<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Nano Banana Pro | Future Lab Edition</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üçå</text></svg>">
  
  <style>
    :root {
      zoom: 1.1; 
      --bg-color: #f0f2f5;
      --bg-pattern: #e2e8f0;
      --panel-bg: rgba(255, 255, 255, 0.9);
      --panel-border: #cbd5e1;
      --panel-shadow: rgba(148, 163, 184, 0.15);
      --text-main: #334155;
      --text-sub: #64748b;
      --text-accent: #0f172a;
      --primary-grad-start: #fbbf24;
      --primary-grad-end: #f59e0b;
      --primary-shadow: rgba(245, 158, 11, 0.3);
      --tech-blue: #3b82f6;
      --tech-blue-bg: #eff6ff;
      --error-bg: #fef2f2;
      --error-border: #fecaca;
      --error-text: #ef4444;
      --radius-panel: 12px;
      --radius-input: 6px;
      --radius-btn: 6px;
      --font-sans: "Inter", system-ui, -apple-system, sans-serif;
      --font-mono: "JetBrains Mono", "SF Mono", monospace;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 32px 24px;
      background-color: var(--bg-color);
      color: var(--text-main);
      font-family: var(--font-sans);
      background-image: radial-gradient(var(--bg-pattern) 1.5px, transparent 1.5px);
      background-size: 24px 24px;
      min-height: 100vh;
    }

    header {
      max-width: 1180px;
      margin: 0 auto 24px;
      border-bottom: 1px dashed var(--panel-border);
      padding-bottom: 16px;
      position: relative;
    }

    h1 {
      margin: 0 0 8px;
      font-size: 26px;
      font-weight: 700;
      letter-spacing: -0.02em;
      color: var(--text-accent);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    h1::before {
        content: '';
        display: block;
        width: 6px;
        height: 24px;
        background: linear-gradient(to bottom, var(--primary-grad-start), var(--primary-grad-end));
        border-radius: 2px;
    }

    .subtitle {
      font-size: 13px;
      color: var(--text-sub);
      font-family: var(--font-mono);
      opacity: 0.9;
    }

    .app {
      max-width: 1180px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 440px 1fr;
      gap: 24px;
      align-items: stretch;
    }

    @media (max-width: 960px) {
      .app { grid-template-columns: minmax(0, 1fr); }
    }

    section {
      background: var(--panel-bg);
      border-radius: var(--radius-panel);
      border: 1px solid white;
      padding: 24px;
      box-shadow: 
        0 0 0 1px var(--panel-border),
        0 10px 30px -10px var(--panel-shadow);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    
    section:hover {
        box-shadow: 
        0 0 0 1px #94a3b8,
        0 15px 35px -10px var(--panel-shadow);
    }

    section + section { margin-top: 0; }

    .section-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      color: var(--text-accent);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      border-bottom: 2px solid #f1f5f9;
      padding-bottom: 8px;
    }

    .section-title .pill {
      font-size: 10px;
      padding: 3px 8px;
      border-radius: 4px;
      background: var(--tech-blue-bg);
      color: var(--tech-blue);
      border: 1px solid rgba(59, 130, 246, 0.2);
      font-family: var(--font-mono);
      font-weight: 600;
    }

    label {
      font-size: 12px;
      font-weight: 600;
      display: block;
      margin-bottom: 6px;
      color: var(--text-sub);
      font-family: var(--font-sans);
    }

    input[type="text"],
    input[type="password"],
    textarea,
    select,
    input[type="number"] {
      width: 100%;
      font-family: var(--font-sans);
      font-size: 13px;
      padding: 10px 12px;
      border-radius: var(--radius-input);
      border: 1px solid #cbd5e1;
      background: #f8fafc;
      color: var(--text-accent);
      outline: none;
      transition: all 0.2s ease;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.03);
    }
    
    input:focus,
    textarea:focus,
    select:focus {
      background: #ffffff;
      border-color: var(--tech-blue);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
    }

    input[type="checkbox"] {
      accent-color: var(--primary-grad-end);
      width: 16px;
      height: 16px;
      margin-right: 8px;
      vertical-align: sub;
      cursor: pointer;
    }

    textarea {
      resize: vertical;
      min-height: 120px;
      max-height: 220px;
      line-height: 1.6;
      font-family: var(--font-mono);
      font-size: 12px;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr 1fr 100px; 
      gap: 12px;
      margin-bottom: 16px;
      align-items: start;
    }
    
    .small-text {
      font-size: 10px;
      color: #94a3b8;
      margin-top: 5px;
      font-family: var(--font-mono);
      line-height: 1.4;
    }

    .api-input {
      position: relative;
      margin-bottom: 16px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .api-key-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .api-key-row {
      display: grid;
      grid-template-columns: 1fr auto auto;
      gap: 8px;
      align-items: center;
    }

    .api-key-row input {
      padding-right: 12px;
      font-family: var(--font-mono);
      letter-spacing: -0.5px;
    }

    .api-key-row button {
      font-size: 10px;
      padding: 4px 10px;
      border-radius: 4px;
      border: 1px solid #bfdbfe;
      background: #eff6ff;
      color: #2563eb;
      cursor: pointer;
      font-weight: 600;
      height: 30px;
    }

    .api-key-row button.danger-action {
      border-color: #fecaca;
      background: #fff1f2;
      color: #dc2626;
    }

    .api-key-row button:hover:not(.danger-action) { background: #dbeafe; }

    .api-input-actions {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .folder-status {
      font-size: 12px;
      font-family: var(--font-mono);
      color: var(--text-sub);
      margin-top: 8px;
    }

    .folder-status strong { color: var(--text-accent); }

    button.primary,
    button.secondary,
    button.danger-action,
    .btn-mini {
      font-family: var(--font-sans);
      border-radius: var(--radius-btn);
      padding: 8px 16px;
      border: none;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
      white-space: nowrap;
      font-size: 13px;
      font-weight: 600;
    }

    button.primary {
      background: linear-gradient(135deg, var(--primary-grad-start), var(--primary-grad-end));
      color: #3f2203;
      box-shadow: 0 4px 12px var(--primary-shadow), inset 0 1px 0 rgba(255,255,255,0.3);
      border: 1px solid rgba(251, 191, 36, 0.5);
    }
    button.primary:disabled { filter: grayscale(0.8); opacity: 0.6; cursor: not-allowed; }
    button.primary:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px var(--primary-shadow), inset 0 1px 0 rgba(255,255,255,0.4);
      filter: brightness(1.05);
    }
    button.primary:not(:disabled):active { transform: translateY(1px); box-shadow: 0 2px 4px var(--primary-shadow); }

    button.secondary {
      background: #ffffff;
      color: var(--text-main);
      border: 1px solid #cbd5e1;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    button.secondary:hover { background: #f8fafc; border-color: #94a3b8; }

    button.danger-action {
        background: #fff1f2;
        color: #be123c;
        border: 1px solid #fda4af;
    }
    button.danger-action:hover { background: #ffe4e6; }

    .btn-mini {
      border-radius: 4px;
      padding: 4px 10px;
      font-size: 11px;
      background: #ffffff;
      border: 1px solid #e2e8f0;
      color: var(--text-sub);
      box-shadow: 0 1px 2px rgba(0,0,0,0.02);
    }
    .btn-mini:hover { border-color: #cbd5e1; background: #f8fafc; color: var(--text-main); }
    .btn-mini.drag-page-hover {
      border-color: #60a5fa;
      background: #eff6ff;
      color: #1d4ed8;
      box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.25);
    }
    .btn-mini.danger { color: #dc2626; border-color: #fecaca; background: #fef2f2; }
    .btn-mini.info { color: #2563eb; background: #eff6ff; border-color: #bfdbfe; }
    .btn-mini.info:hover { background: #dbeafe; }

    .actions {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 16px;
      margin-bottom: 8px;
      flex-wrap: wrap;
      padding-top: 16px;
      border-top: 1px dashed #e2e8f0;
    }

    .status {
      font-size: 12px;
      font-family: var(--font-mono);
      color: var(--text-sub);
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: auto;
      background: #f1f5f9;
      padding: 4px 10px;
      border-radius: 99px;
    }
    .status.error { color: #dc2626; background: #fef2f2; }

    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #cbd5e1;
      box-shadow: 0 0 0 2px rgba(203, 213, 225, 0.4);
    }
    .status-dot.ok { background: #10b981; box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2); }
    .status-dot.busy {
      background: #f59e0b;
      box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.2);
      animation: pulse 1.5s infinite;
    }
    .status-dot.error { background: #ef4444; box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.2); }

    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.7); }
      70% { box-shadow: 0 0 0 6px rgba(245, 158, 11, 0); }
      100% { box-shadow: 0 0 0 0 rgba(245, 158, 11, 0); }
    }

    .drop-zone {
      border-radius: 8px;
      border: 1px dashed #cbd5e1;
      background: #f8fafc;
      padding: 24px;
      text-align: center;
      font-size: 12px;
      color: var(--text-sub);
      margin-bottom: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      background-image: repeating-linear-gradient(45deg, #f8fafc, #f8fafc 10px, #f1f5f9 10px, #f1f5f9 20px);
    }
    .drop-zone strong {
      color: var(--primary-grad-end);
      font-weight: 600;
      display: block;
      font-size: 14px;
      margin-bottom: 4px;
    }
    .drop-zone:hover { border-color: #94a3b8; }
    .drop-zone.active {
      border-color: var(--primary-grad-end);
      background: #fffbeb;
      box-shadow: 0 0 0 4px rgba(251, 191, 36, 0.1);
    }

    .ref-input-row {
      display: flex;
      align-items: center;
      gap: 12px;
      justify-content: space-between;
      margin-bottom: 8px;
      background: white;
      padding: 6px;
      border-radius: 6px;
      border: 1px solid #e2e8f0;
    }
    .ref-input-row-left { display: flex; gap: 8px; align-items: center; flex: 1; }
    .ref-input-row input[type="file"] {
      font-size: 11px;
      color: var(--text-sub);
      border: none;
      background: transparent;
      padding: 0;
      width: 100%;
    }
    .ref-input-row input[type="file"]::file-selector-button {
        font-family: var(--font-sans);
        font-size: 11px;
        font-weight: 500;
        color: var(--text-main);
        background-color: #f1f5f9;
        border: 1px solid #cbd5e1;
        border-radius: 4px;
        padding: 3px 8px;
        margin-right: 8px;
        cursor: pointer;
        transition: all 0.2s;
    }
    .ref-input-row input[type="file"]::file-selector-button:hover { background-color: #e2e8f0; }

    .ref-image-list { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px; }
    .ref-image-item {
      position: relative;
      border-radius: 6px;
      border: 1px solid #e2e8f0;
      background: white;
      padding: 4px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      width: 100px;
      overflow: hidden;
      box-shadow: 0 2px 5px rgba(0,0,0,0.03);
    }
    .ref-thumb-wrap {
      width: 100%;
      border-radius: 3px;
      overflow: hidden;
      background: #e2e8f0;
      cursor: zoom-in;
    }
    .ref-thumb-wrap img {
      width: 100%;
      height: 60px;
      object-fit: cover;
      display: block;
      transition: transform 0.3s ease;
    }
    .ref-thumb-wrap:hover img { transform: scale(1.1); }

    .ref-meta { display: flex; align-items: center; justify-content: space-between; gap: 4px; }
    .ref-name {
      font-size: 9px;
      color: var(--text-sub);
      font-family: var(--font-mono);
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      max-width: 55px;
    }
    .ref-count-hint { font-size: 11px; color: #94a3b8; font-family: var(--font-mono); margin-top: 4px; }

    .results-panel {
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .results-scroll {
      position: relative;
      overflow: visible;
    }

    @media (min-width: 961px) {
      .results-panel {
        max-height: none;
      }
    }

    .results-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 16px;
    }
    .results-header-title { font-size: 14px; font-weight: 700; color: var(--text-accent); }
    .results-header-sub { font-size: 11px; color: var(--text-sub); }
    .results-header-right { display: flex; align-items: center; gap: 12px; }

    .results {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 16px;
      min-height: 200px;
      position: relative;
    }
    .results-drop-hint {
      position: absolute;
      inset: 8px;
      border: 2px dashed #cbd5e1;
      border-radius: 12px;
      background: rgba(248, 250, 252, 0.9);
      color: #475569;
      font-size: 13px;
      font-weight: 600;
      display: none;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 16px;
      z-index: 5;
      pointer-events: none;
    }
    .results-drop-hint span { display: block; font-size: 11px; font-weight: 500; color: #94a3b8; margin-top: 6px; }
    .results-drop-hint.visible { display: flex; }
    .results-footer {
      margin-top: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .results-pagination {
      padding: 10px 12px;
      border: 1px dashed var(--panel-border);
      border-radius: var(--radius-panel);
      background: rgba(248, 250, 252, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
    }

    .page-indicator {
      font-size: 11px;
      color: var(--text-sub);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-family: var(--font-mono);
      min-width: 90px;
      text-align: center;
    }

    .result-card {
      border-radius: 8px;
      background: #ffffff;
      border: 1px solid #e2e8f0;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      position: relative;
      overflow: hidden;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.02);
      content-visibility: auto;
      contain-intrinsic-size: 160px 250px;
    }
    .result-card.drag-hold {
      position: fixed;
      left: -9999px;
      top: -9999px;
      width: 1px;
      height: 1px;
      opacity: 0;
      pointer-events: none;
    }
    .result-card.unseen {
      border: 2px solid #ef4444;
      /* box-shadow: 0 0 0 1px rgba(239, 68, 68, 0.35); */
      background-color: #fef2f2;
    }
    .result-card.locator-highlight {
      border-color: #a855f7 !important;
      background-color: #f3e8ff !important;
      box-shadow: 0 0 0 4px rgba(168, 85, 247, 0.4) !important;
      transform: scale(1.02);
      z-index: 10;
      transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    .result-card.drag-sort-before::before,
    .result-card.drag-sort-after::after {
      content: "";
      position: absolute;
      left: 8px;
      right: 8px;
      height: 2px;
      border-radius: 999px;
      background: var(--tech-blue);
      box-shadow: 0 0 8px rgba(59,130,246,0.4);
    }
    .result-card.drag-sort-before::before { top: 2px; }
    .result-card.drag-sort-after::after { bottom: 2px; }
    .result-card:hover {
      transform: translateY(-2px);
      border-color: #cbd5e1;
      box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.08), 0 4px 6px -2px rgba(0, 0, 0, 0.04);
    }

        body.compare-select-mode {
            cursor: crosshair;
        }
        body.compare-select-mode .result-card {
            outline: 2px dashed rgba(16, 185, 129, 0.5);
            outline-offset: -4px;
        }
        .result-card.compare-select-picked {
            border-color: #34d399 !important;
            box-shadow: 0 0 0 2px rgba(52, 211, 153, 0.5), 0 15px 35px -10px rgba(16, 185, 129, 0.6);
        }
        .compare-select-hint {
            position: fixed;
            top: 24px;
            right: 24px;
            background: rgba(15, 23, 42, 0.92);
            color: #e2e8f0;
            padding: 10px 18px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.04em;
            border: 1px solid rgba(255,255,255,0.18);
            box-shadow: 0 15px 35px rgba(15,23,42,0.35);
            opacity: 0;
            transform: translateY(-10px);
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            z-index: 2000;
            font-family: var(--font-sans);
        }
        .compare-select-hint.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        .compare-overlay {
            position: fixed;
            inset: 0;
            background: rgba(2, 6, 23, 0.97);
            display: flex;
            z-index: 10000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }
        .compare-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .compare-view {
            position: relative;
            width: 100%;
            height: 100%;
            background: #010714;
            overflow: hidden;
            --split: 50%;
        }
        .compare-view.zoomed { cursor: grab; }
        .compare-view.zoomed.compare-dragging { cursor: grabbing; }
        .compare-view-canvas {
            position: absolute;
            inset: 0;
            /* will-change: transform; removed to prevent blurriness on high-res images */
        }
        .compare-view img {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #0f172a;
            user-select: none;
            pointer-events: none;
        }
        .compare-view img.compare-right {
            clip-path: inset(0 calc(100% - var(--split)) 0 0);
        }
        .compare-divider {
            position: absolute;
            top: 0;
            bottom: 0;
            left: var(--split);
            width: 2px;
            background: rgba(255,255,255,0.85);
            cursor: ew-resize;
            box-shadow: 0 0 12px rgba(0,0,0,0.45);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .compare-divider::before {
            content: "";
            position: absolute;
            top: 0;
            bottom: 0;
            left: -20px;
            right: -20px;
            cursor: ew-resize;
        }
        .compare-divider::after {
            content: "";
            width: 14px;
            height: 56px;
            border-radius: 14px;
            background: rgba(15,23,42,0.92);
            border: 1px solid rgba(255,255,255,0.18);
            box-shadow: 0 12px 30px rgba(0,0,0,0.45);
            pointer-events: none;
        }

    .result-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 10px;
      color: var(--text-sub);
      font-family: var(--font-mono);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .badge {
      font-size: 9px;
      padding: 1px 5px;
      border-radius: 3px;
      background: var(--tech-blue-bg);
      color: var(--tech-blue);
      border: 1px solid rgba(59, 130, 246, 0.2);
      font-weight: 600;
    }
    .badge.retry { background: #fff7ed; color: #c2410c; border-color: #ffedd5; }
    .badge.cancel { background: #f1f5f9; color: #64748b; border-color: #e2e8f0; }

    .thumb-wrap {
      border-radius: 4px;
      overflow: hidden;
      background: #f1f5f9;
      cursor: zoom-in;
      aspect-ratio: 1 / 1;
      position: relative;
      border: 1px solid #f1f5f9;
    }
    .thumb-wrap::before {
        content: '';
        position: absolute;
        inset: 0;
        z-index: 0;
        background-image: 
          linear-gradient(45deg, #e2e8f0 25%, transparent 25%), 
          linear-gradient(-45deg, #e2e8f0 25%, transparent 25%), 
          linear-gradient(45deg, transparent 75%, #e2e8f0 75%), 
          linear-gradient(-45deg, transparent 75%, #e2e8f0 75%);
        background-size: 10px 10px;
        background-position: 0 0, 0 5px, 5px -5px, -5px 0px;
        opacity: 0.3;
    }
    .thumb-wrap img {
      width: 100%;
      height: 100%;
      min-height: 140px;
      object-fit: cover;
      display: block;
      position: relative;
      z-index: 1;
      -webkit-user-drag: element; 
      user-select: none;
      transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    .thumb-wrap:hover img { transform: scale(1.05); }

    .result-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 4px;
      font-size: 10px;
      color: var(--text-sub);
      flex-wrap: wrap;
      font-family: var(--font-mono);
      padding: 0 2px;
    }
    .result-meta span {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .result-actions {
      display: flex;
      justify-content: space-between;
      gap: 6px;
      margin-top: 4px;
    }
    .result-actions > * { flex: 1; min-width: 0; }
    .result-actions a { text-decoration: none; display: flex; }
    .result-actions button, .result-actions a > button {
      width: 100%;
      justify-content: center;
      font-size: 10px;
      height: 24px;
      padding: 0;
    }

    .result-card.skeleton { background: #ffffff; border-color: #e2e8f0; }
    .skeleton-thumb {
      height: 140px;
      border-radius: 4px;
      background: #f1f5f9;
      position: relative;
      overflow: hidden;
    }
    .skeleton-thumb::after {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 50%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);
        animation: scan 1.5s infinite;
    }
    @keyframes scan { 0% { left: -50%; } 100% { left: 150%; } }
    .skeleton-line { height: 6px; border-radius: 2px; background: #f1f5f9; margin-top: 6px; width: 60%; }
    .skeleton-footer { margin-top: 8px; }
    .status-text { font-size: 10px; color: var(--tech-blue); }

    .lightbox {
      position: fixed;
      inset: 0;
      background: rgba(2, 6, 23, 0.99);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }
    .lightbox.visible { opacity: 1; pointer-events: auto; }
    .lightbox-inner {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden; 
    }
    .lightbox-inner img {
      max-width: 90vw;
      max-height: 90vh;
      display: block;
      border-radius: 4px;
      box-shadow: 0 0 0 1px rgba(255,255,255,0.1), 0 20px 50px rgba(0, 0, 0, 0.3);
      background: #0f172a;
      transition: transform 0.2s cubic-bezier(0.2, 0, 0.2, 1);
      cursor: zoom-in;
      transform-origin: center center;
      user-select: none;
      -webkit-user-drag: none;
    }
    .lightbox-inner img.zoomed { cursor: grab; box-shadow: 0 30px 60px rgba(0,0,0,0.5); }
    .lightbox-inner img.zoomed:active { cursor: grabbing; }
    .lightbox-inner img.dragging { transition: none !important; }
    .lightbox-close {
      position: absolute;
      top: 24px;
      right: 24px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(0, 0, 0, 0.5);
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 24px;
      z-index: 10;
      backdrop-filter: blur(4px);
      transition: background 0.2s;
    }
    .lightbox-close:hover { background: rgba(0, 0, 0, 0.7); }

        .lightbox-tools {
            position: absolute;
            inset: 0;
            background: rgba(13, 17, 23, 0.95);
            color: #e2e8f0;
            backdrop-filter: blur(10px);
            opacity: 0;
            pointer-events: none;
            z-index: 20;
            transition: opacity 0.2s ease;
            display: flex;
            flex-direction: column;
        }
        .lightbox-tools.active { opacity: 1; pointer-events: auto; }
        .lightbox-tools-container {
            display: flex;
            flex-direction: row;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        .lightbox-main-area {
            flex: 1;
            position: relative;
            background: #000;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .lightbox-sidebar {
            width: 320px;
            flex-shrink: 0;
            background: rgba(13, 17, 23, 0.95);
            border-left: 1px solid rgba(255,255,255,0.1);
            padding: 24px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            box-shadow: -5px 0 20px rgba(0,0,0,0.3);
        }
        .lightbox-tools-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }
        .lightbox-tools-title { font-weight: 700; letter-spacing: 0.02em; font-size: 14px; width: 100%; margin-bottom: 8px; }
        .lightbox-chip {
            font-size: 11px;
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.08);
            color: #cbd5e1;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .lightbox-chip strong { color: #f8fafc; font-weight: 700; }
        .lightbox-field { margin-bottom: 20px; }
        .lightbox-field label { color: #cbd5e1; font-size: 11px; margin-bottom: 6px; display: block; font-weight: 500; }
        .lightbox-inline { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
        .lightbox-inline input,
        .lightbox-inline select,
        .lightbox-inline .range-wrap { width: 100%; }
        .range-wrap input[type="range"] { width: 100%; }
        .lightbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        .lightbox-help { color: #94a3b8; font-size: 11px; margin-top: 4px; line-height: 1.4; }
        
        .lightbox-preview {
            position: relative;
            width: 100%;
            height: 100%;
            background: #0b1221;
            overflow: hidden;
            --split: 50%;
            --split-right: 50%;
        }
        .lightbox-preview-canvas {
            position: absolute;
            inset: 0;
            /* will-change: transform; removed for sharpness */
        }
        .lightbox-preview.zoomed {
            cursor: grab;
        }
        .lightbox-preview.zoomed.dragging {
            cursor: grabbing;
        }
        .lightbox-preview img {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #0f172a;
            user-select: none;
            pointer-events: none;
            /* transition: transform 0.2s ease; removed to prevent blur */
            /* will-change: transform; removed to prevent blur */
        }
        .lightbox-preview .preview-after { clip-path: inset(0 0 0 var(--split)); }
        .lightbox-divider {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: rgba(255,255,255,0.7);
            left: var(--split);
            cursor: ew-resize;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        .lightbox-divider::before {
            content: '';
            position: absolute;
            top: 0; bottom: 0;
            width: 40px;
            left: -19px;
            z-index: 10;
            cursor: ew-resize;
        }
        .lightbox-divider::after {
            content: '';
            width: 12px;
            height: 52px;
            border-radius: 12px;
            background: rgba(15,23,42,0.9);
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 8px 24px rgba(0,0,0,0.35);
            pointer-events: none;
        }
        .lightbox-stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: auto;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        .lightbox-stat {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 12px;
            color: #cbd5e1;
        }
        .lightbox-stat strong { color: #f8fafc; font-weight: 700; }
        .lightbox-actions { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin-top: 6px; }
        .pill { display: inline-flex; align-items: center; gap: 6px; padding: 4px 8px; border-radius: 8px; background: rgba(255,255,255,0.05); color: #cbd5e1; border: 1px solid rgba(255,255,255,0.08); font-size: 11px; }
    
    .config-group {
        display: flex;
        align-items: center;
        gap: 12px;
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 6px;
        padding: 8px 12px;
        margin-bottom: 16px;
    }
    .config-group label {
        margin: 0;
        cursor: pointer;
        display: flex;
        align-items: center;
        flex: 1;
        font-weight: 500;
        color: var(--text-main);
    }
    .config-group input[type="number"] { width: 60px; padding: 4px 8px; font-size: 12px; background: #fff; }

    .list-bar {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }

    .list-tabs {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .list-tab {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid #e2e8f0;
      background: #fff;
      font-size: 12px;
      cursor: pointer;
      font-weight: 600;
      color: var(--text-sub);
      position: relative;
    }

    .list-tab.active {
      border-color: #bfdbfe;
      background: #eff6ff;
      color: #1d4ed8;
    }

    .list-tab.drop-target {
      border-color: #22c55e;
      background: #ecfdf5;
      color: #15803d;
    }

    .list-tab.dragging {
      opacity: 0.5;
      background: #e2e8f0;
      border-style: dashed;
    }

    .list-tab.drag-over-left {
      border-left: 2px solid var(--tech-blue);
      margin-left: -2px; /* Prevent jitter */
    }
    
    .list-tab.drag-over-right {
      border-right: 2px solid var(--tech-blue);
      margin-right: -2px;
    }

    .timestamp-badge {
      font-size: 12px;
      font-family: var(--font-mono);
      color: var(--text-sub);
    }

    .fs-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.65);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .fs-overlay.hidden { display: none; }

    .fs-overlay .overlay-panel {
      background: #fff;
      border-radius: 16px;
      padding: 32px;
      max-width: 420px;
      width: calc(100% - 48px);
      box-shadow: 0 20px 60px rgba(15,23,42,0.25);
      text-align: center;
    }

    .fs-overlay h2 {
      margin-top: 0;
      margin-bottom: 12px;
    }

    .fs-overlay p {
      font-size: 13px;
      color: var(--text-sub);
      line-height: 1.6;
      margin-bottom: 20px;
    }

    .fs-overlay .btn-row {
      display: flex;
      justify-content: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .fs-overlay .status {
      justify-content: center;
      margin-top: 16px;
    }

    .import-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.65);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1100;
    }
    .import-overlay.hidden { display: none; }
    .import-panel {
      background: #fff;
      border-radius: 16px;
      padding: 24px;
      width: min(480px, calc(100% - 48px));
      box-shadow: 0 20px 60px rgba(15,23,42,0.25);
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .import-panel h2 {
      margin: 0;
      font-size: 18px;
      color: var(--text-accent);
    }
    .import-preview {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    .import-preview img {
      width: 96px;
      height: 96px;
      object-fit: cover;
      border-radius: 12px;
      border: 1px solid #e2e8f0;
      background: #f8fafc;
    }
    .import-preview .import-filename {
      font-size: 12px;
      color: var(--text-sub);
      font-family: var(--font-mono);
      word-break: break-all;
    }
    .import-panel .import-field {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 12px;
      color: var(--text-sub);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-weight: 600;
    }
    .import-panel textarea,
    .import-panel input[type="text"] {
      width: 100%;
      border: 1px solid #e2e8f0;
      border-radius: var(--radius-input);
      padding: 8px 10px;
      font-size: 13px;
      font-family: var(--font-sans);
      background: #f8fafc;
    }
    .import-panel textarea {
      min-height: 80px;
      resize: vertical;
    }
    .import-meta-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 12px;
    }
    .import-meta-grid label {
      font-size: 12px;
      color: var(--text-sub);
      display: flex;
      flex-direction: column;
      gap: 4px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-weight: 600;
    }
    .import-actions {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
    }

    .list-move-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.65);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1150;
    }
    .list-move-overlay.hidden { display: none; }
    .list-move-panel {
      background: #fff;
      border-radius: 16px;
      padding: 22px 24px;
      width: min(420px, calc(100% - 48px));
      box-shadow: 0 20px 60px rgba(15,23,42,0.25);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .list-move-panel-title {
      font-size: 14px;
      font-weight: 700;
      color: var(--text-accent);
      letter-spacing: 0.08em;
    }
    .list-move-panel-desc {
      margin: 0;
      font-size: 12px;
      color: var(--text-sub);
    }
    .list-move-panel-controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .list-move-panel-controls select {
      flex: 1;
      border-radius: var(--radius-input);
      border: 1px solid #cbd5e1;
      padding: 6px 8px;
      font-size: 12px;
      font-family: var(--font-sans);
      background: #fff;
      color: var(--text-main);
      min-width: 0;
    }
    .list-move-panel-controls select:disabled {
      background: #f1f5f9;
      color: #94a3b8;
    }
    .list-move-panel-hint {
      font-size: 11px;
      color: var(--text-sub);
      font-family: var(--font-mono);
    }
    .list-move-panel-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }
    /* New Edit Modes */
    #lightboxEditTools .lightbox-main-area {
        background-color: #0f172a; 
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    #lbEditWrapper {
        box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        display: block;
    }
    .crop-handle {
        z-index: 100;
        border: 1px solid rgba(0,0,0,0.2);
        box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    #lbMaskTools input[type=range] {
        background: rgba(255,255,255,0.2);
        border: none;
        height: 4px;
        padding: 0;
    }
    #lbMaskTools input[type=range]::-webkit-slider-thumb {
        -webkit-appearance: none;
        background: white;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-top: -4px; 
    }
  </style>
</head>
<body>
  <div id="fsOverlay" class="fs-overlay hidden" aria-modal="true" role="dialog">
    <div class="overlay-panel">
      <h2>Local Storage Authorization</h2>
      <p>On first use you need to choose a local folder and grant read/write access so generated images and metadata can be saved automatically. Authorization must be granted again every time you open the app.</p>
      <div class="btn-row">
        <button id="selectFolderBtn" class="primary" type="button">Choose or Authorize Folder</button>
      </div>
      <div class="status" id="fsPermissionStatus">
        <span class="status-dot"></span>
        <span>Awaiting authorization</span>
      </div>
    </div>
  </div>
  <div id="importOverlay" class="import-overlay hidden" aria-modal="true" role="dialog">
    <div class="import-panel" role="document">
      <h2>Import Image</h2>
      <div class="import-preview">
        <img id="importPreview" src="" alt="Import preview" style="display:none;" />
        <div class="import-filename" id="importFilename">Awaiting file selection</div>
      </div>
      <label class="import-field">
        PROMPT NOTE
        <textarea id="importPromptInput" placeholder="Optional: capture the prompt or annotations for this image"></textarea>
      </label>
      <div class="import-meta-grid">
        <label>
          RESOLUTION
          <input type="text" id="importResolutionInput" placeholder="e.g. 1024x1024" />
        </label>
        <label>
          ASPECT
          <input type="text" id="importAspectInput" placeholder="e.g. 1:1" />
        </label>
      </div>
      <div class="import-actions">
        <button id="importCancelBtn" class="btn-mini danger" type="button">Cancel</button>
        <button id="importConfirmBtn" class="btn-mini info" type="button">Import</button>
      </div>
    </div>
  </div>

  <div id="customTaskOverlay" class="import-overlay hidden" aria-modal="true" role="dialog">
    <div class="import-panel" role="document" style="width: 600px;">
      <h2>Custom Task Submission (Fal AI)</h2>
      <div style="margin-bottom: 12px;">
        <label for="customEndpoint" style="display:block; margin-bottom: 6px; font-size:12px; font-weight:600; color:var(--text-sub);">ENDPOINT (model path)</label>
        <input type="text" id="customEndpoint" placeholder="e.g. fal-ai/fast-sdxl" style="width:100%; font-family:var(--font-mono);">
      </div>
      
      <div style="margin-bottom: 16px; border: 1px solid #e2e8f0; border-radius: 6px; padding: 12px; background: #f8fafc; max-height: 300px; display: flex; flex-direction: column;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <label style="margin:0;">PAYLOAD CONFIGURATION</label>
            <button id="addPayloadItemBtn" class="btn-mini info" type="button" style="padding: 2px 8px; font-size: 11px;">+ Add Item</button>
        </div>
        <div id="payloadList" style="display: flex; flex-direction: column; gap: 8px; overflow-y: auto;">
            <!-- Payload items will be injected here -->
        </div>
      </div>

      <div class="import-actions">
        <button id="customTaskCancelBtn" class="btn-mini danger" type="button">Cancel</button>
        <button id="customTaskSubmitBtn" class="btn-mini primary" type="button">Submit Task</button>
      </div>
    </div>
  </div>
  <header style="position: relative;">
    <h1>Nano Banana Pro <span style="font-size: 12px; background: var(--text-accent); color: #fff; padding: 2px 6px; border-radius: 4px; vertical-align: middle; margin-left: 8px; font-family: var(--font-mono);">LAB</span></h1>
    <div class="subtitle">
      // PARALLEL EXECUTION PROTOCOL : GEMINI 3 PRO PREVIEW
    </div>
    <div class="folder-status" id="folderStatus">No output directory bound</div>
    <button id="rebindFolderBtn" class="btn-mini info" type="button" style="margin-top:6px;">Re-authorize</button>
    <button id="resetAppBtn" class="btn-mini" type="button" style="position: absolute; top: 0; right: 0; border-color: #fecaca; color: #ef4444; background: #fff;">‚ö† RESET ALL</button>
  </header>

  <main class="app">
    <section>
      <div class="section-title">
        CONFIGURATION
        <span class="pill">Gemini 3 Pro</span>
      </div>

      <div style="margin-bottom: 16px;">
        <label for="providerSelect">PROVIDER</label>
        <select id="providerSelect">
          <option value="google" selected>Google</option>
          <option value="fal">Fal AI</option>
        </select>
        <div id="providerHint" class="small-text" style="display:none;"></div>
      </div>

            <div id="falModelGroup" class="config-group" style="display:none; margin-top: -4px;">
                <label for="falModelSelect">FAL MODEL</label>
                <select id="falModelSelect">
                    <option value="default" selected>default (z-image-turbo)</option>
                    <option value="qwen-image">qwen-image</option>
                </select>
                <div class="small-text" style="margin-top: 4px;">Applies only when provider is Fal AI.</div>
            </div>

      <div class="api-input">
        <label id="apiKeyLabel">API KEY ACCESS</label>
        <div id="apiKeyProviderHint" class="small-text" style="margin-top:0;"></div>
        <div id="apiKeyList" class="api-key-list"></div>
        <div class="api-input-actions">
          <button id="addApiKeyBtn" class="btn-mini info" type="button">+ Add Key</button>
          <button id="getKeyBtn" class="btn-mini" type="button">Get Key</button>
          <span class="small-text" style="margin-top:0;">Cycle through multiple keys in order</span>
        </div>
      </div>
      
      <div class="config-group">
          <label>
              <input type="checkbox" id="enableRetry">
              Auto-Retry Protocol
          </label>
          <div style="display: flex; align-items: center; gap: 8px;">
              <span class="small-text" style="margin-top:0;">LIMIT</span>
              <input type="number" id="maxRetries" value="3" min="1" max="20">
          </div>
      </div>

      <div class="row">
        <div>
          <label for="resolution">RESOLUTION</label>
          <select id="resolution">
            <option value="1K">1K [STD]</option>
            <option value="2K" selected>2K [HD]</option>
            <option value="4K">4K [UHD]</option>
          </select>
        </div>
        <div>
          <label for="aspectRatio">ASPECT RATIO</label>
          <select id="aspectRatio">
            <option value="1:1">1 : 1</option>
            <option value="3:2">3 : 2</option>
            <option value="2:3">2 : 3</option>
            <option value="4:3">4 : 3</option>
            <option value="3:4" selected>3 : 4</option>
            <option value="5:4">5 : 4</option>
            <option value="4:5">4 : 5</option>
            <option value="16:9">16 : 9</option>
            <option value="9:16">9 : 16</option>
            <option value="21:9">21 : 9</option>
          </select>
        </div>
        <div>
          <label for="count">BATCH</label>
          <input id="count" type="number" min="1" max="20" value="1" />
        </div>
      </div>

      <div style="margin-top: 4px; margin-bottom: 12px;">
  <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px;">
    <label for="prompt" style="margin-bottom: 0;">PROMPT DATA</label>
    <button id="clearPromptBtn" class="btn-mini" type="button" style="font-size: 10px; padding: 2px 8px; height: auto; border-color: #e2e8f0; color: #64748b;">CLEAR</button>
  </div>
  <textarea id="prompt" placeholder="Input generation parameters..."></textarea>
</div>

      <div style="margin-top: 12px;">
        <label>REFERENCE INPUT (Multi-Modal)</label>
        <div id="dropZone" class="drop-zone">
          <strong>DRAG & DROP IMAGE DATA HERE</strong>
          <span style="font-size: 10px; opacity: 0.6;">Supports internal result dragging</span>
        </div>

        <div class="ref-input-row">
          <div class="ref-input-row-left">
              <input id="refImages" type="file" accept="image/*" multiple />
          </div>
          <button class="btn-mini info" type="button" id="pasteRefBtn" title="Paste from clipboard">PASTE</button>
          <button class="btn-mini" type="button" id="clearAllRefsBtn" style="margin-left: 6px;">CLEAR</button>
        </div>

        <div id="refImageHint" class="ref-count-hint">No reference data loaded.</div>
        <div id="refImageList" class="ref-image-list"></div>
      </div>

      <div class="actions">
        <button id="generateBtn" class="primary" type="button">üçå INITIALIZE</button>
        <button id="cancelAllBtn" class="danger-action" type="button" style="display:none;">ABORT ALL</button>
        <button id="clearResultsBtn" class="secondary" type="button">PURGE</button>
        <div id="status" class="status">
          <span class="status-dot"></span>
          <span>READY</span>
        </div>
      </div>
    </section>

    <section class="results-panel">
      <div class="results-header">
        <div>
          <div class="results-header-title">OUTPUT STREAM</div>
          <div class="results-header-sub">Pan & Zoom: Click to inspect, Drag to move. Arrow Keys to Switch.</div>
        </div>
        <div class="results-header-right">
          <button id="importBtn" class="btn-mini" type="button">IMPORT IMAGE</button>
        </div>
      </div>
      <div class="list-bar">
        <div id="listTabs" class="list-tabs"></div>
        <button id="addListBtn" class="btn-mini info" type="button" title="Create list" aria-label="Create new list">+</button>
        <button id="removeListBtn" class="btn-mini danger" type="button" title="Delete current list" aria-label="Delete current list">-</button>
      </div>
      <div class="results-scroll">
        <div id="results" class="results">
          <div id="resultsDropHint" class="results-drop-hint" aria-hidden="true">
            Drag images here<span>or click the "Import" button</span>
          </div>
        </div>
      </div>
      <div class="results-footer">
        <div id="resultsPagination" class="results-pagination" aria-label="Pagination controls">
          <button id="pagePrevBtn" class="btn-mini" type="button">Prev</button>
          <div id="pageIndicator" class="page-indicator">Page 1 / 1</div>
          <button id="pageNextBtn" class="btn-mini" type="button">Next</button>
        </div>
      </div>
      <input type="file" id="importInput" accept="image/*" multiple style="display:none;" />
    </section>
  </main>

  <div id="listMoveOverlay" class="list-move-overlay hidden" aria-modal="true" role="dialog">
    <div class="list-move-panel" role="document">
      <div class="list-move-panel-title">LIST TRANSFER</div>
      <p class="list-move-panel-desc">Move every task from the current list to another list.</p>
      <div class="list-move-panel-controls">
        <select id="listMoveAllSelect">
          <option value="">No other lists yet</option>
        </select>
      </div>
      <div class="list-move-panel-hint" id="listMoveAllHint">No tasks in the current list</div>
      <div class="list-move-panel-actions">
        <button id="listMoveCancelBtn" class="btn-mini danger" type="button">Cancel</button>
        <button id="listMoveAllBtn" class="btn-mini info" type="button">Move All</button>
      </div>
    </div>
  </div>

    <div id="compareSelectHint" class="compare-select-hint" aria-live="polite">
        Compare mode: select two task cards
    </div>

    <div id="compareOverlay" class="compare-overlay" aria-hidden="true">
        <div class="compare-view" id="compareView" style="--split:50%;">
            <div class="compare-view-canvas" id="compareViewCanvas">
                <img id="compareImgLeft" alt="Compare left" draggable="false" />
                <img id="compareImgRight" class="compare-right" alt="Compare right" draggable="false" />
                <div class="compare-divider" id="compareDivider"></div>
            </div>
        </div>
    </div>

  <div id="lightbox" class="lightbox" aria-hidden="true">
    <div class="lightbox-inner">
      <button type="button" class="lightbox-close" aria-label="Close preview">√ó</button>
      <img id="lightboxImage" src="" alt="Preview image" draggable="false" />
            <div id="lightboxTools" class="lightbox-tools" aria-live="polite">
                <div class="lightbox-tools-container">
                    <div class="lightbox-main-area">
                        <div class="lightbox-preview" id="lbPreview" style="--split:50%;">
                            <div class="lightbox-preview-canvas" id="lbPreviewCanvas">
                                <img id="lbPreviewBefore" alt="Original" />
                                <img id="lbPreviewAfter" class="preview-after" alt="Compressed" />
                                <div class="lightbox-divider" id="lbPreviewDivider"></div>
                            </div>
                        </div>
                    </div>
                    <div class="lightbox-sidebar">
                        <div class="lightbox-tools-header">
                            <div class="lightbox-tools-title">Compression / Resampling Lab (R)</div>
                            <div class="lightbox-chip" id="lbSourceInfo"></div>
                            <div class="lightbox-chip" id="lbSizeInfo"></div>
                            <div class="lightbox-chip pill" id="lbStatusChip">Pending</div>
                            <div class="lightbox-actions" style="margin-left:auto;">
                                <button type="button" class="btn-mini" id="lbRefreshPreviewBtn">Refresh Preview</button>
                                <button type="button" class="btn-mini info" id="lbSaveCompressedBtn">Compress & New Card</button>
                                <button type="button" class="btn-mini danger" id="lbReplaceCompressedBtn">Compress & Replace</button>
                                <button type="button" class="btn-mini" id="lbExitCompressBtn">Exit</button>
                            </div>
                        </div>

                        <div class="lightbox-field">
                            <label for="lbResizeMode">Resize Options</label>
                            <select id="lbResizeMode">
                                <option value="scale">Scale proportionally</option>
                                <option value="custom">Custom resolution</option>
                            </select>
                            <div class="lightbox-help">Enter a percentage or a specific resolution.</div>
                        </div>
                        <div class="lightbox-field" id="lbScaleRow">
                            <label for="lbScaleInput">Scale (%)</label>
                            <div class="lightbox-row">
                                <input type="range" id="lbScaleInput" min="10" max="100" step="1" value="100" />
                                <input type="number" id="lbScaleNumber" min="10" max="100" step="1" value="100" style="width:82px;" />
                            </div>
                        </div>
                        <div class="lightbox-field" id="lbCustomRow" style="display:none;">
                            <label>Target resolution</label>
                            <div class="lightbox-inline">
                                <input type="number" id="lbCustomWidth" min="16" step="1" placeholder="Width" />
                                <input type="number" id="lbCustomHeight" min="16" step="1" placeholder="Height" />
                                <label class="lightbox-row" style="margin-top:4px;">
                                    <input type="checkbox" id="lbLockAspect" checked />Lock aspect ratio
                                </label>
                            </div>
                        </div>
                        <div class="lightbox-field">
                            <label for="lbQualityInput">Compression quality (%)</label>
                            <div class="lightbox-row">
                                <input type="range" id="lbQualityInput" min="35" max="95" step="1" value="82" />
                                <input type="number" id="lbQualityNumber" min="30" max="100" step="1" value="82" style="width:82px;" />
                            </div>
                            <div class="lightbox-help">Use efficient JPEG compression; drag the divider to compare before/after.</div>
                        </div>
                        
                        <div class="lightbox-stats">
                            <div class="lightbox-stat"><span>Original</span><strong id="lbStatBefore">--</strong></div>
                            <div class="lightbox-stat"><span>Compressed</span><strong id="lbStatAfter">--</strong></div>
                            <div class="lightbox-stat"><span>Savings</span><strong id="lbStatSaved">--</strong></div>
                        </div>
                         <div class="lightbox-actions" style="margin-top: 12px;">
                            <span class="pill" id="lbDimensionHint">--</span>
                            <span class="pill" id="lbQualityHint">Q95</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="lightboxUpscaleTools" class="lightbox-tools" aria-live="polite" style="z-index: 25;">
                <div class="lightbox-tools-container">
                    <div class="lightbox-main-area" style="display:flex;align-items:center;justify-content:center;">
                        <img id="lbUpscalePreview" alt="Upscale Source" style="max-width:100%;max-height:100%;object-fit:contain;" />
                    </div>
                    <div class="lightbox-sidebar">
                        <div class="lightbox-tools-header">
                            <div class="lightbox-tools-title">AI Upscale (SeedVR)</div>
                            <div class="lightbox-chip pill">Press U to exit</div>
                        </div>

                         <div class="lightbox-field">
                            <label for="lbUpscaleFactor">Upscale factor</label>
                            <div class="lightbox-row">
                                <input type="number" id="lbUpscaleFactor" min="1" max="10" step="0.5" value="2" style="width: 100%;" />
                            </div>
                            <div class="lightbox-help">Default: 2. Higher values generate larger images. Recommended max: 4.</div>
                        </div>

                         <div class="lightbox-field">
                            <label for="lbUpscaleNoise">Noise Scale</label>
                            <div class="lightbox-row">
                                <input type="range" id="lbUpscaleNoise" min="0" max="1" step="0.05" value="0.1" style="flex:1;" />
                                <input type="number" id="lbUpscaleNoiseNum" min="0" max="1" step="0.05" value="0.1" style="width:82px;" />
                            </div>
                            <div class="lightbox-help">Controls the creativity/noise added. Default: 0.1.</div>
                        </div>

                        <div class="lightbox-field" style="background:rgba(255,255,255,0.03); padding:10px; border-radius:6px; border:1px solid rgba(255,255,255,0.05);">
                            <div class="small-text" style="color:var(--text-sub); display:flex; flex-direction:column; gap:6px;">
                                <div style="display:flex;justify-content:space-between;">
                                     <span>Current image size:</span>
                                     <span id="lbUpscaleOriginSize" style="font-family:var(--font-mono);">--</span>
                                </div>
                                 <div style="display:flex;justify-content:space-between;">
                                     <span>Upscaled resolution:</span>
                                     <span id="lbUpscaleTargetSize" style="color:var(--tech-blue); font-weight:600; font-family:var(--font-mono);">--</span>
                                </div>
                                 <div style="display:flex;justify-content:space-between;border-top:1px dashed rgba(255,255,255,0.1); padding-top:6px; margin-top:2px;">
                                     <span>Estimated credit cost:</span>
                                     <span id="lbUpscaleCost" style="color:var(--primary-grad-end); font-weight:600; font-family:var(--font-mono);">--</span>
                                </div>
                            </div>
                        </div>

                         <div class="lightbox-actions" style="margin-top:auto;">
                            <button type="button" class="btn-mini primary" id="lbUpscaleSubmitBtn" style="width:100%">Submit task</button>
                            <button type="button" class="btn-mini" id="lbUpscaleExitBtn" style="width:100%; margin-top:8px;">Exit (U)</button>
                        </div>
                    </div>
                </div>
            </div>

            <div id="lightboxEditTools" class="lightbox-tools" aria-live="polite" style="z-index: 26;">
                <div class="lightbox-tools-container">
                    <div class="lightbox-main-area" style="position: relative; display:flex; align-items:center; justify-content:center; background:#0f172a; overflow:hidden;" id="lbEditContainer">
                        <div id="lbEditWrapper" style="position:relative;">
                            <canvas id="lbEditCanvas" style="display:block;"></canvas>
                            
                            <!-- Overlay for cropping -->
                            <div id="lbCropOverlay" style="display:none; position:absolute; top:0; left:0; width:100px; height:100px; box-shadow: 0 0 0 9999px rgba(0,0,0,0.5); border: 2px solid white; cursor: move; touch-action: none;">
                                <!-- Edges -->
                                <div class="crop-handle" data-dir="n" style="position:absolute; width:100%; height:12px; top:-6px; left:0; cursor:n-resize;"></div>
                                <div class="crop-handle" data-dir="s" style="position:absolute; width:100%; height:12px; bottom:-6px; left:0; cursor:s-resize;"></div>
                                <div class="crop-handle" data-dir="w" style="position:absolute; width:12px; height:100%; top:0; left:-6px; cursor:w-resize;"></div>
                                <div class="crop-handle" data-dir="e" style="position:absolute; width:12px; height:100%; top:0; right:-6px; cursor:e-resize;"></div>
                                <!-- Corners (z-index higher) -->
                                <div class="crop-handle" data-dir="nw" style="position:absolute; width:12px; height:12px; background:white; top:-6px; left:-6px; cursor:nw-resize; z-index:10; border-radius:2px;"></div>
                                <div class="crop-handle" data-dir="ne" style="position:absolute; width:12px; height:12px; background:white; top:-6px; right:-6px; cursor:ne-resize; z-index:10; border-radius:2px;"></div>
                                <div class="crop-handle" data-dir="sw" style="position:absolute; width:12px; height:12px; background:white; bottom:-6px; left:-6px; cursor:sw-resize; z-index:10; border-radius:2px;"></div>
                                <div class="crop-handle" data-dir="se" style="position:absolute; width:12px; height:12px; background:white; bottom:-6px; right:-6px; cursor:se-resize; z-index:10; border-radius:2px;"></div>
                            </div>
    
                            <!-- Overlay for inpainting mask -->
                            <canvas id="lbMaskCanvas" style="display:none; position:absolute; top:0; left:0; width:100%; height:100%; z-index: 10; cursor: crosshair;"></canvas>
                        </div>
                    </div>
                    <div class="lightbox-sidebar">
                        <div class="lightbox-tools-header">
                            <div class="lightbox-tools-title">Image Editor (T)</div>
                            <div class="lightbox-chip pill" id="lbEditStatus" style="display:none;">Ready</div>
                             <div class="lightbox-actions" style="margin-left:auto;">
                                <button type="button" class="btn-mini primary" id="lbEditSaveNewBtn">Save New</button>
                                <button type="button" class="btn-mini danger" id="lbEditSaveReplaceBtn">Overwrite</button>
                                <button type="button" class="btn-mini" id="lbEditExitBtn">Exit</button>
                            </div>
                        </div>

                        <div class="lightbox-field">
                           <div class="section-title" style="margin-bottom:12px; font-size:12px; border-bottom:none;">Tools</div>
                           <div class="lightbox-actions" style="justify-content:flex-start; margin-top:0;">
                               <button type="button" class="btn-mini" id="lbCropToggleBtn">Crop</button>
                               <button type="button" class="btn-mini" id="lbRotateBtn">Rotate</button>
                               <button type="button" class="btn-mini" id="lbPaintToggleBtn" style="color:var(--primary-grad-end); border-color:rgba(251, 191, 36, 0.3);">Inpaint</button>
                           </div>
                        </div>

                         <div id="lbAdjustControls">
                            <div style="display:flex; justify-content:flex-end; margin-bottom:8px;">
                                <button type="button" class="btn-mini" id="lbAdjustResetBtn" style="font-size:11px; padding:2px 8px;">Reset Adjustments</button>
                            </div>
                            <div class="lightbox-field">
                                <label for="lbBrightness">Brightness</label>
                                <input type="range" id="lbBrightness" min="0" max="200" value="100" />
                            </div>
                             <div class="lightbox-field">
                                <label for="lbContrast">Contrast</label>
                                <input type="range" id="lbContrast" min="0" max="200" value="100" />
                            </div>
                             <div class="lightbox-field">
                                <label for="lbSaturation">Saturation</label>
                                <input type="range" id="lbSaturation" min="0" max="200" value="100" />
                            </div>
                            <div class="lightbox-field">
                                <label for="lbGrayscale">Grayscale</label>
                                <input type="range" id="lbGrayscale" min="0" max="100" value="0" />
                            </div>
                         </div>
                         
                         <div id="lbInpaintControls" style="display:none;">
                            <div class="lightbox-field" style="margin-top:16px;">
                                <label>Brush Size</label>
                                <div style="display:flex; gap:8px; align-items:center;">
                                    <input type="range" id="lbBrushSize" min="5" max="150" value="30" style="flex:1;" />
                                    <button type="button" class="btn-mini danger" id="lbClearMaskBtn" style="font-size:11px;">Clear</button>
                                </div>
                            </div>
                            <div class="lightbox-field" style="border-top:1px dashed var(--panel-border); padding-top:16px;">
                                <label for="lbInpaintPrompt">Inpaint Prompt <span style="color:var(--text-sub); font-weight:400; font-size:11px;">(Required)</span></label>
                                <textarea id="lbInpaintPrompt" style="min-height: 80px;" placeholder="Describe what to fill in the masked area..."></textarea>
                            </div>
                            
                            <div class="small-text" style="color:var(--text-sub); display:flex; flex-direction:column; gap:6px; margin-bottom:12px;">
                                 <div style="display:flex;justify-content:space-between;">
                                     <span>Output Resolution:</span>
                                     <span id="lbInpaintRes" style="font-family:var(--font-mono);">--</span>
                                </div>
                                <div style="display:flex;justify-content:space-between;">
                                     <span>Rate:</span>
                                     <span style="font-family:var(--font-mono);">$0.05 / MP</span>
                                </div>
                                 <div style="display:flex;justify-content:space-between;border-top:1px dashed rgba(255,255,255,0.1); padding-top:6px; margin-top:2px;">
                                     <span>Estimated Cost:</span>
                                     <span id="lbInpaintCost" style="color:var(--primary-grad-end); font-weight:600; font-family:var(--font-mono);">--</span>
                                </div>
                            </div>
                            
                            <button type="button" class="btn-mini primary" id="lbInpaintSubmitBtn" style="width:100%; margin-top:8px;">Generate Fill</button>
                            <div class="small-text" style="color:var(--text-sub); margin-top:8px;">
                                Use the brush to mask the area you want to change.
                            </div>
                         </div>
    </div>
  </div>

  <script>
    function confirmAction(e, message = "Are you sure you want to delete this?") {
        if (e && (e.metaKey || e.ctrlKey)) return true;
        return confirm(message);
    }
    /* --- Storage & Persistence System (IndexedDB + LocalStorage) --- */
    const DB_NAME = "NanoBananaDB";
    const DB_VERSION = 4;
    const STORE_RESULTS = "results";
    const STORE_REFS = "refs";
    const STORE_PAYLOADS = "resultPayloads";
    const LIST_STORAGE_KEY = "nano_banana_lists";
    const CARD_ORDER_FILE = "_card-order.json";
    const MAIN_LIST_ID = "main";
    const REF_LIST_ID = "ref";
    const DIR_PICKER_ID = "nano-banana-workspace";
    const RESULT_TIMESTAMP_INDEX = "byTimestamp";
    const PAGE_SIZE = 9;
    const TASK_TYPES = {
        RESULT: "result",
        SKELETON: "skeleton",
        FAILURE: "failure"
    };

    // Initialize IndexedDB
    let dbInstance = null;
    const activeTasks = new Map();
    let lastViewedTaskId = null;
    let locatorTimer = null;
    let refImages = [];
    const REF_IMAGE_LIMIT = 14;
    const DEFAULT_IMAGE_MIME = "image/png";
    const DISK_IMAGE_EXTENSIONS = ["png","jpg","jpeg","webp","gif","bmp"];
    const resultsData = new Map();
    const taskIndex = new Map();
    const taskRuntimeInfo = new Map();
    const pageState = {
        pageSize: PAGE_SIZE,
        pageByListId: new Map()
    };
    const MAX_RUNTIME_RESULT_RECORDS = 600;
    const UNSEEN_RESULTS_STORAGE_KEY = "nano_banana_unseen_results_v1";
    let unseenResultIds = loadStoredUnseenResultIds();
    const PENDING_TASKS_STORAGE_KEY = "nano_banana_pending_tasks_v1";
    let pendingTaskRecords = loadStoredPendingTasks();
    function rememberResultRecord(taskId, payload = {}) {
        if (!taskId) return null;
        let record = resultsData.get(taskId);
        if (record) {
            Object.assign(record, payload);
        } else {
            record = { taskId, ...payload };
            resultsData.set(taskId, record);
        }
        if ("thumbnail" in record) delete record.thumbnail;
        enforceResultsCacheLimit();
        return record;
    }
    function upsertTaskIndexEntry(taskId, payload = {}) {
        if (!taskId) return null;
        const current = taskIndex.get(taskId) || {};
        const next = {
            listId: payload.listId || current.listId || MAIN_LIST_ID,
            timestamp: payload.timestamp || current.timestamp || Date.now(),
            type: payload.type || current.type || TASK_TYPES.RESULT
        };
        taskIndex.set(taskId, next);
        return next;
    }
    function removeTaskIndexEntry(taskId) {
        if (!taskId) return;
        taskIndex.delete(taskId);
        taskRuntimeInfo.delete(taskId);
    }
    function setTaskRuntimeInfo(taskId, payload = {}) {
        if (!taskId) return null;
        const current = taskRuntimeInfo.get(taskId) || {};
        const next = { ...current, ...payload };
        taskRuntimeInfo.set(taskId, next);
        return next;
    }
    function getTaskRuntimeInfo(taskId) {
        if (!taskId) return null;
        return taskRuntimeInfo.get(taskId) || null;
    }
    function enforceResultsCacheLimit() {
        if (resultsData.size <= MAX_RUNTIME_RESULT_RECORDS) return;
        const keys = Array.from(resultsData.keys());
        const deleteCount = resultsData.size - MAX_RUNTIME_RESULT_RECORDS;
        for (let i = 0; i < deleteCount; i++) {
            const taskId = keys[i];
            const card = document.querySelector(`.result-card[data-task-id="${taskId}"]`);
            // We use { keepObserver: true } because cards remain in the DOM when visible.
            cleanupResultRecord(taskId, card, { keepObserver: true });
        }
    }
    function loadStoredUnseenResultIds() {
        if (typeof localStorage === "undefined") return new Set();
        try {
            const raw = localStorage.getItem(UNSEEN_RESULTS_STORAGE_KEY);
            if (!raw) return new Set();
            const parsed = JSON.parse(raw);
            if (!Array.isArray(parsed)) return new Set();
            const normalized = parsed
                .map(id => (typeof id === "string" ? id.trim() : ""))
                .filter(Boolean);
            return new Set(normalized);
        } catch (err) {
            console.warn("Failed to load unseen result state", err);
            return new Set();
        }
    }
    function persistUnseenResultIds() {
        if (typeof localStorage === "undefined") return;
        try {
            localStorage.setItem(UNSEEN_RESULTS_STORAGE_KEY, JSON.stringify(Array.from(unseenResultIds)));
        } catch (err) {
            console.warn("Failed to persist unseen result state", err);
        }
    }
    function setCardUnseenState(card, isUnseen) {
        if (!card) return;
        if (isUnseen) card.classList.add("unseen");
        else card.classList.remove("unseen");
    }
    function syncCardUnseenClass(taskId) {
        if (!taskId) return;
        const card = document.querySelector(`.result-card[data-task-id="${taskId}"]`);
        if (card) setCardUnseenState(card, unseenResultIds.has(taskId));
    }
    function markResultUnseen(taskId) {
        if (!taskId) return;
        if (!unseenResultIds.has(taskId)) {
            unseenResultIds.add(taskId);
            persistUnseenResultIds();
        }
        syncCardUnseenClass(taskId);
    }
    function markResultSeen(taskId) {
        if (!taskId) return;
        if (unseenResultIds.delete(taskId)) {
            persistUnseenResultIds();
        }
        const card = document.querySelector(`.result-card[data-task-id="${taskId}"]`);
        setCardUnseenState(card, false);
    }
    function loadStoredPendingTasks() {
        if (typeof localStorage === "undefined") return new Map();
        try {
            const raw = localStorage.getItem(PENDING_TASKS_STORAGE_KEY);
            if (!raw) return new Map();
            const parsed = JSON.parse(raw);
            if (!Array.isArray(parsed)) return new Map();
            const map = new Map();
            parsed.forEach(entry => {
                if (!entry || typeof entry.taskId !== "string") return;
                map.set(entry.taskId, normalizePendingTaskRecord(entry));
            });
            return map;
        } catch (err) {
            console.warn("Failed to load pending tasks", err);
            return new Map();
        }
    }
    function persistPendingTaskRecords() {
        if (typeof localStorage === "undefined") return;
        try {
            const payload = JSON.stringify(Array.from(pendingTaskRecords.values()));
            localStorage.setItem(PENDING_TASKS_STORAGE_KEY, payload);
        } catch (err) {
            console.warn("Failed to persist pending tasks", err);
        }
    }
    function cloneRefSnapshot(snapshot = []) {
        if (!Array.isArray(snapshot)) return [];
        return snapshot
            .map(entry => {
                if (!entry) return null;
                const sourceId = typeof entry.sourceId === "string" ? entry.sourceId : (typeof entry.id === "string" ? entry.id : "");
                if (!sourceId) return null;
                return {
                    sourceId,
                    mimeType: typeof entry.mimeType === "string" ? entry.mimeType : DEFAULT_IMAGE_MIME
                };
            })
            .filter(Boolean);
    }
    function normalizePendingTaskRecord(entry) {
        return {
            taskId: entry.taskId,
            prompt: typeof entry.prompt === "string" ? entry.prompt : "",
            refImagesSnapshot: cloneRefSnapshot(entry.refImagesSnapshot),
            refImageIds: Array.isArray(entry.refImageIds) ? entry.refImageIds.filter(id => typeof id === "string" && id).slice(0, REF_IMAGE_LIMIT) : [],
            resolution: typeof entry.resolution === "string" ? entry.resolution : "",
            aspectRatio: typeof entry.aspectRatio === "string" ? entry.aspectRatio : "",
            enableRetry: !!entry.enableRetry,
            maxRetries: typeof entry.maxRetries === "number" ? entry.maxRetries : 0,
            provider: normalizeProvider(entry.provider || "google"),
            listId: typeof entry.listId === "string" ? entry.listId : MAIN_LIST_ID,
            createdAt: typeof entry.createdAt === "number" ? entry.createdAt : Date.now(),
            status: entry.status === "FAILED" ? "FAILED" : "RUNNING",
            errorMessage: typeof entry.errorMessage === "string" ? entry.errorMessage : "",
            failureAt: typeof entry.failureAt === "number" ? entry.failureAt : null
        };
    }
    function registerPendingTask(taskId, config = {}, options = {}) {
        if (!taskId) return null;
        const record = {
            taskId,
            prompt: typeof config.prompt === "string" ? config.prompt : "",
            refImagesSnapshot: cloneRefSnapshot(config.refImagesSnapshot),
            refImageIds: Array.isArray(config.refImageIds) ? config.refImageIds.filter(id => typeof id === "string" && id).slice(0, REF_IMAGE_LIMIT) : [],
            resolution: typeof config.resolution === "string" ? config.resolution : "",
            aspectRatio: typeof config.aspectRatio === "string" ? config.aspectRatio : "",
            enableRetry: !!config.enableRetry,
            maxRetries: typeof config.maxRetries === "number" ? config.maxRetries : 0,
            provider: normalizeProvider(config.provider || "google"),
            listId: typeof options.listId === "string" ? options.listId : MAIN_LIST_ID,
            createdAt: typeof options.createdAt === "number" ? options.createdAt : Date.now(),
            status: options.status === "FAILED" ? "FAILED" : "RUNNING",
            errorMessage: typeof options.errorMessage === "string" ? options.errorMessage : "",
            failureAt: typeof options.failureAt === "number" ? options.failureAt : null
        };
        pendingTaskRecords.set(taskId, record);
        persistPendingTaskRecords();
        return record;
    }
    function markPendingTaskFailed(taskId, message = "") {
        if (!taskId) return null;
        const existing = pendingTaskRecords.get(taskId);
        const payload = existing || registerPendingTask(taskId, {}, { status: "FAILED" });
        if (!payload) return null;
        payload.status = "FAILED";
        payload.errorMessage = message || payload.errorMessage || "Task failed.";
        payload.failureAt = Date.now();
        pendingTaskRecords.set(taskId, payload);
        persistPendingTaskRecords();
        return payload;
    }
    function removePendingTask(taskId) {
        if (!taskId) return;
        if (pendingTaskRecords.delete(taskId)) {
            persistPendingTaskRecords();
        }
    }
    function getPendingTaskRecord(taskId) {
        if (!taskId) return null;
        return pendingTaskRecords.get(taskId) || null;
    }
    function buildReusableTaskSnapshot(record) {
        if (!record) return null;
        return {
            prompt: typeof record.prompt === "string" ? record.prompt : "",
            refImagesSnapshot: cloneRefSnapshot(record.refImagesSnapshot),
            refImageIds: Array.isArray(record.refImageIds) ? record.refImageIds.filter(Boolean) : [],
            resolution: typeof record.resolution === "string" ? record.resolution : "",
            aspectRatio: typeof record.aspectRatio === "string" ? record.aspectRatio : "",
            enableRetry: !!record.enableRetry,
            maxRetries: typeof record.maxRetries === "number" ? record.maxRetries : 0,
            provider: normalizeProvider(record.provider || activeProvider),
            listId: typeof record.listId === "string" ? record.listId : MAIN_LIST_ID,
            createdAt: typeof record.createdAt === "number" ? record.createdAt : Date.now()
        };
    }
    function resolveReusableTaskConfig(taskId) {
        if (!taskId) return null;
        const pending = getPendingTaskRecord(taskId);
        if (pending) return pending;
        const runtime = getTaskRuntimeInfo(taskId);
        if (runtime?.reuseSnapshot) return runtime.reuseSnapshot;
        return null;
    }
    function applyPendingTaskToForm(taskId, options = {}) {
        const record = resolveReusableTaskConfig(taskId);
        if (!record) return;
        const promptOnly = !!options.promptOnly;
        if (!promptOnly && record.provider) setActiveProvider(record.provider);
        promptInput.value = record.prompt || "";
        promptInput.dispatchEvent(new Event("input", { bubbles: true }));
        if (promptOnly) return;
        const refIds = Array.isArray(record.refImageIds) ? record.refImageIds.filter(Boolean) : [];
        if (refIds.length) {
            applyReferenceIdsQuietly(refIds).catch(console.error);
        }
    }
    function retryPendingTask(taskId, fallbackFunc) {
        const record = getPendingTaskRecord(taskId);
        if (!record) {
            if (typeof fallbackFunc === "function") {
                fallbackFunc();
                return true;
            }
            setTemporaryErrorStatus("Task data unavailable.");
            return false;
        }
        if (!requireFolderAccess()) return false;
        const provider = normalizeProvider(record.provider || activeProvider);
        const apiKey = getApiKeyManager(provider).getNextKey();
        if (!apiKey) { setTemporaryErrorStatus("Please enter at least one API Key."); return false; }
        const newTaskId = `${Date.now()}_${Math.random().toString(36).slice(2)}`;
        const newConfig = {
            prompt: record.prompt || "",
            refImagesSnapshot: cloneRefSnapshot(record.refImagesSnapshot),
            refImageIds: Array.isArray(record.refImageIds) ? record.refImageIds.slice(0) : [],
            resolution: record.resolution || "",
            aspectRatio: record.aspectRatio || "",
            enableRetry: !!record.enableRetry,
            maxRetries: typeof record.maxRetries === "number" ? record.maxRetries : 0,
            apiKey,
            provider
        };
        createSkeletonCard(newTaskId, { listId: record.listId || MAIN_LIST_ID });
        registerPendingTask(newTaskId, newConfig, { listId: record.listId || MAIN_LIST_ID, status: "RUNNING" });
        executeTask(newTaskId, newConfig).catch(console.error);
        removePendingTask(taskId);
        return true;
    }
    function restorePendingTaskCards() {
        if (!pendingTaskRecords.size) return;
        let mutated = false;
        let hasEntries = false;
        pendingTaskRecords.forEach((record, taskId) => {
            if (!record) return;
            if (record.status !== "FAILED") {
                record.status = "FAILED";
                record.errorMessage = record.errorMessage || "Task interrupted. Please retry.";
                record.failureAt = Date.now();
                mutated = true;
            }
            upsertTaskIndexEntry(taskId, {
                listId: record.listId || MAIN_LIST_ID,
                timestamp: record.createdAt || Date.now(),
                type: TASK_TYPES.FAILURE
            });
            setTaskRuntimeInfo(taskId, {
                errorMessage: record.errorMessage || "Task failed.",
                allowReuse: true,
                listId: record.listId || MAIN_LIST_ID,
                timestamp: record.createdAt || Date.now()
            });
            ensureTaskInOrder(taskId, "start");
            hasEntries = true;
        });
        if (mutated) persistPendingTaskRecords();
        if (hasEntries) {
            renderActivePage({ reason: "restore-pending" });
        }
    }
    let cardOrder = [];
    let cardOrderDirty = false;
    let cardOrderSavePromise = null;
    let cardOrderLoadedFromDisk = false;
    let cardOrderLoadPromise = null;
    let draggingCardId = null;
    let draggingCardEl = null;
    let dragPaginationActive = false;
    let dragPageHoverTimer = null;
    let dragPageHoverDirection = 0;
    let dragPageHoverEl = null;
    let dragHoverState = null;
    let dragOriginInfo = null;
    const MIN_CARD_SORT_DRAG_DISTANCE = 12;
    let transparentDragImage = null;
    let fileDragDepth = 0;
    let importDialogResolver = null;
    let importBatchMode = false;
    let workingDirectoryHandle = null;
    let folderAccessGranted = false;
    let diskSyncQueued = false;
    let dbHydrated = false;
    let diskSyncPromise = null;
    let listConfig = {
        active: MAIN_LIST_ID,
        lists: new Map([
            [MAIN_LIST_ID, { id: MAIN_LIST_ID, name: "Main", locked: true }],
            [REF_LIST_ID, { id: REF_LIST_ID, name: "REF", locked: true, hidden: true }]
        ])
    };
    let refListVisible = false;
    let listConfigDirty = false;
    let restoreCursorKey = null;
    let restoreCursorUsingIndex = null;
    let restoreLoading = false;
    let restoreExhausted = false;
    let restoredResultCount = 0;
    let cardVisibilityObserver = null;

    function openDB() {
        if (dbInstance) return Promise.resolve(dbInstance);
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onupgradeneeded = (e) => {
                const db = e.target.result;
                const upgradeTx = e.target.transaction;
                let resultsStore;
                if (!db.objectStoreNames.contains(STORE_RESULTS)) {
                    resultsStore = db.createObjectStore(STORE_RESULTS, { keyPath: "taskId" });
                } else {
                    resultsStore = upgradeTx.objectStore(STORE_RESULTS);
                }
                if (resultsStore && !resultsStore.indexNames.contains(RESULT_TIMESTAMP_INDEX)) {
                    resultsStore.createIndex(RESULT_TIMESTAMP_INDEX, ["timestamp", "taskId"]);
                }
                let payloadStore;
                if (!db.objectStoreNames.contains(STORE_PAYLOADS)) {
                    payloadStore = db.createObjectStore(STORE_PAYLOADS, { keyPath: "taskId" });
                } else {
                    payloadStore = upgradeTx.objectStore(STORE_PAYLOADS);
                }
                if (!db.objectStoreNames.contains(STORE_REFS)) {
                    db.createObjectStore(STORE_REFS, { keyPath: "id" });
                }

                if (resultsStore && payloadStore && e.oldVersion < 4) {
                    const migrateReq = resultsStore.openCursor();
                    migrateReq.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (!cursor) return;
                        const value = cursor.value;
                        if (value?.base64 && value.taskId) {
                            payloadStore.put({ taskId: value.taskId, base64: value.base64 });
                            delete value.base64;
                            cursor.update(value);
                        }
                        cursor.continue();
                    };
                }
            };
            request.onsuccess = (e) => {
                dbInstance = e.target.result;
                // Handle version changes (e.g. deletion) gracefully
                dbInstance.onversionchange = () => {
                    dbInstance.close();
                    dbInstance = null;
                };
                resolve(dbInstance);
            };
            request.onerror = (e) => reject(e.target.error);
        });
    }

    // LocalStorage Persistence for simple settings
    function saveSettings() {
        getApiKeyManager(activeProvider).setKeys(getApiKeyValues());
        const settings = {
            provider: activeProvider,
            falModel,
            apiKeysByProvider: {
                google: apiKeyManagers.google.keys,
                fal: apiKeyManagers.fal.keys
            },
            prompt: promptInput.value,
            resolution: resolutionSelect.value,
            aspectRatio: aspectRatioSelect.value,
            count: countInput.value,
            enableRetry: enableRetryInput.checked,
            maxRetries: maxRetriesInput.value
        };
        localStorage.setItem("nano_banana_settings", JSON.stringify(settings));
    }

    function loadSettings() {
        const saved = localStorage.getItem("nano_banana_settings");
        if (saved) {
            let settingsApplied = false;
            try {
                const s = JSON.parse(saved);
                let googleKeys = [];
                let falKeys = [];
                if (Array.isArray(s.apiKeys)) {
                    googleKeys = s.apiKeys;
                }
                if (s.apiKeysByProvider && typeof s.apiKeysByProvider === "object") {
                    if (Array.isArray(s.apiKeysByProvider.google)) googleKeys = s.apiKeysByProvider.google;
                    if (Array.isArray(s.apiKeysByProvider.fal)) falKeys = s.apiKeysByProvider.fal;
                }
                apiKeyManagers.google.setKeys(googleKeys);
                apiKeyManagers.fal.setKeys(falKeys);

                const savedFalModel = typeof s.falModel === "string" ? s.falModel : "default";
                falModel = savedFalModel === "qwen-image" ? "qwen-image" : "default";
                if (falModelSelect) falModelSelect.value = falModel;

                const provider = normalizeProvider(s.provider || "google");
                setActiveProvider(provider, { skipSave: true, skipKeyPersist: true });
                settingsApplied = true;
                if (s.prompt) promptInput.value = s.prompt;
                if (s.resolution) resolutionSelect.value = s.resolution;
                if (s.aspectRatio) aspectRatioSelect.value = s.aspectRatio;
                if (s.count) countInput.value = s.count;
                if (s.enableRetry !== undefined) enableRetryInput.checked = s.enableRetry;
                if (s.maxRetries) maxRetriesInput.value = s.maxRetries;
            } catch(e) { console.error("Failed to load settings", e); }
            if (!settingsApplied) {
                apiKeyManagers.google.setKeys([]);
                apiKeyManagers.fal.setKeys([]);
                setActiveProvider("google", { skipSave: true, skipKeyPersist: true });
            }
        } else {
            apiKeyManagers.google.setKeys([]);
            apiKeyManagers.fal.setKeys([]);
            setActiveProvider("google", { skipSave: true, skipKeyPersist: true });
        }
    }

    async function persistResultRecord(record) {
        if (!record?.taskId) return;
        const { base64, ...metaRecord } = record;
        try {
            const db = await openDB();
            const storeNames = base64 ? [STORE_RESULTS, STORE_PAYLOADS] : [STORE_RESULTS];
            const tx = db.transaction(storeNames, "readwrite");
            tx.objectStore(STORE_RESULTS).put(metaRecord);
            if (base64) {
                tx.objectStore(STORE_PAYLOADS).put({ taskId: record.taskId, base64 });
            }
        } catch (err) {
            console.error("Save result failed", err);
        }
    }

    function normalizeOrderList(value) {
        if (!Array.isArray(value)) return [];
        return value.map(id => (typeof id === "string" ? id : "")).filter(Boolean);
    }

    function resetCardOrderTracking() {
        cardOrder = [];
        cardOrderDirty = false;
        cardOrderLoadedFromDisk = false;
        cardOrderLoadPromise = null;
        cardOrderSavePromise = null;
    }

    function markCardOrderDirty() {
        cardOrderDirty = true;
        persistCardOrderToDisk();
    }

    async function loadCardOrderFromDisk(force = false) {
        if (!force && cardOrderLoadedFromDisk) return true;
        if (!folderAccessGranted || !workingDirectoryHandle?.getFileHandle) return false;
        if (cardOrderLoadPromise) return cardOrderLoadPromise;
        const targetHandle = workingDirectoryHandle;
        
        cardOrderLoadPromise = (async () => {
            try {
                const fileHandle = await targetHandle.getFileHandle(CARD_ORDER_FILE);
                const file = await fileHandle.getFile();
                const text = await file.text();
                let parsed;
                try {
                    parsed = JSON.parse(text);
                } catch (err) {
                    console.warn("Failed to parse order file", err);
                    parsed = null;
                }

                const rawOrder = Array.isArray(parsed) ? parsed : (Array.isArray(parsed?.order) ? parsed.order : []);
                cardOrder = normalizeOrderList(rawOrder);

                if (parsed && Array.isArray(parsed.lists) && parsed.lists.length > 0) {
                    const newLists = new Map();
                    let hasMain = false;
                    
                    parsed.lists.forEach(l => {
                        if (l.id === MAIN_LIST_ID) hasMain = true;
                        newLists.set(l.id, {
                            id: l.id,
                            name: l.name || "Unnamed List",
                            locked: !!l.locked,
                            hidden: !!l.hidden
                        });
                    });

                    if (!hasMain) {
                        const mainList = { id: MAIN_LIST_ID, name: "Main", locked: true };
                        const tempMap = new Map();
                        tempMap.set(MAIN_LIST_ID, mainList);
                        newLists.forEach((v, k) => tempMap.set(k, v));
                        listConfig.lists = tempMap;
                    } else {
                        listConfig.lists = newLists;
                    }
                    ensureRefListRegistered();

                    if (parsed.activeList && listConfig.lists.has(parsed.activeList)) {
                        listConfig.active = parsed.activeList;
                    }

                    renderListTabs();
                    updateMoveAllControl();
                }

                ensureRefListRegistered();
                refListVisible = listConfig.active === REF_LIST_ID;
                cardOrderDirty = false;
                cardOrderLoadedFromDisk = true;
                maybeNormalizeStoredOrderDirection();
                return true;
            } catch (err) {
                if (err?.name === "NotFoundError") {
                    cardOrderLoadedFromDisk = true;
                    return false; 
                }
                if (err?.name === "NotAllowedError") {
                    handleFolderAccessError("Re-authorize the output directory");
                    return false;
                }
                console.warn("Failed to read order file", err);
                cardOrderLoadedFromDisk = true;
                return false;
            } finally {
                cardOrderLoadPromise = null;
            }
        })();
        return cardOrderLoadPromise;
    }

    async function persistCardOrderToDisk() {
        if (!cardOrderDirty && !listConfigDirty) return; 
        if (!folderAccessGranted || !workingDirectoryHandle?.getFileHandle) return;
        if (cardOrderSavePromise) return cardOrderSavePromise;

        const listsArray = Array.from(listConfig.lists.values());
        const payload = JSON.stringify({ 
            version: 2,
            order: cardOrder, 
            lists: listsArray, 
            activeList: listConfig.active, 
            updatedAt: Date.now() 
        }, null, 2);

        const targetHandle = workingDirectoryHandle;
        cardOrderSavePromise = (async () => {
            try {
                const fileHandle = await targetHandle.getFileHandle(CARD_ORDER_FILE, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(payload);
                await writable.close();
                
                cardOrderDirty = false;
                listConfigDirty = false; 
            } catch (err) {
                cardOrderDirty = true; 
                if (err?.name === "NotAllowedError") {
                    handleFolderAccessError("Re-authorize the output directory");
                } else {
                    console.warn("Failed to write order file", err);
                }
            } finally {
                cardOrderSavePromise = null;
                if ((cardOrderDirty || listConfigDirty) && folderAccessGranted && workingDirectoryHandle) {
                    setTimeout(() => persistCardOrderToDisk(), 300);
                }
            }
        })();
        return cardOrderSavePromise;
    }

    function ensureTaskInOrder(taskId, position = "end") {
        if (!taskId) return;
        const existingIndex = cardOrder.indexOf(taskId);
        if (existingIndex !== -1) {
            if (position === "start" && existingIndex !== 0) {
                cardOrder.splice(existingIndex, 1);
                cardOrder.unshift(taskId);
                markCardOrderDirty();
            }
            return;
        }
        if (position === "start") {
            cardOrder.unshift(taskId);
        } else {
            cardOrder.push(taskId);
        }
        markCardOrderDirty();
    }


    function removeTaskFromOrder(taskId) {
        if (!taskId) return;
        const index = cardOrder.indexOf(taskId);
        if (index === -1) return;
        cardOrder.splice(index, 1);
        markCardOrderDirty();
    }

    function ensureCardOrderReady() {
        if (cardOrder.length) return;
        cardOrder = Array.from(taskIndex.entries())
            .filter(([, meta]) => meta)
            .sort((a, b) => (b[1].timestamp || 0) - (a[1].timestamp || 0))
            .map(([taskId]) => taskId);
    }

    function getTaskTimestamp(taskId) {
        if (!taskId) return 0;
        const meta = taskIndex.get(taskId);
        if (meta?.timestamp) return meta.timestamp;
        const record = resultsData.get(taskId);
        if (record?.timestamp) return record.timestamp;
        return 0;
    }

    function shouldReverseListOrder(ids) {
        if (!Array.isArray(ids) || ids.length < 2) return false;
        let ascPairs = 0;
        let descPairs = 0;
        for (let i = 0; i < ids.length - 1; i += 1) {
            const a = getTaskTimestamp(ids[i]);
            const b = getTaskTimestamp(ids[i + 1]);
            if (!a || !b) continue;
            if (a <= b) ascPairs += 1;
            else descPairs += 1;
        }
        if (!ascPairs && !descPairs) return false;
        if (ascPairs && !descPairs) return true;
        return ascPairs >= descPairs * 2;
    }

    function maybeNormalizeStoredOrderDirection() {
        ensureCardOrderReady();
        if (!cardOrder.length) return;
        const listGroups = new Map();
        cardOrder.forEach(taskId => {
            const listId = taskIndex.get(taskId)?.listId || MAIN_LIST_ID;
            if (!listGroups.has(listId)) listGroups.set(listId, []);
            listGroups.get(listId).push(taskId);
        });
        const replacements = new Map();
        listGroups.forEach((ids, listId) => {
            if (shouldReverseListOrder(ids)) {
                replacements.set(listId, ids.slice().reverse());
            }
        });
        if (!replacements.size) return;
        const counters = new Map();
        let mutated = false;
        cardOrder = cardOrder.map(taskId => {
            const listId = taskIndex.get(taskId)?.listId || MAIN_LIST_ID;
            if (!replacements.has(listId)) return taskId;
            const pointer = counters.get(listId) || 0;
            const seq = replacements.get(listId);
            const nextId = seq[pointer] || taskId;
            counters.set(listId, pointer + 1);
            if (nextId !== taskId) mutated = true;
            return nextId;
        });
        if (mutated) {
            markCardOrderDirty();
        }
    }

    function applyVisibleOrderToGlobal(listId, visibleIds) {
        if (!listId || !Array.isArray(visibleIds) || !visibleIds.length) return;
        ensureCardOrderReady();
        const orderedVisible = visibleIds.filter(id => taskIndex.get(id)?.listId === listId);
        if (!orderedVisible.length) return;
        const targetSet = new Set(orderedVisible);
        let cursor = 0;
        const updated = cardOrder.map(id => {
            const meta = taskIndex.get(id);
            if (!meta || meta.listId !== listId || !targetSet.has(id)) return id;
            const nextId = orderedVisible[cursor++];
            return nextId || id;
        });
        orderedVisible.forEach(id => {
            if (!updated.includes(id)) updated.unshift(id);
        });
        const changed = updated.length !== cardOrder.length || updated.some((id, idx) => id !== cardOrder[idx]);
        if (changed) {
            cardOrder = updated;
            markCardOrderDirty();
        }
    }

    function moveCardInOrder(taskId, targetTaskId, insertBefore) {
        if (!taskId || !targetTaskId || taskId === targetTaskId) return false;
        ensureCardOrderReady();
        if (!cardOrder.length) return false;
        const fromIndex = cardOrder.indexOf(taskId);
        if (fromIndex === -1) return false;
        cardOrder.splice(fromIndex, 1);
        const targetIndex = cardOrder.indexOf(targetTaskId);
        if (targetIndex === -1) {
            cardOrder.splice(fromIndex, 0, taskId);
            return false;
        }
        const insertIndex = insertBefore ? targetIndex : targetIndex + 1;
        cardOrder.splice(insertIndex, 0, taskId);
        markCardOrderDirty();
        return true;
    }

    function moveCardToListEnd(taskId, listId) {
        if (!taskId || !listId) return false;
        ensureCardOrderReady();
        if (!cardOrder.length) return false;
        const fromIndex = cardOrder.indexOf(taskId);
        if (fromIndex === -1) return false;
        cardOrder.splice(fromIndex, 1);
        let insertIndex = cardOrder.length;
        for (let i = cardOrder.length - 1; i >= 0; i -= 1) {
            const meta = taskIndex.get(cardOrder[i]);
            if (meta?.listId === listId) {
                insertIndex = i + 1;
                break;
            }
        }
        cardOrder.splice(insertIndex, 0, taskId);
        markCardOrderDirty();
        return true;
    }

    function captureOrderFromDom() {
        if (!resultsEl) return;
        const activeListId = listConfig.active || MAIN_LIST_ID;
        const ids = Array.from(resultsEl.querySelectorAll(".result-card"))
            .map(card => card.dataset.taskId)
            .filter(Boolean);
        if (!ids.length) return;
        applyVisibleOrderToGlobal(activeListId, ids);
    }

    function getCardTimestampValue(card) {
        if (!card) return 0;
        const taskId = card.dataset.taskId;
        if (taskId) {
            const record = resultsData.get(taskId);
            if (record?.timestamp) return record.timestamp;
        }
        const attr = card.dataset.createdAt;
        return attr ? Number(attr) : 0;
    }

    function applyStoredCardOrder() {
        renderActivePage({ reason: "order" });
    }

    function getOrderedTaskIdsForList(listId) {
        const targetListId = listId || MAIN_LIST_ID;
        const baseOrder = cardOrder.length
            ? cardOrder
            : Array.from(taskIndex.entries())
                .filter(([, meta]) => meta)
                .sort((a, b) => (b[1].timestamp || 0) - (a[1].timestamp || 0))
                .map(([taskId]) => taskId);
        const activeIds = [];
        const regularIds = [];
        baseOrder.forEach(taskId => {
            const meta = taskIndex.get(taskId);
            if (!meta || meta.listId !== targetListId) return;
            if (meta.type === TASK_TYPES.SKELETON) activeIds.push(taskId);
            else regularIds.push(taskId);
        });
        return activeIds.concat(regularIds);
    }

    function ensurePageIndex(listId) {
        if (!listId) return 0;
        if (!pageState.pageByListId.has(listId)) {
            pageState.pageByListId.set(listId, 0);
        }
        return pageState.pageByListId.get(listId) || 0;
    }

    function setPageIndex(listId, pageIndex) {
        if (!listId) return;
        const safeIndex = Math.max(0, pageIndex || 0);
        pageState.pageByListId.set(listId, safeIndex);
    }

    function getTotalPagesForList(listId) {
        const count = getOrderedTaskIdsForList(listId).length;
        return Math.max(1, Math.ceil(count / pageState.pageSize));
    }

    function clampPageIndex(listId, pageIndex) {
        const totalPages = getTotalPagesForList(listId);
        const clamped = Math.min(Math.max(pageIndex, 0), totalPages - 1);
        setPageIndex(listId, clamped);
        return { pageIndex: clamped, totalPages };
    }

    function updatePaginationControls(listId, pageIndex, totalPages) {
        if (pageIndicator) {
            pageIndicator.textContent = `Page ${pageIndex + 1} / ${totalPages}`;
        }
        if (pagePrevBtn) {
            pagePrevBtn.disabled = pageIndex <= 0;
        }
        if (pageNextBtn) {
            pageNextBtn.disabled = pageIndex >= totalPages - 1;
        }
    }

    function clearRenderedCards() {
        if (!resultsEl) return;
        const cards = Array.from(resultsEl.querySelectorAll(".result-card"));
        cards.forEach(card => {
            const taskId = card.dataset.taskId;
            if (draggingCardId && taskId === draggingCardId) return;
            if (taskId) {
                cleanupResultRecord(taskId, card, {
                    keepObserver: true,
                    keepRecord: false,
                    preserveUnseen: true,
                    skipSaveCancel: true,
                    skipRecordUrlCleanup: true
                });
            }
            card.remove();
        });
    }

    async function fetchRenderPayload(taskId) {
        if (!taskId) return null;
        let record = resultsData.get(taskId);
        let stored = null;
        if (!record || !record.meta) {
            stored = await fetchStoredResultRecord(taskId);
            if (stored) {
                record = rememberResultRecord(taskId, {
                    meta: stored.meta || {},
                    prompt: stored.prompt || "",
                    listId: stored.listId || MAIN_LIST_ID,
                    timestamp: stored.timestamp || Date.now(),
                    refImageIds: Array.isArray(stored.refImageIds) ? stored.refImageIds : []
                });
            }
        }
        const meta = record?.meta || stored?.meta || {};
        const prompt = record?.prompt || stored?.prompt || "";
        const timestamp = record?.timestamp || stored?.timestamp || Date.now();
        const listId = record?.listId || stored?.listId || MAIN_LIST_ID;
        const indexMeta = taskIndex.get(taskId);
        if (indexMeta && indexMeta.listId !== listId) {
            indexMeta.listId = listId;
            taskIndex.set(taskId, indexMeta);
        }
        let thumbnail = record?.thumbnail || null;
        if (!thumbnail && stored?.thumbnail) {
            thumbnail = stored.thumbnail;
        }
        if (!thumbnail) {
            thumbnail = await fetchStoredThumbnail(taskId);
        }
        if (!thumbnail) {
            const metaCandidate = stored?.meta || record?.meta;
            if (metaCandidate) {
                thumbnail = await hydrateMissingThumbnail({
                    taskId,
                    meta: metaCandidate,
                    thumbnail: null
                });
            }
        }
        return { taskId, meta, prompt, timestamp, listId, thumbnail };
    }

    function resolveFailureCardOptions(taskId) {
        const pending = getPendingTaskRecord(taskId);
        if (pending) {
            return {
                taskId,
                errorMessage: pending.errorMessage || "Task failed.",
                retryHandler: () => retryPendingTask(taskId),
                allowReuse: true,
                listId: pending.listId || MAIN_LIST_ID,
                timestamp: pending.createdAt || Date.now()
            };
        }
        const runtime = getTaskRuntimeInfo(taskId) || {};
        return {
            taskId,
            errorMessage: runtime.errorMessage || "Task failed.",
            allowReuse: !!runtime.allowReuse,
            listId: runtime.listId || taskIndex.get(taskId)?.listId || MAIN_LIST_ID,
            timestamp: runtime.timestamp || taskIndex.get(taskId)?.timestamp || Date.now()
        };
    }

    async function renderActivePage(options = {}) {
        if (!resultsEl) return;
        const preserveScroll = options.preserveScroll === true;
        const scrollRoot = preserveScroll
            ? (() => {
                const candidate = resultsEl.closest(".results-scroll");
                if (candidate && candidate.scrollHeight > candidate.clientHeight) return candidate;
                return document.scrollingElement || document.documentElement;
            })()
            : null;
        const scrollState = (preserveScroll && scrollRoot)
            ? { top: scrollRoot.scrollTop, left: scrollRoot.scrollLeft, height: resultsEl.offsetHeight }
            : null;
        if (scrollState) resultsEl.style.minHeight = `${scrollState.height}px`;
        try {
            const activeListId = listConfig.active || MAIN_LIST_ID;
            const orderedIds = getOrderedTaskIdsForList(activeListId);
            const initialPageIndex = ensurePageIndex(activeListId);
            const { pageIndex, totalPages } = clampPageIndex(activeListId, initialPageIndex);
            const start = pageIndex * pageState.pageSize;
            const pageTaskIds = orderedIds.slice(start, start + pageState.pageSize);

            const cards = await Promise.all(pageTaskIds.map(async (taskId) => {
                const meta = taskIndex.get(taskId);
                if (!meta) return null;
                if (meta.type === TASK_TYPES.SKELETON) {
                    return buildSkeletonCardElement(taskId);
                }
                if (meta.type === TASK_TYPES.FAILURE) {
                    const runtime = getTaskRuntimeInfo(taskId);
                    if (runtime?.status === "cancelled") {
                        return buildCancelledCardElement({
                            taskId,
                            listId: meta.listId || MAIN_LIST_ID,
                            timestamp: meta.timestamp || Date.now()
                        });
                    }
                    return buildFailureCardElement(resolveFailureCardOptions(taskId));
                }
                const payload = await fetchRenderPayload(taskId);
                if (!payload) return null;
                return buildResultCardElement({
                    taskId,
                    listId: payload.listId || MAIN_LIST_ID,
                    timestamp: payload.timestamp || Date.now(),
                    meta: payload.meta || {},
                    prompt: payload.prompt || "",
                    thumbnail: payload.thumbnail || null
                });
            }));

            clearRenderedCards();

            const fragment = document.createDocumentFragment();
            cards.forEach(card => {
                if (card) fragment.appendChild(card);
            });
            resultsEl.appendChild(fragment);
            applyCompareSelectionIndicators();

            updatePaginationControls(activeListId, pageIndex, totalPages);
            updateMoveAllControl();
            renderListTabs();
        } catch (err) {
            console.warn("Render page failed", err);
        } finally {
            if (scrollState && scrollRoot) {
                requestAnimationFrame(() => {
                    resultsEl.style.minHeight = "";
                    scrollRoot.scrollTop = scrollState.top;
                    scrollRoot.scrollLeft = scrollState.left;
                });
            }
        }
    }

    function changePageBy(delta) {
        const activeListId = listConfig.active || MAIN_LIST_ID;
        const currentIndex = ensurePageIndex(activeListId);
        const totalPages = getTotalPagesForList(activeListId);
        const clampedCurrent = Math.min(Math.max(currentIndex, 0), totalPages - 1);
        if (clampedCurrent !== currentIndex) {
            clampPageIndex(activeListId, clampedCurrent);
            prepareDragForPagination();
            renderActivePage({ reason: "pagination", preserveScroll: true });
            return;
        }
        if ((delta < 0 && currentIndex <= 0) || (delta > 0 && currentIndex >= totalPages - 1)) return;
        const nextIndex = currentIndex + delta;
        const { pageIndex } = clampPageIndex(activeListId, nextIndex);
        if (pageIndex === currentIndex) return;
        prepareDragForPagination();
        renderActivePage({ reason: "pagination", preserveScroll: true });
    }

    function prioritizeActiveTaskCards() {
        if (!resultsEl || !activeTasks.size) return false;
        const activeIds = Array.from(activeTasks.keys());
        if (!activeIds.length) return false;
        const activeSet = new Set(activeIds);
        const cards = Array.from(resultsEl.querySelectorAll(".result-card"));
        if (!cards.length) return false;
        const movers = cards.filter(card => {
            const taskId = card.dataset.taskId;
            if (!taskId) return false;
            if (card.dataset.listId && card.dataset.listId !== MAIN_LIST_ID) return false;
            return activeSet.has(taskId);
        });
        if (!movers.length) return false;
        const fragment = document.createDocumentFragment();
        movers.forEach(card => fragment.appendChild(card));
        const anchor = cards.find(card => {
            const taskId = card.dataset.taskId;
            if (!taskId) return false;
            return !activeSet.has(taskId);
        }) || getListMoveCardAnchor();
        if (anchor) resultsEl.insertBefore(fragment, anchor);
        else resultsEl.appendChild(fragment);
        return true;
    }

    function ensureTransparentDragImage() {
        if (transparentDragImage) return transparentDragImage;
        const canvas = document.createElement("canvas");
        canvas.width = canvas.height = 1;
        canvas.style.position = "fixed";
        canvas.style.top = "-10px";
        canvas.style.left = "-10px";
        canvas.style.opacity = "0";
        canvas.style.pointerEvents = "none";
        document.body.appendChild(canvas);
        transparentDragImage = canvas;
        return transparentDragImage;
    }

    function dataTransferHasFiles(event) {
        if (!event?.dataTransfer?.types) return false;
        return Array.from(event.dataTransfer.types).includes("Files");
    }

    function showResultsFileDropHint() {
        if (resultsDropHint) {
            resultsDropHint.classList.add("visible");
        }
    }

    function hideResultsFileDropHint() {
        if (resultsDropHint) {
            resultsDropHint.classList.remove("visible");
        }
        fileDragDepth = 0;
    }

    function isCardSortDragEvent(event) {
        const types = Array.from(event?.dataTransfer?.types || []);
        return types.includes("application/x-nano-card-sort");
    }

    function clearCardSortHints() {
        if (!resultsEl) return;
        resultsEl.querySelectorAll(".result-card.drag-sort-before, .result-card.drag-sort-after")
            .forEach(card => {
                card.classList.remove("drag-sort-before", "drag-sort-after");
            });
        dragHoverState = null;
    }

    function setDragHoldState(active) {
        if (!draggingCardEl) return;
        if (active) draggingCardEl.classList.add("drag-hold");
        else draggingCardEl.classList.remove("drag-hold");
    }

    function clearDragPageHover() {
        if (dragPageHoverTimer) {
            clearTimeout(dragPageHoverTimer);
            dragPageHoverTimer = null;
        }
        dragPageHoverDirection = 0;
        if (dragPageHoverEl) {
            dragPageHoverEl.classList.remove("drag-page-hover");
            dragPageHoverEl = null;
        }
    }

    function scheduleDragPageChange(delta, el) {
        if (!draggingCardId) return;
        if (dragPageHoverDirection === delta && dragPageHoverTimer) return;
        clearDragPageHover();
        dragPageHoverDirection = delta;
        dragPageHoverEl = el || null;
        if (dragPageHoverEl) dragPageHoverEl.classList.add("drag-page-hover");
        dragPageHoverTimer = setTimeout(() => {
            dragPageHoverTimer = null;
            dragPageHoverDirection = 0;
            if (dragPageHoverEl) {
                dragPageHoverEl.classList.remove("drag-page-hover");
                dragPageHoverEl = null;
            }
            changePageBy(delta);
        }, 350);
    }

    function prepareDragForPagination() {
        if (!draggingCardId) return;
        dragPaginationActive = true;
        setDragHoldState(true);
        clearDragPageHover();
        clearCardSortHints();
    }

    function finalizeCardDrag() {
        const shouldRefresh = dragPaginationActive;
        dragPaginationActive = false;
        clearDragPageHover();
        setDragHoldState(false);
        draggingCardEl = null;
        draggingCardId = null;
        clearCardSortHints();
        clearCardDragOrigin();
        if (shouldRefresh) {
            renderActivePage({ reason: "drag-paginate", preserveScroll: true });
        }
    }

    function recordCardDragOrigin(e, card) {
        if (!card) {
            dragOriginInfo = null;
            return;
        }
        dragOriginInfo = {
            card,
            parent: card.parentNode,
            nextSibling: card.nextSibling,
            startX: typeof e?.clientX === "number" ? e.clientX : null,
            startY: typeof e?.clientY === "number" ? e.clientY : null
        };
    }

    function restoreCardToOrigin() {
        if (!dragOriginInfo?.card || !dragOriginInfo.parent) return false;
        const { card, parent, nextSibling } = dragOriginInfo;
        if (!parent.contains(card)) return false;
        if (nextSibling && nextSibling.parentNode === parent) {
            parent.insertBefore(card, nextSibling);
        } else {
            if (parent === resultsEl) insertBeforeListMoveCard(card);
            else parent.appendChild(card);
        }
        return true;
    }

    function getCardDragDistance(e) {
        if (!dragOriginInfo) return Infinity;
        if (dragOriginInfo.startX == null || dragOriginInfo.startY == null) return Infinity;
        if (typeof e?.clientX !== "number" || typeof e?.clientY !== "number") return Infinity;
        const dx = e.clientX - dragOriginInfo.startX;
        const dy = e.clientY - dragOriginInfo.startY;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function clearCardDragOrigin() {
        dragOriginInfo = null;
    }

    function shouldInsertBefore(e, targetCard) {
        const rect = targetCard.getBoundingClientRect();
        return (e.clientY - rect.top) < rect.height / 2;
    }

    function insertCardAtActiveListEnd(card) {
        if (!resultsEl) return;
        const activeCards = Array.from(resultsEl.querySelectorAll(`.result-card[data-list-id="${listConfig.active}"]`));
        const lastCard = activeCards.filter(c => c.style.display !== "none").pop() || activeCards.pop();
        if (!lastCard) {
            insertAtResultsTop(card);
            return;
        }
        insertAfterResultCard(lastCard, card);
    }

    function handleResultsDragEnter(e) {
        if (dataTransferHasFiles(e) && !isCardSortDragEvent(e)) {
            e.preventDefault();
            fileDragDepth++;
            showResultsFileDropHint();
        }
    }

    function handleResultsDragOver(e) {
        if (dataTransferHasFiles(e) && !isCardSortDragEvent(e)) {
            e.preventDefault();
            showResultsFileDropHint();
            if (e.dataTransfer) e.dataTransfer.dropEffect = "copy";
            return;
        }
        if (!isCardSortDragEvent(e)) return;
        e.preventDefault();
        const targetCard = e.target.closest(".result-card");
        if (!targetCard || !targetCard.dataset.taskId || targetCard.dataset.placeholder === "true" || targetCard.dataset.listId !== listConfig.active || targetCard.dataset.taskId === draggingCardId) {
            clearCardSortHints();
            return;
        }
        const insertBefore = shouldInsertBefore(e, targetCard);
        if (insertBefore) {
            targetCard.classList.add("drag-sort-before");
            targetCard.classList.remove("drag-sort-after");
        } else {
            targetCard.classList.add("drag-sort-after");
            targetCard.classList.remove("drag-sort-before");
        }
        dragHoverState = { card: targetCard, insertBefore };
    }

    function handleResultsDragLeave(e) {
        if (dataTransferHasFiles(e) && !isCardSortDragEvent(e)) {
            fileDragDepth = Math.max(0, fileDragDepth - 1);
            if (!fileDragDepth) hideResultsFileDropHint();
            return;
        }
        const targetCard = e.target.closest(".result-card");
        if (targetCard) {
            targetCard.classList.remove("drag-sort-before", "drag-sort-after");
        }
    }

    function handleResultsDrop(e) {
        if (dataTransferHasFiles(e) && !isCardSortDragEvent(e)) {
            e.preventDefault();
            hideResultsFileDropHint();
            const files = Array.from(e.dataTransfer?.files || []);
            if (files.length) {
                handleManualImageImport(files);
            }
            return;
        }
        if (!isCardSortDragEvent(e)) return;
        e.preventDefault();
        const dragged = draggingCardEl || (draggingCardId ? document.querySelector(`.result-card[data-task-id="${draggingCardId}"]`) : null);
        let targetCard = e.target.closest(".result-card");
        if (targetCard && (!targetCard.dataset.taskId || targetCard.dataset.placeholder === "true")) {
            targetCard = null;
        }
        if (!dragged) {
            clearCardSortHints();
            clearCardDragOrigin();
            return;
        }
        const dropDistance = getCardDragDistance(e);
        const isTinyMovement = dropDistance < MIN_CARD_SORT_DRAG_DISTANCE;
        if (!targetCard || targetCard.dataset.listId !== listConfig.active || targetCard === dragged) {
            if (dragHoverState?.card && dragHoverState.card !== dragged && dragHoverState.card.dataset.listId === listConfig.active && resultsEl.contains(dragHoverState.card)) {
                targetCard = dragHoverState.card;
            }
        }
        const droppedOnSelf = targetCard === dragged;
        const hasValidTarget = targetCard && targetCard.dataset.listId === listConfig.active && targetCard !== dragged;
        let insertBefore = null;
        if (!hasValidTarget) {
            const reverted = (droppedOnSelf || isTinyMovement) ? restoreCardToOrigin() : false;
            if (!reverted) {
                insertCardAtActiveListEnd(dragged);
            }
        } else {
            insertBefore = (dragHoverState && dragHoverState.card === targetCard && typeof dragHoverState.insertBefore === "boolean")
                ? dragHoverState.insertBefore
                : shouldInsertBefore(e, targetCard);
            if (insertBefore) resultsEl.insertBefore(dragged, targetCard);
            else resultsEl.insertBefore(dragged, targetCard.nextSibling);
        }
        setDragHoldState(false);
        clearCardSortHints();
        if (dragPaginationActive) {
            if (draggingCardId && hasValidTarget && typeof insertBefore === "boolean" && targetCard) {
                moveCardInOrder(draggingCardId, targetCard.dataset.taskId, insertBefore);
            } else if (draggingCardId && !hasValidTarget) {
                moveCardToListEnd(draggingCardId, listConfig.active || MAIN_LIST_ID);
            }
        } else {
            captureOrderFromDom();
        }
        clearCardDragOrigin();
    }

    function handlePagerDragOver(e, delta, btn) {
        if (!isCardSortDragEvent(e)) return;
        e.preventDefault();
        if (e.dataTransfer) e.dataTransfer.dropEffect = "move";
        scheduleDragPageChange(delta, btn);
    }

    function handlePagerDrop(e) {
        if (!isCardSortDragEvent(e)) return;
        e.preventDefault();
        clearDragPageHover();
        restoreCardToOrigin();
    }


    /* --- UI Elements & Logic --- */
    const generateBtn = document.getElementById("generateBtn");
    const cancelAllBtn = document.getElementById("cancelAllBtn");
    const clearResultsBtn = document.getElementById("clearResultsBtn");
    const resetAppBtn = document.getElementById("resetAppBtn"); // NEW
    const statusEl = document.getElementById("status");
    const resultsEl = document.getElementById("results");
    const resultsCountLabel = document.getElementById("resultsCountLabel");
    const resultsDropHint = document.getElementById("resultsDropHint");
    const listMoveOverlayEl = document.getElementById("listMoveOverlay");
    const listMoveAllSelectEl = document.getElementById("listMoveAllSelect");
    const listMoveAllBtn = document.getElementById("listMoveAllBtn");
    const listMoveAllHintEl = document.getElementById("listMoveAllHint");
    const listMoveCancelBtn = document.getElementById("listMoveCancelBtn");
    const pagePrevBtn = document.getElementById("pagePrevBtn");
    const pageNextBtn = document.getElementById("pageNextBtn");
    const pageIndicator = document.getElementById("pageIndicator");
    if (pagePrevBtn) pagePrevBtn.addEventListener("click", () => changePageBy(-1));
    if (pageNextBtn) pageNextBtn.addEventListener("click", () => changePageBy(1));
    if (pagePrevBtn) {
        pagePrevBtn.addEventListener("dragenter", (e) => handlePagerDragOver(e, -1, pagePrevBtn));
        pagePrevBtn.addEventListener("dragover", (e) => handlePagerDragOver(e, -1, pagePrevBtn));
        pagePrevBtn.addEventListener("dragleave", () => clearDragPageHover());
        pagePrevBtn.addEventListener("drop", handlePagerDrop);
    }
    if (pageNextBtn) {
        pageNextBtn.addEventListener("dragenter", (e) => handlePagerDragOver(e, 1, pageNextBtn));
        pageNextBtn.addEventListener("dragover", (e) => handlePagerDragOver(e, 1, pageNextBtn));
        pageNextBtn.addEventListener("dragleave", () => clearDragPageHover());
        pageNextBtn.addEventListener("drop", handlePagerDrop);
    }

    function getListMoveCardAnchor() {
        return null;
    }

    function insertBeforeListMoveCard(node) {
        if (!resultsEl || !node) return;
        const anchor = getListMoveCardAnchor();
        if (anchor) {
            resultsEl.insertBefore(node, anchor);
        } else {
            resultsEl.appendChild(node);
        }
    }

    function insertAtResultsTop(node) {
        if (!resultsEl || !node) return;
        
        const firstFinishedCard = resultsEl.querySelector(".result-card:not(.skeleton)");
        
        if (firstFinishedCard) {
            resultsEl.insertBefore(node, firstFinishedCard);
        } else {
            insertBeforeListMoveCard(node);
        }
        }

    function insertAfterResultCard(referenceCard, node) {
        if (!resultsEl || !referenceCard || !node) return;
        const anchor = referenceCard.nextSibling || getListMoveCardAnchor();
        if (anchor) {
            resultsEl.insertBefore(node, anchor);
        } else {
            resultsEl.appendChild(node);
        }
    }
    const importBtn = document.getElementById("importBtn");
    const importInput = document.getElementById("importInput");
    const importOverlayEl = document.getElementById("importOverlay");
    const importPromptInput = document.getElementById("importPromptInput");
    const importResolutionInput = document.getElementById("importResolutionInput");
    const importAspectInput = document.getElementById("importAspectInput");
    const importConfirmBtn = document.getElementById("importConfirmBtn");
    const importCancelBtn = document.getElementById("importCancelBtn");
    const importPreviewImg = document.getElementById("importPreview");
    const importFilenameEl = document.getElementById("importFilename");
    const providerSelect = document.getElementById("providerSelect");
    const falModelGroup = document.getElementById("falModelGroup");
    const falModelSelect = document.getElementById("falModelSelect");
    const providerHintEl = document.getElementById("providerHint");
    const apiKeyLabelEl = document.getElementById("apiKeyLabel");
    const apiKeyProviderHintEl = document.getElementById("apiKeyProviderHint");
    const apiKeyListEl = document.getElementById("apiKeyList");
    const addApiKeyBtn = document.getElementById("addApiKeyBtn");
    const getKeyBtn = document.getElementById("getKeyBtn");
    const fsOverlay = document.getElementById("fsOverlay");
    const selectFolderBtn = document.getElementById("selectFolderBtn");
    const fsPermissionStatus = document.getElementById("fsPermissionStatus");
    const folderStatusEl = document.getElementById("folderStatus");
    const rebindFolderBtn = document.getElementById("rebindFolderBtn");
    const listTabsEl = document.getElementById("listTabs");
    const addListBtn = document.getElementById("addListBtn");
    const removeListBtn = document.getElementById("removeListBtn");
    const promptInput = document.getElementById("prompt");
    
    const countInput = document.getElementById("count");
    const resolutionSelect = document.getElementById("resolution");
    const aspectRatioSelect = document.getElementById("aspectRatio");
    const enableRetryInput = document.getElementById("enableRetry");
    const maxRetriesInput = document.getElementById("maxRetries");

    resultsEl.addEventListener("dragenter", handleResultsDragEnter);
    resultsEl.addEventListener("dragover", handleResultsDragOver);
    resultsEl.addEventListener("dragleave", handleResultsDragLeave);
    resultsEl.addEventListener("drop", handleResultsDrop);

    const PROVIDER_CONFIGS = {
        google: {
            id: "google",
            label: "Google",
            keyLabel: "API KEY ACCESS",
            keyHint: "Google AI Studio API keys.",
            keyPlaceholder: "ENTER_GOOGLE_KEY_HERE",
            keyUrl: "https://aistudio.google.com/app/apikey",
            endpoint: "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent",
            providerHint: "",
            disableResolution: false,
            disableAspectRatio: false,
            resourceBase: "https://generativelanguage.googleapis.com"
        },
        fal: {
            id: "fal",
            label: "Fal AI",
            keyLabel: "FAL API KEY",
            keyHint: "Fal AI API keys.",
            keyPlaceholder: "ENTER_FAL_KEY_HERE",
            keyUrl: "https://fal.ai/dashboard/keys",
            endpoint: "https://fal.run/fal-ai/z-image/turbo",
            i2iEndpoint: "https://fal.run/fal-ai/z-image/turbo/image-to-image",
            providerHint: "Fal AI uses Z-Image Turbo. Supports Text-to-Image and Image-to-Image (if reference image provided).",
            disableResolution: false,
            disableAspectRatio: false
        }
    };

    let activeProvider = "google";
    let falModel = "default";

    function createKeyManager() {
        return {
            keys: [],
            index: 0,
            setKeys(keys) {
                const newKeys = keys.filter(Boolean);
                this.keys = newKeys;
                if (this.keys.length > 0) {
                    this.index = this.index % this.keys.length;
                } else {
                    this.index = 0;
                }
            },
            getNextKey() {
                if (!this.keys.length) return null;
                if (this.index >= this.keys.length) this.index = 0;
                const key = this.keys[this.index];
                this.index = (this.index + 1) % this.keys.length;
                return key;
            }
        };
    }

    const apiKeyManagers = {
        google: createKeyManager(),
        fal: createKeyManager()
    };

    function normalizeProvider(value) {
        const normalized = (value || "").toString().toLowerCase();
        if (normalized === "fal" || normalized === "fal-ai") return "fal";
        return "google";
    }

    function getProviderConfig(provider = activeProvider) {
        const normalized = normalizeProvider(provider);
        const baseConfig = PROVIDER_CONFIGS[normalized] || PROVIDER_CONFIGS.google;
        
        if (normalized === "fal") {
             if (falModel === "qwen-image") {
                 return {
                     ...baseConfig,
                     endpoint: "https://fal.run/fal-ai/qwen-image-2512",
                     i2iEndpoint: "https://fal.run/fal-ai/qwen-image-edit-2511"
                 };
             }
        }
        
        return baseConfig;
    }

    function getApiKeyManager(provider = activeProvider) {
        const normalized = normalizeProvider(provider);
        return apiKeyManagers[normalized] || apiKeyManagers.google;
    }

    function getApiKeyValues() {
        return Array.from(apiKeyListEl.querySelectorAll("input"))
            .map(input => input.value.trim())
            .filter(Boolean);
    }

    function updateApiKeyManagerFromInputs() {
        getApiKeyManager().setKeys(getApiKeyValues());
    }

    function setApiKeyInputs(values) {
        apiKeyListEl.innerHTML = "";
        const populated = Array.isArray(values) && values.length ? values : [""];
        populated.forEach(val => apiKeyListEl.appendChild(createApiKeyRow(val)));
        updateApiKeyManagerFromInputs();
    }

    function createApiKeyRow(value = "") {
        const row = document.createElement("div");
        row.className = "api-key-row";
        const input = document.createElement("input");
        input.type = "password";
        input.placeholder = getProviderConfig().keyPlaceholder;
        input.autocomplete = "off";
        input.value = value || "";
        const toggleBtn = document.createElement("button");
        toggleBtn.type = "button";
        toggleBtn.textContent = "SHOW";
        toggleBtn.addEventListener("click", () => {
            if (input.type === "password") {
                input.type = "text";
                toggleBtn.textContent = "HIDE";
            } else {
                input.type = "password";
                toggleBtn.textContent = "SHOW";
            }
        });
        const removeBtn = document.createElement("button");
        removeBtn.type = "button";
        removeBtn.className = "danger-action";
        removeBtn.textContent = "DEL";
        removeBtn.addEventListener("click", (e) => {
            if (!confirmAction(e, "Delete this API Key?")) return;
            
            if (apiKeyListEl.children.length === 1) {
                input.value = "";
            } else {
                row.remove();
            }
            updateApiKeyManagerFromInputs();
            saveSettings();
        });
        input.addEventListener("input", () => {
            updateApiKeyManagerFromInputs();
            saveSettings();
        });
        row.appendChild(input);
        row.appendChild(toggleBtn);
        row.appendChild(removeBtn);
        return row;
    }

    function updateApiKeyPlaceholders() {
        const placeholder = getProviderConfig().keyPlaceholder;
        apiKeyListEl.querySelectorAll("input").forEach(input => {
            input.placeholder = placeholder;
        });
    }

    function setActiveProvider(provider, options = {}) {
        const nextProvider = normalizeProvider(provider);
        if (activeProvider !== nextProvider) {
            if (!options.skipKeyPersist) {
                getApiKeyManager(activeProvider).setKeys(getApiKeyValues());
            }
            activeProvider = nextProvider;
        }
        if (providerSelect) providerSelect.value = activeProvider;
        setApiKeyInputs(getApiKeyManager(activeProvider).keys);
        updateProviderUi();
        if (!options.skipSave) saveSettings();
    }

    function updateProviderUi() {
        const config = getProviderConfig();
        const normalized = normalizeProvider(activeProvider);
        if (falModelGroup) {
            falModelGroup.style.display = normalized === "fal" ? "block" : "none";
        }
        if (falModelSelect && normalized === "fal") {
            falModelSelect.value = falModel;
        }
        if (apiKeyLabelEl) apiKeyLabelEl.textContent = config.keyLabel;
        if (apiKeyProviderHintEl) {
            apiKeyProviderHintEl.textContent = config.keyHint || "";
            apiKeyProviderHintEl.style.display = config.keyHint ? "block" : "none";
        }
        if (providerHintEl) {
            const hint = config.providerHint || "";
            providerHintEl.textContent = hint;
            providerHintEl.style.display = hint ? "block" : "none";
        }
        if (resolutionSelect) {
            const disableResolution = !!config.disableResolution;
            resolutionSelect.disabled = disableResolution;
            resolutionSelect.title = disableResolution ? "Ignored for this provider" : "";
        }
        if (aspectRatioSelect) {
            const disableAspectRatio = !!config.disableAspectRatio;
            aspectRatioSelect.disabled = disableAspectRatio;
            aspectRatioSelect.title = disableAspectRatio ? "Ignored for this provider" : "";
        }
        if (getKeyBtn) {
            if (config.keyUrl) {
                getKeyBtn.disabled = false;
                getKeyBtn.textContent = "Get Key";
                getKeyBtn.title = `Open ${config.label} key page`;
            } else {
                getKeyBtn.disabled = true;
                getKeyBtn.textContent = `${config.label} Key`;
                getKeyBtn.title = `${config.label} uses a bearer token`;
            }
        }
        updateApiKeyPlaceholders();
    }

    function setFolderStatus(text, mode = "waiting") {
        if (!fsPermissionStatus) return;
        const dot = fsPermissionStatus.querySelector(".status-dot");
        const content = fsPermissionStatus.querySelector("span:nth-child(2)");
        dot.className = "status-dot";
        if (mode === "ok") dot.classList.add("ok");
        else if (mode === "error") dot.classList.add("error");
        else dot.classList.add("busy");
        content.textContent = text;
    }

    function updateFolderStatusLabel() {
        if (!folderStatusEl) return;
        if (!workingDirectoryHandle) {
            folderStatusEl.textContent = "No output directory bound";
        } else {
            const suffix = folderAccessGranted ? "(Authorized)" : "(Pending)";
            folderStatusEl.innerHTML = `Output directory: <strong>${workingDirectoryHandle.name}</strong> ${suffix}`;
        }
        updateFolderButtonLabel();
    }

    function updateFolderButtonLabel() {
        if (!selectFolderBtn) return;
        if (workingDirectoryHandle) {
            selectFolderBtn.textContent = "Confirm output directory authorization";
        } else {
            selectFolderBtn.textContent = "Select output directory";
        }
    }

    function handleFolderAccessError(message = "Re-authorize the output directory") {
        folderAccessGranted = false;
        updateFolderStatusLabel();
        showFolderOverlay(message);
    }

    function showFolderOverlay(message = "Please authorize the output directory to continue") {
        if (!fsOverlay) return;
        fsOverlay.classList.remove("hidden");
        setFolderStatus(message, folderAccessGranted ? "ok" : "busy");
    }

    function hideFolderOverlay() {
        if (!fsOverlay) return;
        fsOverlay.classList.add("hidden");
    }

    async function checkDirectoryPermission(handle) {
        if (!handle?.queryPermission) return false;
        try {
            const status = await handle.queryPermission({ mode: "readwrite" });
            return status === "granted";
        } catch (err) {
            console.warn("Permission query failed", err);
            return false;
        }
    }

    async function ensurePersistentStorage() {
        if (!navigator?.storage?.persist) return;
        try {
            await navigator.storage.persist();
        } catch (err) {
            console.warn("Persistent storage request failed", err);
        }
    }

    async function requestDirectoryPermission(handle) {
        if (!handle) return false;
        if (await checkDirectoryPermission(handle)) return true;
        if (!handle.requestPermission) return false;
        const result = await handle.requestPermission({ mode: "readwrite" });
        return result === "granted";
    }

    async function handleFolderSelection() {
        try {
            if (!window.showDirectoryPicker && !workingDirectoryHandle) {
                setFolderStatus("This browser does not support the local file system", "error");
                return;
            }
            if (!workingDirectoryHandle) {
                const pickerOptions = { mode: "readwrite" };
                if (DIR_PICKER_ID) pickerOptions.id = DIR_PICKER_ID;
                workingDirectoryHandle = await window.showDirectoryPicker(pickerOptions);
                updateFolderStatusLabel();
            }
            const granted = await requestDirectoryPermission(workingDirectoryHandle);
            if (granted) {
                folderAccessGranted = true;
                updateFolderStatusLabel();
                setFolderStatus("Read/write access granted", "ok");
                hideFolderOverlay();
                await loadCardOrderFromDisk(true);
                await rebuildTaskIndexFromDb();
                await renderActivePage({ reason: "folder-auth" });
                persistCardOrderToDisk();
                queueDiskSync();
            } else {
                folderAccessGranted = false;
                setFolderStatus("Permission denied, please try again", "error");
            }
        } catch (err) {
            console.error(err);
            folderAccessGranted = false;
            setFolderStatus("Authorization failed, please try again", "error");
        }
    }

    function requireFolderAccess() {
        if (folderAccessGranted && workingDirectoryHandle) return true;
        showFolderOverlay();
        if (workingDirectoryHandle) setFolderStatus("Please re-authorize the output directory", "error");
        else setFolderStatus("Please select an output directory first", "error");
        return false;
    }

    function ensureRefListRegistered() {
        if (!listConfig?.lists) return;
        const existing = listConfig.lists.get(REF_LIST_ID) || {};
        listConfig.lists.set(REF_LIST_ID, {
            id: REF_LIST_ID,
            name: "REF",
            locked: true,
            hidden: true
        });
    }

    function loadListPreferences() {
        listConfig = {
            active: MAIN_LIST_ID,
            lists: new Map()
        };
        listConfig.lists.set(MAIN_LIST_ID, { id: MAIN_LIST_ID, name: "Main", locked: true });
        const saved = localStorage.getItem(LIST_STORAGE_KEY);
        if (saved) {
            try {
                const parsed = JSON.parse(saved);
                if (Array.isArray(parsed.lists)) {
                    const ordered = [];
                    parsed.lists.forEach(item => {
                        if (item.id === MAIN_LIST_ID) {
                            ordered.push({ id: MAIN_LIST_ID, name: "Main", locked: true, hidden: false });
                        } else {
                            ordered.push({ id: item.id, name: item.name || "List", locked: !!item.locked && item.id === MAIN_LIST_ID, hidden: !!item.hidden });
                        }
                    });
                    listConfig.lists.clear();
                    ordered.forEach(item => {
                        if (!item.id) return;
                        const locked = item.id === MAIN_LIST_ID ? true : !!item.locked;
                        const name = item.id === MAIN_LIST_ID ? "Main" : item.name || "List";
                        const hidden = item.id === REF_LIST_ID ? true : !!item.hidden;
                        listConfig.lists.set(item.id, { id: item.id, name, locked, hidden });
                    });
                    if (!listConfig.lists.has(MAIN_LIST_ID)) {
                        listConfig.lists = new Map([[MAIN_LIST_ID, { id: MAIN_LIST_ID, name: "Main", locked: true }]]);
                        ensureRefListRegistered();
                    }
                }
                if (parsed.active && listConfig.lists.has(parsed.active)) {
                    listConfig.active = parsed.active;
                }
            } catch (err) {
                console.warn("Load list preferences failed", err);
            }
        }
        ensureRefListRegistered();
        refListVisible = listConfig.active === REF_LIST_ID;
        renderListTabs();
        updateMoveAllControl();
    }

    function saveListPreferences() {
        const payload = {
            active: listConfig.active === REF_LIST_ID ? MAIN_LIST_ID : listConfig.active,
            lists: Array.from(listConfig.lists.values()).map(list => ({
                id: list.id,
                name: list.name,
                locked: !!list.locked,
                hidden: !!list.hidden
            }))
        };
        localStorage.setItem(LIST_STORAGE_KEY, JSON.stringify(payload));

        listConfigDirty = true;
        persistCardOrderToDisk();
    }

    function getListCardCount(listId) {
        return getOrderedTaskIdsForList(listId).length;
    }

    // --- New function: handle list reordering ---
    function reorderLists(sourceId, targetId, position) {
        if (sourceId === targetId || sourceId === MAIN_LIST_ID) return; // Main list cannot be moved

        // 1. Convert the Map to an array for easier operations
        let listArray = Array.from(listConfig.lists.values());
        
        // 2. Find the source and target indexes
        const sourceIndex = listArray.findIndex(l => l.id === sourceId);
        const targetIndex = listArray.findIndex(l => l.id === targetId);
        
        if (sourceIndex === -1 || targetIndex === -1) return;

        // 3. Remove the source element
        const [movedItem] = listArray.splice(sourceIndex, 1);

        // 4. Compute the insertion spot (removing an element shifts indexes, so recompute the target index)
        const newTargetIndex = listArray.findIndex(l => l.id === targetId);
        
        if (position === 'before') {
            // If the target is the Main List and the insertion tries to precede it, force the position to index 1
            if (listArray[newTargetIndex].id === MAIN_LIST_ID) {
                 listArray.splice(1, 0, movedItem);
            } else {
                 listArray.splice(newTargetIndex, 0, movedItem);
            }
        } else {
            listArray.splice(newTargetIndex + 1, 0, movedItem);
        }

        // 5. Keep the Main List at index 0 (double safety)
        const mainListIndex = listArray.findIndex(l => l.id === MAIN_LIST_ID);
        if (mainListIndex > 0) {
            const [mainItem] = listArray.splice(mainListIndex, 1);
            listArray.unshift(mainItem);
        }

        // 6. Rebuild the Map and persist it
        listConfig.lists = new Map(listArray.map(item => [item.id, item]));
        ensureRefListRegistered();
        saveListPreferences();
        renderListTabs();
    }

    function renderListTabs() {
        if (!listTabsEl) return;
        listTabsEl.innerHTML = "";
        
        listConfig.lists.forEach(list => {
            const isRefList = list.id === REF_LIST_ID;
            const isVisibleRef = isRefList && (refListVisible || listConfig.active === REF_LIST_ID);
            if (list.hidden && !isVisibleRef) return;
            const tab = document.createElement("div");
            // Main List cannot be dragged; other lists can
            const isMain = list.id === MAIN_LIST_ID;
            tab.className = "list-tab" + (list.id === listConfig.active ? " active" : "");
            if (!isMain) {
                tab.draggable = true;
                tab.style.cursor = "grab"; 
            }
            tab.dataset.listId = list.id;

            const nameSpan = document.createElement("span");
            nameSpan.textContent = `${list.name} (${getListCardCount(list.id)})`;
            
            if (!list.locked) {
                nameSpan.title = "Double-click to rename";
                nameSpan.style.cursor = "text"; 
                nameSpan.addEventListener("dblclick", (e) => {
                    e.stopPropagation();
                    const newName = prompt("Rename list:", list.name);
                    if (newName && newName.trim()) {
                        list.name = newName.trim();
                        saveListPreferences();
                        renderListTabs();
                        updateMoveAllControl();
                    }
                });
            }
            tab.appendChild(nameSpan);

            // Click to switch lists
            tab.addEventListener("click", () => setActiveList(list.id));

            // --- Drag-and-drop handling start ---
            
            // 1. Start dragging (list ordering only)
            if (!isMain) {
                tab.addEventListener("dragstart", (e) => {
                    e.stopPropagation();
                    e.dataTransfer.setData("application/x-nano-list-id", list.id);
                    e.dataTransfer.effectAllowed = "move";
                    tab.classList.add("dragging");
                });

                tab.addEventListener("dragend", (e) => {
                    tab.classList.remove("dragging");
                    document.querySelectorAll(".list-tab").forEach(t => {
                        t.classList.remove("drag-over-left", "drag-over-right");
                    });
                });
            }

            // 2. Drag over (handles list ordering and card reassignment)
            tab.addEventListener("dragover", (e) => {
                e.preventDefault(); // allow drop
                const types = Array.from(e.dataTransfer?.types || []);

                // Case A: dragging a card (existing behavior)
                if (types.includes("application/x-nano-card-id")) {
                    tab.classList.add("drop-target");
                    e.dataTransfer.dropEffect = "move";
                    return;
                }

                // Case B: dragging a list (new behavior)
                if (types.includes("application/x-nano-list-id")) {
                    // Ignore drops on itself or attempts to drag the Main List (still blocked at dragstart)
                    if (tab.classList.contains("dragging")) return;

                    const rect = tab.getBoundingClientRect();
                    const midX = rect.left + rect.width / 2;
                    
                    // Determine whether the cursor is on the left or right half
                    if (e.clientX < midX) {
                        tab.classList.add("drag-over-left");
                        tab.classList.remove("drag-over-right");
                    } else {
                        tab.classList.add("drag-over-right");
                        tab.classList.remove("drag-over-left");
                    }
                }
            });

            // 3. Drag leave
            tab.addEventListener("dragleave", () => {
                tab.classList.remove("drop-target", "drag-over-left", "drag-over-right");
            });

            // 4. Drop
            tab.addEventListener("drop", (e) => {
                e.preventDefault();
                tab.classList.remove("drop-target", "drag-over-left", "drag-over-right");
                
                // Handle card reassignment
                const cardTaskId = e.dataTransfer.getData("application/x-nano-card-id");
                if (cardTaskId) {
                    assignCardToList(cardTaskId, list.id);
                    return;
                }

                // Handle list ordering
                const sourceListId = e.dataTransfer.getData("application/x-nano-list-id");
                if (sourceListId) {
                    const rect = tab.getBoundingClientRect();
                    const midX = rect.left + rect.width / 2;
                    const position = e.clientX < midX ? 'before' : 'after';
                    reorderLists(sourceListId, list.id, position);
                }
            });
            // --- Drag-and-drop handling end ---

            listTabsEl.appendChild(tab);
        });
        updateListActionButtons();
    }

    function updateListActionButtons() {
        if (!removeListBtn) return;
        const activeList = listConfig.lists.get(listConfig.active);
        const canDelete = !!activeList && !activeList.locked;
        removeListBtn.disabled = !canDelete;
        if (canDelete) {
            removeListBtn.title = `Delete list "${activeList.name}"`;
        } else {
            removeListBtn.title = "Main list cannot be deleted";
        }
    }

    function setActiveList(listId) {
        const isRefTarget = listId === REF_LIST_ID;
        if (isRefTarget) {
            ensureRefListRegistered();
            refListVisible = true;
        } else {
            refListVisible = false;
        }
        if (!listConfig.lists.has(listId)) listId = MAIN_LIST_ID;
        listConfig.active = listId;
        if (isRefTarget) {
            filterResultsView();
        } else {
            saveListPreferences();
            filterResultsView();
        }
    }

    function filterResultsView() {
        renderActivePage({ reason: "filter" });
    }

    function findCardImage(card) {
        if (!card) return null;
        return card.querySelector(".thumb-wrap img") || card.querySelector("img");
    }

    function offloadCardMedia(card) {
        if (!card || card.classList.contains("skeleton")) return;
        const img = findCardImage(card);
        if (!img || img.dataset.mediaOffloaded === "true") return;
        const taskId = card.dataset.taskId;
        const currentSrc = img.src || img.getAttribute("src");
        if (currentSrc && currentSrc.startsWith("blob:")) {
            revokeObjectUrl(currentSrc);
            if (img.dataset.usingObjectUrl === "true") {
                const record = resultsData.get(taskId);
                if (record && record.objectUrl === currentSrc) {
                    record.objectUrl = null;
                }
                delete img.dataset.usingObjectUrl;
            }
        }
        img.removeAttribute("src");
        img.src = "";
        img.dataset.mediaOffloaded = "true";
        delete img.dataset.restoring;
        card.classList.add("media-offloaded");
    }

    async function restoreCardMedia(card) {
        if (!card || card.classList.contains("skeleton")) return;
        const img = findCardImage(card);
        if (!img || img.dataset.mediaOffloaded !== "true" || img.dataset.restoring === "true") return;
        const taskId = card.dataset.taskId;
        if (!taskId) {
            delete img.dataset.mediaOffloaded;
            return;
        }
        img.dataset.restoring = "true";
        try {
            let nextSrc = await fetchStoredThumbnail(taskId);
            let record = resultsData.get(taskId);
            if (!nextSrc) {
                const stored = await fetchStoredResultRecord(taskId);
                if (stored) {
                    record = rememberResultRecord(taskId, {
                        meta: stored.meta,
                        prompt: stored.prompt,
                        listId: stored.listId || MAIN_LIST_ID,
                        timestamp: stored.timestamp || Date.now(),
                        refImageIds: Array.isArray(stored.refImageIds) ? stored.refImageIds : []
                    });
                    if (stored.thumbnail) {
                        nextSrc = stored.thumbnail;
                    } else if (stored.meta) {
                        nextSrc = await hydrateMissingThumbnail({
                            taskId: stored.taskId,
                            meta: stored.meta,
                            thumbnail: stored.thumbnail || null
                        });
                    }
                }
            }
            if (!nextSrc && record?.meta) {
                nextSrc = await hydrateMissingThumbnail({
                    taskId,
                    meta: record.meta,
                    thumbnail: null
                });
            }
            if (!nextSrc) {
                const base64 = await fetchFullBase64(taskId);
                if (base64) {
                    try {
                        const mimeType = record?.meta?.mimeType || DEFAULT_IMAGE_MIME;
                        nextSrc = `data:${mimeType};base64,${base64}`;
                    } catch (err) {
                        console.warn("Failed to rebuild inline preview", err);
                    }
                }
            }

            if (nextSrc instanceof Blob) {
                nextSrc = URL.createObjectURL(nextSrc);
            }
            
            // Safety: Revoke existing blob if we are replacing it
            if (img.src && img.src.startsWith("blob:") && img.src !== nextSrc) {
                revokeObjectUrl(img.src);
            }

            if (!nextSrc) {
                img.src = REF_PLACEHOLDER_IMG;
                delete img.dataset.usingObjectUrl;
            } else {
                img.src = nextSrc;
                if (nextSrc.startsWith("blob:")) {
                    img.dataset.usingObjectUrl = "true";
                } else {
                    delete img.dataset.usingObjectUrl;
                }
            }
            delete img.dataset.mediaOffloaded;
            card.classList.remove("media-offloaded");
        } catch (err) {
            console.warn("Failed to restore media for card", taskId, err);
        } finally {
            delete img.dataset.restoring;
        }
    }

    function ensureCardVisibilityObserver() {
        if (cardVisibilityObserver || typeof IntersectionObserver === "undefined") return cardVisibilityObserver;
        cardVisibilityObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                const card = entry.target;
                if (!card || card.classList.contains("skeleton")) return;
                if (entry.isIntersecting) {
                    restoreCardMedia(card).catch(err => console.warn("Restore media failed", err));
                } else {
                    offloadCardMedia(card);
                }
            });
        }, {
            root: resultsEl || null,
            rootMargin: "256px 0px",
            threshold: 0.05
        });
        return cardVisibilityObserver;
    }

    function observeCardMedia(card) {
        if (!card || card.dataset.mediaObserverAttached === "true") return;
        const observer = ensureCardVisibilityObserver();
        if (!observer) return;
        observer.observe(card);
        card.dataset.mediaObserverAttached = "true";
    }

    function unobserveCardMedia(card) {
        if (!cardVisibilityObserver || !card || card.dataset.mediaObserverAttached !== "true") return;
        cardVisibilityObserver.unobserve(card);
        delete card.dataset.mediaObserverAttached;
    }

    function updateMoveAllControl() {
        if (!listMoveAllSelectEl || !listMoveAllHintEl) return;
        const currentValue = listMoveAllSelectEl.value;
        const availableTargets = Array.from(listConfig.lists.values()).filter(list => {
            if (list.id === listConfig.active) return false;
            if (!list.hidden) return true;
            return list.id === REF_LIST_ID && (refListVisible || listConfig.active === REF_LIST_ID);
        });
        listMoveAllSelectEl.innerHTML = "";
        if (!availableTargets.length) {
            const opt = document.createElement("option");
            opt.value = "";
            opt.textContent = "No other lists yet";
            listMoveAllSelectEl.appendChild(opt);
        } else {
            availableTargets.forEach((list) => {
                const opt = document.createElement("option");
                opt.value = list.id;
                opt.textContent = list.name;
                if (currentValue === list.id) opt.selected = true;
                listMoveAllSelectEl.appendChild(opt);
            });
            if (!listMoveAllSelectEl.value && availableTargets[0]) {
                listMoveAllSelectEl.value = availableTargets[0].id;
            }
        }
        const activeCount = getListCardCount(listConfig.active);
        const activeName = listConfig.lists.get(listConfig.active)?.name || "Current";
        listMoveAllSelectEl.disabled = availableTargets.length === 0;
        if (listMoveAllBtn) {
            listMoveAllBtn.disabled = availableTargets.length === 0 || activeCount === 0;
        }
        listMoveAllHintEl.textContent = activeCount ? `${activeName} ¬∑ ${activeCount} tasks` : `${activeName} list has no tasks`;
    }

    function openListMoveOverlay() {
        if (!listMoveOverlayEl) return;
        updateMoveAllControl();
        listMoveOverlayEl.classList.remove("hidden");
        listMoveOverlayEl.setAttribute("aria-hidden", "false");
        setTimeout(() => listMoveAllSelectEl?.focus(), 0);
    }

    function closeListMoveOverlay() {
        if (!listMoveOverlayEl) return;
        listMoveOverlayEl.classList.add("hidden");
        listMoveOverlayEl.setAttribute("aria-hidden", "true");
    }

    function toggleListMoveOverlay() {
        if (!listMoveOverlayEl) return;
        if (listMoveOverlayEl.classList.contains("hidden")) openListMoveOverlay();
        else closeListMoveOverlay();
    }

    async function updateTaskListId(taskId, targetListId) {
        if (!taskId) return;
        const listId = listConfig.lists.has(targetListId) ? targetListId : MAIN_LIST_ID;
        const meta = taskIndex.get(taskId);
        if (meta) {
            meta.listId = listId;
            taskIndex.set(taskId, meta);
        } else {
            upsertTaskIndexEntry(taskId, { listId, type: TASK_TYPES.RESULT });
        }
        const record = resultsData.get(taskId);
        if (record) {
            record.listId = listId;
        }
        const runtime = getTaskRuntimeInfo(taskId);
        if (runtime) {
            runtime.listId = listId;
            taskRuntimeInfo.set(taskId, runtime);
        }
        const pending = pendingTaskRecords.get(taskId);
        if (pending) {
            pending.listId = listId;
            pendingTaskRecords.set(taskId, pending);
            persistPendingTaskRecords();
        }
        await updateStoredResult(taskId, { listId });
        if (folderAccessGranted) {
            const stored = record || await fetchStoredResultRecord(taskId);
            if (stored) {
                stored.listId = listId;
                await persistResultMetadataSnapshot(taskId, stored);
            }
        }
    }

    async function assignCardToList(taskId, targetListId) {
        if (!taskId) return;
        await updateTaskListId(taskId, targetListId);
        renderActivePage({ reason: "list-assign" });
    }

    async function moveActiveListTasks(targetListId) {
        if (!listConfig.lists.has(targetListId)) {
            setTemporaryErrorStatus("The target list is invalid");
            return false;
        }
        const sourceListId = listConfig.active;
        if (sourceListId === targetListId) {
            setTemporaryErrorStatus("Please choose a different target list");
            return false;
        }
        const ids = getOrderedTaskIdsForList(sourceListId);
        if (!ids.length) {
            setTemporaryErrorStatus("There are no tasks in the current list");
            return false;
        }
        for (const taskId of ids) {
            await updateTaskListId(taskId, targetListId);
        }
        renderActivePage({ reason: "move-all" });
        return true;
    }

    async function handleMoveAllBtnClick() {
        if (!listMoveAllSelectEl) return;
        const targetListId = listMoveAllSelectEl.value;
        if (!targetListId) {
            setTemporaryErrorStatus("Please select a target list");
            return;
        }
        const moved = await moveActiveListTasks(targetListId);
        if (moved) closeListMoveOverlay();
    }

    function addCustomList() {
        const name = prompt("Please enter a list name", "New List");
        if (!name) return;
        const id = `list_${Date.now().toString(36)}`;
        listConfig.lists.set(id, { id, name: name.trim() || "List", locked: false });
        saveListPreferences();
        setActiveList(id);
    }

    async function removeList(listId) {
        const list = listConfig.lists.get(listId);
        if (!list || list.locked) return;
        const confirmed = confirm(`Delete the list "${list.name}"?`);
        if (!confirmed) return;
        listConfig.lists.delete(listId);
        const affectedIds = getOrderedTaskIdsForList(listId);
        let deleteAll = false;
        if (affectedIds.length) {
            deleteAll = confirm(`How should the ${affectedIds.length} tasks be handled after deleting the list?\nOK = Delete all tasks\nCancel = Move them to the Main List`);
        }
        if (deleteAll) {
            for (const taskId of affectedIds) {
                await purgeResultRecord(taskId);
                removeTaskFromOrder(taskId);
                removeTaskIndexEntry(taskId);
                removePendingTask(taskId);
            }
        } else {
            for (const taskId of affectedIds) {
                await updateTaskListId(taskId, MAIN_LIST_ID);
            }
        }
        if (listConfig.active === listId) listConfig.active = MAIN_LIST_ID;
        pageState.pageByListId.delete(listId);
        saveListPreferences();
        renderActivePage({ reason: "remove-list" });
    }

    // Attach auto-save to inputs
    [promptInput, countInput, resolutionSelect, aspectRatioSelect, enableRetryInput, maxRetriesInput].forEach(el => {
        el.addEventListener('input', saveSettings);
        el.addEventListener('change', saveSettings);
    });
    if (providerSelect) {
        providerSelect.addEventListener("change", () => {
            setActiveProvider(providerSelect.value);
        });
    }
    if (falModelSelect) {
        falModelSelect.addEventListener("change", () => {
            falModel = falModelSelect.value || "default";
            if (activeProvider === "fal") updateProviderUi();
            saveSettings();
        });
    }

    addApiKeyBtn.addEventListener("click", () => {
        apiKeyListEl.appendChild(createApiKeyRow());
    });
    if (getKeyBtn) {
        getKeyBtn.addEventListener("click", () => {
            const config = getProviderConfig();
            if (!config.keyUrl) return;
            window.open(config.keyUrl, "_blank");
        });
    }
    addListBtn.addEventListener("click", addCustomList);
    removeListBtn.addEventListener("click", () => {
        const activeList = listConfig.lists.get(listConfig.active);
        if (!activeList || activeList.locked) return;
        removeList(listConfig.active).catch(console.error);
    });
    selectFolderBtn.addEventListener("click", handleFolderSelection);
    rebindFolderBtn.addEventListener("click", () => {
        workingDirectoryHandle = null;
        folderAccessGranted = false;
        resetCardOrderTracking();
        updateFolderStatusLabel();
        showFolderOverlay("Please choose a new output directory");
    });
    if (importBtn && importInput) {
        importBtn.addEventListener("click", (e) => {
            importBatchMode = !!e.metaKey;
            importInput.click();
        });
        importInput.addEventListener("change", (e) => {
            const files = Array.from(e.target.files || []);
            if (files.length) {
                if (importBatchMode) {
                    handleBatchImageImport(files);
                } else {
                    handleManualImageImport(files);
                }
            }
            importBatchMode = false;
            importInput.value = "";
        });
    }
    if (listMoveAllBtn) {
        listMoveAllBtn.addEventListener("click", handleMoveAllBtnClick);
    }
    if (listMoveCancelBtn) {
        listMoveCancelBtn.addEventListener("click", () => closeListMoveOverlay());
    }
    if (listMoveOverlayEl) {
        listMoveOverlayEl.addEventListener("click", (e) => {
            if (e.target === listMoveOverlayEl) closeListMoveOverlay();
        });
    }

    const dropZone = document.getElementById("dropZone");
    const refInput = document.getElementById("refImages");
    const pasteRefBtn = document.getElementById("pasteRefBtn");
    const refImageListEl = document.getElementById("refImageList");
    const refImageHintEl = document.getElementById("refImageHint");
    const clearAllRefsBtn = document.getElementById("clearAllRefsBtn");

    const lightbox = document.getElementById("lightbox");
    const lightboxImage = document.getElementById("lightboxImage");
    const lightboxClose = document.querySelector("#lightbox .lightbox-close");
    const lightboxTools = document.getElementById("lightboxTools");
    const lbReplaceCompressedBtn = document.getElementById("lbReplaceCompressedBtn");
    const lbResizeMode = document.getElementById("lbResizeMode");
    const lbScaleInput = document.getElementById("lbScaleInput");
    const lbScaleNumber = document.getElementById("lbScaleNumber");
    const lbScaleRow = document.getElementById("lbScaleRow");
    const lbCustomRow = document.getElementById("lbCustomRow");
    const lbCustomWidth = document.getElementById("lbCustomWidth");
    const lbCustomHeight = document.getElementById("lbCustomHeight");
    const lbLockAspect = document.getElementById("lbLockAspect");
    const lbQualityInput = document.getElementById("lbQualityInput");
    const lbQualityNumber = document.getElementById("lbQualityNumber");
    const lbPreview = document.getElementById("lbPreview");
    const lbPreviewCanvas = document.getElementById("lbPreviewCanvas");
    const lbPreviewBefore = document.getElementById("lbPreviewBefore");
    const lbPreviewAfter = document.getElementById("lbPreviewAfter");
    const lbPreviewDivider = document.getElementById("lbPreviewDivider");
    const lbSaveCompressedBtn = document.getElementById("lbSaveCompressedBtn");
    const lbRefreshPreviewBtn = document.getElementById("lbRefreshPreviewBtn");
    const lbExitCompressBtn = document.getElementById("lbExitCompressBtn");
    const lbSourceInfo = document.getElementById("lbSourceInfo");
    const lbSizeInfo = document.getElementById("lbSizeInfo");
    const lbStatusChip = document.getElementById("lbStatusChip");
    const lbDimensionHint = document.getElementById("lbDimensionHint");
    const lbQualityHint = document.getElementById("lbQualityHint");
    const lbStatBefore = document.getElementById("lbStatBefore");
    const lbStatAfter = document.getElementById("lbStatAfter");
    const lbStatSaved = document.getElementById("lbStatSaved");

    const lightboxUpscaleTools = document.getElementById("lightboxUpscaleTools");
    
    const lightboxEditTools = document.getElementById("lightboxEditTools");
    const lbEditCanvas = document.getElementById("lbEditCanvas");
    const lbCropOverlay = document.getElementById("lbCropOverlay");
    const lbMaskCanvas = document.getElementById("lbMaskCanvas");
    const lbMaskTools = document.getElementById("lbMaskTools");
    const lbEditStatus = document.getElementById("lbEditStatus");
    const lbCropToggleBtn = document.getElementById("lbCropToggleBtn");
    const lbRotateBtn = document.getElementById("lbRotateBtn");
    const lbPaintToggleBtn = document.getElementById("lbPaintToggleBtn");
    const lbClearMaskBtn = document.getElementById("lbClearMaskBtn");
    const lbBrushSize = document.getElementById("lbBrushSize");
    const lbBrightness = document.getElementById("lbBrightness");
    const lbContrast = document.getElementById("lbContrast");
    const lbSaturation = document.getElementById("lbSaturation");
    const lbGrayscale = document.getElementById("lbGrayscale");
    const lbEditSaveNewBtn = document.getElementById("lbEditSaveNewBtn");
    const lbEditSaveReplaceBtn = document.getElementById("lbEditSaveReplaceBtn");
    const lbEditExitBtn = document.getElementById("lbEditExitBtn");
    const lbAdjustControls = document.getElementById("lbAdjustControls");
    const lbInpaintControls = document.getElementById("lbInpaintControls");
    const lbInpaintPrompt = document.getElementById("lbInpaintPrompt");
    const lbInpaintSubmitBtn = document.getElementById("lbInpaintSubmitBtn");
    const lbUpscalePreview = document.getElementById("lbUpscalePreview");
    const lbUpscaleFactor = document.getElementById("lbUpscaleFactor");
    const lbUpscaleNoise = document.getElementById("lbUpscaleNoise");
    const lbUpscaleNoiseNum = document.getElementById("lbUpscaleNoiseNum");
    const lbUpscaleSubmitBtn = document.getElementById("lbUpscaleSubmitBtn");
    const lbUpscaleExitBtn = document.getElementById("lbUpscaleExitBtn");
    const lbUpscaleOriginSize = document.getElementById("lbUpscaleOriginSize");
    const lbUpscaleTargetSize = document.getElementById("lbUpscaleTargetSize");
    const lbUpscaleCost = document.getElementById("lbUpscaleCost");
    const compareSelectHintEl = document.getElementById("compareSelectHint");
    const compareOverlay = document.getElementById("compareOverlay");
    const compareViewEl = document.getElementById("compareView");
    const compareViewCanvas = document.getElementById("compareViewCanvas");
    const compareImgLeft = document.getElementById("compareImgLeft");
    const compareImgRight = document.getElementById("compareImgRight");
    const compareDivider = document.getElementById("compareDivider");
    if (importConfirmBtn) importConfirmBtn.addEventListener("click", confirmImportDialog);
    if (importCancelBtn) importCancelBtn.addEventListener("click", () => cancelImportDialog());
    if (importOverlayEl) {
        importOverlayEl.addEventListener("click", (e) => {
            if (e.target === importOverlayEl) cancelImportDialog();
        });
    }
    document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && importOverlayEl && !importOverlayEl.classList.contains("hidden") && importDialogResolver) {
            cancelImportDialog();
        }
    });

    function queueDiskSync() {
        diskSyncQueued = true;
        attemptDiskSync();
    }

    function attemptDiskSync() {
        if (!diskSyncQueued) return;
        if (!folderAccessGranted || !workingDirectoryHandle || !dbHydrated) return;
        diskSyncQueued = false;
        syncResultsFromDirectory();
    }

    function reconcileGlobalOrderWithRecords(records = [], extraIds = []) {
        const dbIds = new Set(records.map(record => record.taskId).filter(Boolean));
        const keepIds = new Set([...dbIds, ...extraIds]);
        const filtered = cardOrder.filter(id => keepIds.has(id));
        const present = new Set(filtered);
        const missing = records
            .filter(record => record?.taskId && !present.has(record.taskId))
            .sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
        missing.forEach(record => {
            filtered.push(record.taskId);
            present.add(record.taskId);
        });
        extraIds.forEach(id => {
            if (!present.has(id)) {
                filtered.unshift(id);
                present.add(id);
            }
        });
        const changed = filtered.length !== cardOrder.length || filtered.some((id, idx) => id !== cardOrder[idx]);
        if (changed) {
            cardOrder = filtered;
            markCardOrderDirty();
        }
    }

    async function fetchAllResultIndex() {
        const db = await openDB();
        const tx = db.transaction(STORE_RESULTS, "readonly");
        const store = tx.objectStore(STORE_RESULTS);
        const hasIndex = store.indexNames && store.indexNames.contains(RESULT_TIMESTAMP_INDEX);
        const source = hasIndex ? store.index(RESULT_TIMESTAMP_INDEX) : store;
        return await new Promise((resolve, reject) => {
            const items = [];
            const request = source.openCursor(null, "next");
            request.onerror = () => reject(request.error);
            request.onsuccess = (event) => {
                const cursor = event.target.result;
                if (!cursor) return resolve(items);
                const value = cursor.value;
                if (value?.taskId) {
                    items.push({
                        taskId: value.taskId,
                        listId: value.listId || MAIN_LIST_ID,
                        timestamp: value.timestamp || 0
                    });
                }
                cursor.continue();
            };
        });
    }

    async function rebuildTaskIndexFromDb() {
        const records = await fetchAllResultIndex();
        const nonResultEntries = Array.from(taskIndex.entries())
            .filter(([, meta]) => meta?.type && meta.type !== TASK_TYPES.RESULT);
        taskIndex.clear();
        const foundListIds = new Set();
        records.forEach(record => {
            if (!record?.taskId) return;
            upsertTaskIndexEntry(record.taskId, {
                listId: record.listId || MAIN_LIST_ID,
                timestamp: record.timestamp || Date.now(),
                type: TASK_TYPES.RESULT
            });
            if (record.listId) foundListIds.add(record.listId);
        });
        const extraIds = [];
        nonResultEntries.forEach(([taskId, meta]) => {
            if (!taskId || !meta) return;
            taskIndex.set(taskId, meta);
            extraIds.push(taskId);
        });
        let configChanged = false;
        foundListIds.forEach(id => {
            if (!id || listConfig.lists.has(id)) return;
            const newName = id.startsWith("list_") ? `Recovered List ${id.slice(-4)}` : `List ${id}`;
            listConfig.lists.set(id, { id, name: newName, locked: false });
            configChanged = true;
        });
        if (configChanged) {
            saveListPreferences();
        }
        ensureRefListRegistered();
        reconcileGlobalOrderWithRecords(records, extraIds);
        maybeNormalizeStoredOrderDirection();
    }

    async function hydrateMissingThumbnail(recordMeta) {
        if (!recordMeta || recordMeta.thumbnail) return recordMeta?.thumbnail || null;
        try {
            const base64 = await fetchFullBase64(recordMeta.taskId);
            if (!base64) return null;
            const mime = recordMeta.meta?.mimeType || DEFAULT_IMAGE_MIME;
            const thumb = await generateThumbnail(base64, mime);
            if (thumb) {
                recordMeta.thumbnail = thumb;
                await updateStoredResult(recordMeta.taskId, { thumbnail: thumb });
            }
            return thumb;
        } catch (err) {
            console.warn("Thumbnail hydration failed", err);
            return null;
        }
    }

    /* --- Initialization Logic --- */
    async function initApp() {
        await ensurePersistentStorage();
        loadListPreferences();
        loadSettings();
        try {
            const db = await openDB();
            updateFolderStatusLabel();
            folderAccessGranted = false;
            showFolderOverlay("Please choose an output directory");
            await loadStoredRefSelections(db);
            await rebuildTaskIndexFromDb();
            await renderActivePage({ reason: "init" });
            dbHydrated = true;
            attemptDiskSync();
        } catch(e) {
            console.error("DB Init Error:", e);
            setTemporaryErrorStatus("Storage initialization failed.");
            dbHydrated = true;
            attemptDiskSync();
        }
        restorePendingTaskCards();
    }

    function updateGlobalStatus() {
        const runningCount = activeTasks.size;
        const dot = statusEl.querySelector(".status-dot");
        const text = statusEl.querySelector("span:nth-child(2)");
        statusEl.classList.remove("error");
        dot.className = "status-dot";

        if (runningCount > 0) {
            dot.classList.add("busy");
            text.textContent = `PROCESSING (${runningCount})`;
            cancelAllBtn.style.display = "inline-flex"; 
            generateBtn.textContent = "üçå ADD BATCH";
        } else {
            dot.classList.add("ok");
            text.textContent = "READY";
            cancelAllBtn.style.display = "none"; 
            generateBtn.textContent = "üçå INITIALIZE";
        }
    }
    
    function setTemporaryErrorStatus(msg) {
        const dot = statusEl.querySelector(".status-dot");
        const text = statusEl.querySelector("span:nth-child(2)");
        statusEl.classList.add("error");
        dot.className = "status-dot error";
        text.textContent = msg;
        setTimeout(() => updateGlobalStatus(), 3000);
    }

    function setTemporaryStatus(msg) {
        const dot = statusEl.querySelector(".status-dot");
        const text = statusEl.querySelector("span:nth-child(2)");
        statusEl.classList.remove("error");
        dot.className = "status-dot ok";
        text.textContent = msg;
        setTimeout(() => updateGlobalStatus(), 3000);
    }
    
    function updateResultsCount() {
      updateMoveAllControl();
      renderListTabs();
      const activeListId = listConfig.active || MAIN_LIST_ID;
      const { pageIndex, totalPages } = clampPageIndex(activeListId, ensurePageIndex(activeListId));
      updatePaginationControls(activeListId, pageIndex, totalPages);
    }

    /* --- Lightbox Logic (Same as before) --- */
    const lbUpscaleState = { active: false, factor: 2 };
    const lbEditState = {
        active: false,
        img: null,
        canvas: null,
        ctx: null,
        adjust: { brightness: 100, contrast: 100, saturation: 100, grayscale: 0, rotation: 0 },
        crop: { active: false, rect: null, dragging: null, dragStart: {x:0,y:0} },
        paint: { active: false, drawing: false, lastPos: null },
        view: { scale: 1, x: 0, y: 0, isDragging: false, dragStart: {x:0, y:0} } // Viewport transform
    };
    const lbCompressState = {
        active: false,
        taskId: null,
        context: null,
        base64: null,
        sourceMime: DEFAULT_IMAGE_MIME,
        originalBytes: 0,
        originalWidth: 0,
        originalHeight: 0,
        targetWidth: 0,
        targetHeight: 0,
        resizeMode: "scale",
        scale: 100,
        customWidth: null,
        customHeight: null,
        lockAspect: true,
        quality: 95,
        split: 50,
        compressedBase64: null,
        compressedBytes: 0,
        baseBitmap: null,
        prompt: "",
        listId: MAIN_LIST_ID,
        refImageIds: [],
        meta: {},
        status: "",
        loading: false
    };
    let lbPreviewDebounce = null;
    let lbState = { isZoomed: false, scale: 1, x: 0, y: 0, isDragging: false, startX: 0, startY: 0, initialTx: 0, initialTy: 0, dragMoved: false, skipNextClick: false };
    const lbPreviewZoomState = { scale: 1, x: 0, y: 0, isDragging: false, startX: 0, startY: 0, initialX: 0, initialY: 0 };
    let lastCursorX = window.innerWidth / 2;
    let lastCursorY = window.innerHeight / 2;
    const compareModeState = { active: false, selections: [], pickOrder: [], overlayVisible: false };
    const editSelectionModeState = { active: false };
    const compareViewState = { scale: 1, x: 0, y: 0, isDragging: false, startX: 0, startY: 0, initialX: 0, initialY: 0, split: 50 };

    function estimateBase64Bytes(base64 = "") {
        if (!base64) return 0;
        const clean = base64.replace(/\s+/g, "");
        const padding = (clean.slice(-2).match(/=/g) || []).length;
        return Math.max(0, Math.floor((clean.length * 3) / 4) - padding);
    }

    function formatBytesShort(bytes = 0) {
        if (!Number.isFinite(bytes) || bytes <= 0) return "0 B";
        if (bytes < 1024) return `${bytes} B`;
        if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
        return `${(bytes / 1048576).toFixed(2)} MB`;
    }

    function ratioFromDims(w, h) {
        if (!w || !h) return "";
        const gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));
        const g = gcd(Math.round(Math.abs(w)), Math.round(Math.abs(h))) || 1;
        return `${Math.round(w / g)}:${Math.round(h / g)}`;
    }

    function setCompressionStatus(text) {
        if (lbStatusChip) lbStatusChip.textContent = text;
        lbCompressState.status = text;
    }

    function resetCompressionPreviewZoom() {
        lbPreviewZoomState.scale = 1;
        lbPreviewZoomState.x = 0;
        lbPreviewZoomState.y = 0;
        lbPreviewZoomState.isDragging = false;
        if (lbPreviewCanvas) lbPreviewCanvas.style.transform = "";
        if (lbPreview) {
            lbPreview.classList.remove("zoomed");
            lbPreview.classList.remove("dragging");
        }
    }

    function updateCompressionPreviewTransform() {
        const { scale, x, y } = lbPreviewZoomState;
        const transform = `translate(${x}px, ${y}px) scale(${scale})`;
        if (lbPreviewCanvas) lbPreviewCanvas.style.transform = transform;
        if (lbPreview) {
            if (scale !== 1 || x !== 0 || y !== 0) lbPreview.classList.add("zoomed");
            else lbPreview.classList.remove("zoomed");
        }
    }

    function adjustCompressionPreviewScale(delta) {
        if (!lbPreview) return;
        const oldScale = lbPreviewZoomState.scale || 1;
        const nextScale = Math.min(20, Math.max(0.2, oldScale + delta));
        if (Math.abs(nextScale - oldScale) < 0.001) return;
        const rect = lbPreview.getBoundingClientRect();
        const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
        const pivotX = clamp(lastCursorX, rect.left, rect.right) - (rect.left + rect.width / 2);
        const pivotY = clamp(lastCursorY, rect.top, rect.bottom) - (rect.top + rect.height / 2);
        const ratio = nextScale / oldScale;
        lbPreviewZoomState.x = pivotX - (pivotX - lbPreviewZoomState.x) * ratio;
        lbPreviewZoomState.y = pivotY - (pivotY - lbPreviewZoomState.y) * ratio;
        lbPreviewZoomState.scale = nextScale;
        updateCompressionPreviewTransform();
    }

    function pointerXToSplitPercent(clientX) {
        if (!lbPreview) return lbCompressState.split || 50;
        const rect = lbPreview.getBoundingClientRect();
        if (!rect.width) return lbCompressState.split || 50;
        const centerX = rect.left + rect.width / 2;
        const pointerToCenter = clientX - centerX;
        const { scale = 1, x = 0 } = lbPreviewZoomState;
        const baseX = scale !== 1 || x !== 0 ? (pointerToCenter - x) / scale : pointerToCenter;
        const coord = baseX + rect.width / 2;
        const percent = (coord / rect.width) * 100;
        return Math.min(100, Math.max(0, percent));
    }

    function splitPercentToClientX(percent) {
        if (!lbPreview) return NaN;
        const rect = lbPreview.getBoundingClientRect();
        if (!rect.width) return NaN;
        const clamped = Math.min(100, Math.max(0, percent));
        const coord = (clamped / 100) * rect.width;
        const baseX = coord - rect.width / 2;
        const { scale = 1, x = 0 } = lbPreviewZoomState;
        const pointerToCenter = baseX * scale + x;
        return rect.left + rect.width / 2 + pointerToCenter;
    }

    // Reusable canvas for compression to avoid memory leaks
    let compressionCanvas = null;
    function getCompressionCanvas() {
        if (!compressionCanvas) {
            compressionCanvas = document.createElement("canvas");
        }
        return compressionCanvas;
    }
    function cleanupCompressionCanvas() {
        if (compressionCanvas) {
            const ctx = compressionCanvas.getContext("2d");
            if (ctx) {
                // Clear the canvas content
                compressionCanvas.width = 1;
                compressionCanvas.height = 1;
                ctx.clearRect(0, 0, 1, 1);
            }
        }
    }

    function resetCompressionMode() {
        resetCompressionPreviewZoom();
        
        // Clear any pending debounce timer
        if (lbPreviewDebounce) {
            clearTimeout(lbPreviewDebounce);
            lbPreviewDebounce = null;
        }
        
        // Close ImageBitmap first (must be done before nullifying)
        if (lbCompressState.baseBitmap) {
            try { lbCompressState.baseBitmap.close(); } catch (err) {}
            lbCompressState.baseBitmap = null;
        }
        
        // Release object URLs to free memory
        if (lbCompressState.sourceObjectUrl) {
            try { URL.revokeObjectURL(lbCompressState.sourceObjectUrl); } catch(e){}
            lbCompressState.sourceObjectUrl = null;
        }
        if (lbCompressState.previewObjectUrl) {
            try { URL.revokeObjectURL(lbCompressState.previewObjectUrl); } catch(e){}
            lbCompressState.previewObjectUrl = null;
        }
        
        // Release blob reference
        if (lbCompressState.compressedBlob) {
            lbCompressState.compressedBlob = null;
        }
        
        // Clear large base64 strings explicitly
        lbCompressState.base64 = null;
        lbCompressState.compressedBase64 = null;
        
        // Clear the reusable canvas
        cleanupCompressionCanvas();

        Object.assign(lbCompressState, {
            active: false,
            taskId: null,
            context: null,
            base64: null,
            sourceMime: DEFAULT_IMAGE_MIME,
            originalBytes: 0,
            originalWidth: 0,
            originalHeight: 0,
            targetWidth: 0,
            targetHeight: 0,
            resizeMode: "scale",
            scale: 100,
            customWidth: null,
            customHeight: null,
            lockAspect: true,
            quality: 95,
            split: 50,
            compressedBase64: null,
            compressedBlob: null,
            compressedBytes: 0,
            baseBitmap: null,
            sourceObjectUrl: null,
            previewObjectUrl: null,
            prompt: "",
            listId: MAIN_LIST_ID,
            refImageIds: [],
            meta: {},
            status: "",
            loading: false
        });
        
        // Clear image element sources to release memory
        if (lbPreviewBefore) {
            lbPreviewBefore.src = "";
            lbPreviewBefore.removeAttribute("src");
        }
        if (lbPreviewAfter) {
            lbPreviewAfter.src = "";
            lbPreviewAfter.removeAttribute("src");
        }
        if (lightboxTools) lightboxTools.classList.remove("active");
        if (lbPreview) {
            lbPreview.style.setProperty("--split", "50%");
            lbPreview.style.setProperty("--split-right", "50%");
        }
        if (lbStatBefore) lbStatBefore.textContent = "--";
        if (lbStatAfter) lbStatAfter.textContent = "--";
        if (lbStatSaved) lbStatSaved.textContent = "--";
        if (lbDimensionHint) lbDimensionHint.textContent = "--";
        if (lbQualityHint) lbQualityHint.textContent = "Q95";
        if (lbSizeInfo) lbSizeInfo.textContent = "";
        if (lbSourceInfo) lbSourceInfo.textContent = "";
        setCompressionStatus("Pending");
    }

    function compareOverlayVisible() {
        return !!(compareOverlay && compareOverlay.classList.contains("visible"));
    }

    function updateCompareSelectionHint() {
        if (!compareSelectHintEl) return;
        if (!compareModeState.active) {
            compareSelectHintEl.classList.remove("visible");
            return;
        }
        const stepText = compareModeState.selections.length === 0 ? "Select task card 1" : "Select task card 2";
        compareSelectHintEl.textContent = `Compare mode: ${stepText} ¬∑ Esc/E to exit`;
        compareSelectHintEl.classList.add("visible");
    }

    function clearCompareSelectionIndicators() {
        document.querySelectorAll(".result-card.compare-select-picked").forEach((card) => {
            card.classList.remove("compare-select-picked");
        });
    }

    function applyCompareSelectionIndicators() {
        if (!compareModeState.active || !resultsEl) return;
        const selectedIds = new Set(compareModeState.selections || []);
        resultsEl.querySelectorAll(".result-card").forEach((card) => {
            const taskId = card.dataset.taskId;
            if (taskId && selectedIds.has(taskId)) {
                card.classList.add("compare-select-picked");
            } else {
                card.classList.remove("compare-select-picked");
            }
        });
    }

    function enterCompareSelectionMode() {
        if (compareOverlayVisible()) return;
        if (compareModeState.active) {
            updateCompareSelectionHint();
            return;
        }
        compareModeState.active = true;
        compareModeState.selections = [];
        compareModeState.pickOrder = [];
        if (document.body) document.body.classList.add("compare-select-mode");
        clearCompareSelectionIndicators();
        updateCompareSelectionHint();
    }

    function exitCompareSelectionMode(options = {}) {
        if (!compareModeState.active) {
            if (!options.keepHint) compareSelectHintEl?.classList.remove("visible");
            return;
        }
        compareModeState.active = false;
        compareModeState.selections = [];
        compareModeState.pickOrder = [];
        if (document.body) document.body.classList.remove("compare-select-mode");
        clearCompareSelectionIndicators();
        if (!options.keepHint) compareSelectHintEl?.classList.remove("visible");
    }

    function getOrderedCompareSelectionIds(limit = 2) {
        const order = compareModeState.pickOrder.filter(id => compareModeState.selections.includes(id));
        if (order.length >= 1) {
            return limit ? order.slice(0, limit) : order.slice();
        }
        return limit ? compareModeState.selections.slice(0, limit) : compareModeState.selections.slice();
    }

    function handleCompareCardSelection(taskId, event) {
        if (!compareModeState.active || !taskId) return false;
        if (event) {
            event.preventDefault();
            event.stopPropagation();
        }
        const existingIndex = compareModeState.selections.indexOf(taskId);
        if (existingIndex !== -1) {
            compareModeState.selections.splice(existingIndex, 1);
            compareModeState.pickOrder = compareModeState.pickOrder.filter(id => id !== taskId);
            const existingCard = document.querySelector(`.result-card[data-task-id="${taskId}"]`);
            existingCard?.classList.remove("compare-select-picked");
            updateCompareSelectionHint();
            return true;
        }
        if (compareModeState.selections.length >= 2) {
            const removedId = compareModeState.selections.shift();
            compareModeState.pickOrder = compareModeState.pickOrder.filter(id => id !== removedId);
            const removedCard = document.querySelector(`.result-card[data-task-id="${removedId}"]`);
            removedCard?.classList.remove("compare-select-picked");
        }
        compareModeState.selections.push(taskId);
        compareModeState.pickOrder = compareModeState.pickOrder.filter(id => id !== taskId);
        compareModeState.pickOrder.push(taskId);
        const card = document.querySelector(`.result-card[data-task-id="${taskId}"]`);
        card?.classList.add("compare-select-picked");
        updateCompareSelectionHint();
        if (compareModeState.selections.length === 2) {
            const orderedPair = getOrderedCompareSelectionIds(2);
            const pair = orderedPair.length === 2 ? orderedPair : [...compareModeState.selections];
            setTimeout(() => openCompareOverlayForTasks(pair).catch(console.error), 60);
        }
        return true;
    }

    /* --- Edit Selection Mode Logic --- */
    function updateEditSelectionHint() {
        if (!compareSelectHintEl) return;
        if (!editSelectionModeState.active) {
            // Only clear if not in compare mode (though they should be exclusive)
            if (!compareModeState.active) compareSelectHintEl.classList.remove("visible");
            return;
        }
        compareSelectHintEl.textContent = `Edit mode: Select a task to edit ¬∑ Esc/E to exit`;
        compareSelectHintEl.classList.add("visible");
    }

    function enterEditSelectionMode() {
        if (compareOverlayVisible()) return;
        if (compareModeState.active) return;
        if (editSelectionModeState.active) {
            updateEditSelectionHint();
            return;
        }
        editSelectionModeState.active = true;
        // Reuse the compare-select-mode class for cursor/visuals
        if (document.body) document.body.classList.add("compare-select-mode");
        updateEditSelectionHint();
    }

    function exitEditSelectionMode() {
        if (!editSelectionModeState.active) return;
        editSelectionModeState.active = false;
        if (document.body) document.body.classList.remove("compare-select-mode");
        if (compareSelectHintEl) compareSelectHintEl.classList.remove("visible");
    }

    function handleEditCardSelection(taskId, event) {
        if (!editSelectionModeState.active || !taskId) return false;
        if (event) {
            event.preventDefault();
            event.stopPropagation();
        }
        
        exitEditSelectionMode();
        // Slight delay to allow UI to update
        setTimeout(() => editTaskMetadata(taskId).catch(console.error), 10);
        return true;
    }

    async function editTaskMetadata(taskId) {
        let record = resultsData.get(taskId);
        
        // Robustness: Try to fetch from DB if not in memory or incomplete
        if (!record) {
             try {
                const stored = await fetchStoredResultRecord(taskId);
                if (stored) {
                    record = rememberResultRecord(taskId, {
                        meta: stored.meta || {},
                        prompt: stored.prompt || "",
                        listId: stored.listId || MAIN_LIST_ID,
                        timestamp: stored.timestamp || Date.now(),
                        refImageIds: Array.isArray(stored.refImageIds) ? stored.refImageIds : []
                    });
                }
             } catch (err) {
                 console.warn("Failed to restore record for editing", err);
             }
        }
        
        if (!record) return;

        let previewUrl = null;
        try {
            if (record.objectUrl) {
                previewUrl = record.objectUrl;
            } else {
                // Explicitly fetch thumbnail because it's typically stripped from resultsData to save memory
                const thumbFromDb = await fetchStoredThumbnail(taskId);
                if (thumbFromDb) {
                    if (typeof thumbFromDb === 'string' && thumbFromDb.trim().startsWith("data:")) {
                        previewUrl = thumbFromDb;
                    } else {
                        previewUrl = "data:image/png;base64," + thumbFromDb;
                    }
                } else if (record.base64) {
                    const mime = record.meta?.mimeType || "image/png";
                    previewUrl = `data:${mime};base64,${record.base64}`;
                }
            }
        } catch (err) {
             console.warn("Error resolving preview image", err);
        }

        const currentMeta = record.meta || {};
        const defaults = {
            prompt: record.prompt || "",
            resolution: currentMeta.resolution || "",
            aspectRatio: currentMeta.aspectRatio || ""
        };

        try {
            const dialogResult = await openImportDialog({
                fileName: "Edit Task Metadata",
                confirmText: "Save",
                previewUrl,
                defaults
            });

            if (dialogResult) {
                record.prompt = dialogResult.prompt;
                if (!record.meta) record.meta = {};
                record.meta.resolution = dialogResult.resolution;
                record.meta.aspectRatio = dialogResult.aspectRatio;

                // Persist to DB
                await updateStoredResult(taskId, {
                    prompt: record.prompt,
                    meta: record.meta
                });

                // Persist to Disk
                await persistResultMetadataSnapshot(taskId, record);

                // Trigger UI Refresh
                renderActivePage({ reason: "metadata-update" });
            }
        } catch (err) {
            console.error("Edit metadata failed", err);
            if (importOverlayEl) {
                importOverlayEl.classList.add("hidden");
                importOverlayEl.setAttribute("aria-hidden", "true");
            }
            resetImportDialogFields();
        }
    }

    function pointerXToCompareSplit(clientX) {
        if (!compareViewEl) return compareViewState.split || 50;
        const rect = compareViewEl.getBoundingClientRect();
        if (!rect.width) return compareViewState.split || 50;
        const centerX = rect.left + rect.width / 2;
        const pointerToCenter = clientX - centerX;
        const { scale = 1, x = 0 } = compareViewState;
        const baseX = scale !== 1 || x !== 0 ? (pointerToCenter - x) / scale : pointerToCenter;
        const coord = baseX + rect.width / 2;
        const percent = (coord / rect.width) * 100;
        return Math.min(100, Math.max(0, percent));
    }

    function splitPercentToCompareClientX(percent) {
        if (!compareViewEl) return NaN;
        const rect = compareViewEl.getBoundingClientRect();
        if (!rect.width) return NaN;
        const clamped = Math.min(100, Math.max(0, percent));
        const coord = (clamped / 100) * rect.width;
        const baseX = coord - rect.width / 2;
        const { scale = 1, x = 0 } = compareViewState;
        const pointerToCenter = baseX * scale + x;
        return rect.left + rect.width / 2 + pointerToCenter;
    }

    function updateCompareSplit(percent = 50) {
        compareViewState.split = Math.min(100, Math.max(0, percent));
        compareViewEl?.style.setProperty("--split", `${compareViewState.split}%`);
    }

    function updateCompareZoomTransform() {
        if (!compareViewCanvas) return;
        const { scale, x, y } = compareViewState;
        compareViewCanvas.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
        if (!compareViewEl) return;
        if (scale !== 1 || x !== 0 || y !== 0) {
            compareViewEl.classList.add("zoomed");
        } else {
            compareViewEl.classList.remove("zoomed");
            compareViewEl.classList.remove("compare-dragging");
        }
    }

    function resetCompareZoom() {
        compareViewState.scale = 1;
        compareViewState.x = 0;
        compareViewState.y = 0;
        compareViewState.isDragging = false;
        updateCompareZoomTransform();
    }

    function adjustCompareZoom(delta) {
        if (!compareOverlayVisible()) return;
        const oldScale = compareViewState.scale || 1;
        let newScale = oldScale + delta;
        newScale = Math.min(20, Math.max(0.2, newScale));
        if (Math.abs(newScale - oldScale) < 0.001) return;
        if (!compareViewEl) return;
        const rect = compareViewEl.getBoundingClientRect();
        if (!rect.width || !rect.height) return;
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const pivotX = lastCursorX - centerX;
        const pivotY = lastCursorY - centerY;
        const ratio = newScale / oldScale;
        compareViewState.x = pivotX - (pivotX - compareViewState.x) * ratio;
        compareViewState.y = pivotY - (pivotY - compareViewState.y) * ratio;
        compareViewState.scale = newScale;
        updateCompareZoomTransform();
    }

    async function prepareCompareImagePayload(taskId) {
        if (!taskId) return null;
        const snapshot = await getResultSnapshot(taskId);
        if (!snapshot) return null;
        let meta = snapshot.meta || {};
        let base64 = await fetchFullBase64(taskId);

        // Quality check: detect if we loaded a thumbnail instead of the original
        let forceRefresh = !base64;
        if (base64) {
            try {
                const checkMime = meta.mimeType || DEFAULT_IMAGE_MIME;
                const dims = await getImageDimensionsFromBase64(base64, checkMime);
                if (dims) {
                    const isSmall = Math.max(dims.width, dims.height) <= 320;
                    const metaExpectsLarge = meta.width && meta.height && Math.max(meta.width, meta.height) > 480;
                    
                    if (isSmall && (metaExpectsLarge || meta.remoteUrl || meta.remote_url)) {
                        console.log(`[Compare] Detected low-res image for ${taskId} (${dims.width}x${dims.height}), attempting refresh...`);
                        forceRefresh = true;
                    }
                }
            } catch (e) {
                console.warn("Quality check failed", e);
            }
        }

        if (forceRefresh) {
            try {
                const hydrated = await hydrateRemoteResultForTask(taskId, { refresh: true });
                if (hydrated?.base64) {
                    base64 = hydrated.base64;
                    meta = hydrated.meta || meta;
                }
            } catch (err) {
                console.warn("Compare hydrate failed", err);
            }
        }

        if (!base64) return null;
        const mimeType = meta.mimeType || DEFAULT_IMAGE_MIME;
        return {
            taskId,
            src: `data:${mimeType};base64,${base64}`,
            meta
        };
    }

    async function openCompareOverlayForTasks(taskIds = []) {
        exitCompareSelectionMode();
        if (!Array.isArray(taskIds) || taskIds.length < 2) return;
        try {
            const [left, right] = await Promise.all(taskIds.slice(0, 2).map(id => prepareCompareImagePayload(id)));
            if (!left || !right) {
                setTemporaryErrorStatus("Unable to load comparison image.");
                compareModeState.overlayVisible = false;
                return;
            }
            if (compareImgLeft) {
                compareImgLeft.src = right.src;
                compareImgLeft.dataset.taskId = right.taskId;
            }
            if (compareImgRight) {
                compareImgRight.src = left.src;
                compareImgRight.dataset.taskId = left.taskId;
            }
            updateCompareSplit(50);
            resetCompareZoom();
            if (compareOverlay) {
                compareOverlay.classList.add("visible");
                compareOverlay.setAttribute("aria-hidden", "false");
            }
            compareModeState.overlayVisible = true;
        } catch (err) {
            console.error("Compare overlay init failed", err);
            setTemporaryErrorStatus(err?.message || "Failed to load compare mode.");
            compareModeState.overlayVisible = false;
        }
    }

    function closeCompareOverlay() {
        if (!compareOverlayVisible()) return;
        compareOverlay.classList.remove("visible");
        compareOverlay.setAttribute("aria-hidden", "true");
        compareModeState.overlayVisible = false;
        if (compareImgLeft) {
            compareImgLeft.src = "";
            delete compareImgLeft.dataset.taskId;
        }
        if (compareImgRight) {
            compareImgRight.src = "";
            delete compareImgRight.dataset.taskId;
        }
        resetCompareZoom();
    }

    function updateUpscaleInfo() {
        if (!lightboxImage || !lbUpscaleFactor) return;
        const w = lightboxImage.naturalWidth || 0;
        const h = lightboxImage.naturalHeight || 0;
        const factor = parseFloat(lbUpscaleFactor.value) || 2;
        
        if (lbUpscaleOriginSize) {
            const mp = (w * h / 1000000).toFixed(2);
            lbUpscaleOriginSize.textContent = `${w} √ó ${h} (${mp} MP)`;
        }
        
        const tw = Math.round(w * factor);
        const th = Math.round(h * factor);
        
        if (lbUpscaleTargetSize) {
             const mp = (tw * th / 1000000).toFixed(2);
             lbUpscaleTargetSize.textContent = `${tw} √ó ${th} (${mp} MP)`;
        }
        
        if (lbUpscaleCost) {
            const totalPixels = tw * th;
            const cost = (totalPixels / 1000000 * 0.001).toFixed(4);
            lbUpscaleCost.textContent = `$${cost}`;
        }
    }

    function enterUpscaleMode() {
        if (!lightbox.classList.contains("visible")) return;
        if (lbCompressState.active) resetCompressionMode();

        lbUpscaleState.active = true;
        if (lightboxUpscaleTools) lightboxUpscaleTools.classList.add("active");
        
        // Setup preview
        const currentSrc = lightboxImage.src;
        if (lbUpscalePreview) lbUpscalePreview.src = currentSrc;
        
        // Reset inputs
        if (lbUpscaleFactor) lbUpscaleFactor.value = "2";
        if (lbUpscaleNoise) lbUpscaleNoise.value = "0.1";
        if (lbUpscaleNoiseNum) lbUpscaleNoiseNum.value = "0.1";
        lbUpscaleState.factor = 2;
        
        updateUpscaleInfo();

        if (lbUpscaleSubmitBtn) lbUpscaleSubmitBtn.disabled = false;
    }

    function exitUpscaleMode() {
        lbUpscaleState.active = false;
        if (lightboxUpscaleTools) lightboxUpscaleTools.classList.remove("active");
        if (lbUpscalePreview) lbUpscalePreview.src = "";
    }

    async function submitUpscaleTask() {
        if (!lbUpscaleState.active) return;
        
        const factor = parseFloat(lbUpscaleFactor.value) || 2;
        const noiseVal = lbUpscaleNoise ? parseFloat(lbUpscaleNoise.value) : 0.1;
        const noise = isNaN(noiseVal) ? 0.1 : Math.max(0, Math.min(1, noiseVal));

        if (factor < 1 || factor > 10) {
            alert("Upscale factor must be between 1 and 10.");
            return;
        }

        const currentSrc = lightboxImage.src;
        if (!currentSrc) return;

        // 0. Grab original prompt/meta before closing everything
        let originalPrompt = "";
        let originalMeta = {};
        if (lightboxImage.dataset.taskId) {
           try {
             // Try to fetch synchronously from memory first if possible, otherwise DB
             const tid = lightboxImage.dataset.taskId;
             if (typeof resultsData !== "undefined" && resultsData.has(tid)) {
                 const m = resultsData.get(tid);
                 if (m.prompt) originalPrompt = m.prompt;
                 if (m.meta) originalMeta = m.meta;
             }
             
             // Always try DB for full record to be safe
             const db = await openDB();
             const tx = db.transaction(STORE_RESULTS, "readonly");
             const rec = await getRequestAsync(tx.objectStore(STORE_RESULTS), tid);
             if (rec) {
                 originalPrompt = rec.prompt || originalPrompt;
                 originalMeta = rec.metadata || originalMeta;
             }
           } catch(e) { console.warn("Upscale inheritance fetch failed", e); }
        }

        // Immediate UI feedback
        if (typeof setTemporaryStatus === "function") setTemporaryStatus("Upscale task added to queue...");
        
        // Exit Modes
        exitUpscaleMode(); 
        closeLightbox();

        // Create Task
        const newTaskId = `task_${Date.now()}_seedvr_upscale`;
        // Create skeleton immediately
        createSkeletonCard(newTaskId, { listId: MAIN_LIST_ID });
        updateSkeletonStatus(newTaskId, "PREPARING UPLOAD...", "QUEUED");

        // Run background task
        handleBackgroundUpscale(currentSrc, factor, newTaskId, originalPrompt, originalMeta, noise).catch(err => {
            console.error("Background upscale error:", err);
            setTemporaryErrorStatus("Upscale failed: " + err.message);
            // Optionally remove the skeleton if it failed completely
            removeTaskIndexEntry(newTaskId);
            renderActivePage({ reason: "upscale-fail" });
        });
    }

    /* --- Edit Mode Implementation --- */
    
    // Select Edit Variables
    let lbEditWrapper, lbEditContainerRef;

    async function enterEditMode() {
        if (!lightbox.classList.contains("visible")) return;
        if (lbCompressState.active) resetCompressionMode();
        if (lbUpscaleState.active) exitUpscaleMode();

        lbEditState.active = true;
        if (lightboxEditTools) lightboxEditTools.classList.add("active");
        
        lbEditWrapper = document.getElementById("lbEditWrapper");
        lbEditContainerRef = document.getElementById("lbEditContainer");

        // Load image
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
            lbEditState.img = img;
            
            // Reset State
            lbEditState.adjust = { brightness: 100, contrast: 100, saturation: 100, grayscale: 0, rotation: 0 };
            lbEditState.crop = { active: false, rect: null, dragging: null, dragStart: {x:0, y:0} };
            lbEditState.paint = { active: false, drawing: false, lastPos: null };
            lbEditState.view = { scale: 1, x: 0, y: 0, isDragging: false, dragStart: {x:0,y:0} };
            
            // Reset UI
            [lbBrightness, lbContrast, lbSaturation].forEach(el => el.value = 100);
            lbGrayscale.value = 0;
            if(lbInpaintPrompt) lbInpaintPrompt.value = "";
            lbAdjustControls.style.display = "block";
            lbInpaintControls.style.display = "none";
            lbMaskCanvas.style.display = "none";
            // lbMaskTools.style.display = "none"; // Removed from DOM
            lbCropOverlay.style.display = "none";
            
            if(lbEditStatus) lbEditStatus.innerText = "Ready";
            
            updateEditCanvas();
            updateEditViewTransform();
        };
        img.src = lightboxImage.src;
    }

    function exitEditMode() {
        lbEditState.active = false;
        if (lightboxEditTools) lightboxEditTools.classList.remove("active");
        // Hide overlays
        if (lbCropOverlay) lbCropOverlay.style.display = "none";
        if (lbMaskCanvas) lbMaskCanvas.style.display = "none";
        // if (lbMaskTools) lbMaskTools.style.display = "none";
    }

    function updateEditCanvas() {
        if (!lbEditState.img || !lbEditCanvas) return;
        
        // Sync state from DOM
        lbEditState.adjust.brightness = lbBrightness.value;
        lbEditState.adjust.contrast = lbContrast.value;
        lbEditState.adjust.saturation = lbSaturation.value;
        lbEditState.adjust.grayscale = lbGrayscale.value;

        const img = lbEditState.img;
        const rot = lbEditState.adjust.rotation % 360;
        const isVertical = (rot === 90 || rot === 270 || rot === -90 || rot === -270);
        
        // Logical dimensions (image size after rotation)
        const logicalW = isVertical ? img.height : img.width;
        const logicalH = isVertical ? img.width : img.height;
        
        // Fit within container
        const contW = lbEditContainerRef.clientWidth;
        const contH = lbEditContainerRef.clientHeight;
        const scale = Math.min(contW / logicalW, contH / logicalH);
        
        const displayW = Math.floor(logicalW * scale);
        const displayH = Math.floor(logicalH * scale);
        
        // Update Wrapper size
        lbEditWrapper.style.width = displayW + "px";
        lbEditWrapper.style.height = displayH + "px";
        
        // Set Canvas internal size to logical resolution
        lbEditCanvas.width = logicalW;
        lbEditCanvas.height = logicalH;

        // Force CSS scaling to fit wrapper
        lbEditCanvas.style.width = "100%";
        lbEditCanvas.style.height = "100%";
        
        const ctx = lbEditCanvas.getContext('2d');
        ctx.save();
        
            // Apply Filters
            ctx.filter = `brightness(${lbEditState.adjust.brightness}%) contrast(${lbEditState.adjust.contrast}%) saturate(${lbEditState.adjust.saturation}%) grayscale(${lbEditState.adjust.grayscale}%)`;
            
            // Apply Rotation
            ctx.translate(logicalW / 2, logicalH / 2);
            ctx.rotate(rot * Math.PI / 180);
            ctx.drawImage(img, -img.width / 2, -img.height / 2);
            
            ctx.restore();

            // *** IMPORTANT: The filter property is part of the state, but `toDataURL` usually ignores it on some browsers if not baked in properly. 
            // However, drawImage respects it. But for the FINAL output, we create a new canvas. 
            // The `saveEditResult` function uses `ctx.drawImage(srcCanvas, ...)` so it copies the PIXELS of the source canvas.
            // If the source canvas has the filter applied actively, the pixel data in `toDataURL` might NOT contain the filter if it's just a view filter (CSS).
            // BUT wait, we are using `lbEditCanvas.getContext('2d').filter = ...`. This IS a canvas filter.
            // So drawImage applies it to the context. It should be baked into the canvas PIXELS.
            // The issue might be that we need to wait for the filter to apply? No, it's synchronous.
            // Wait, for `saveEditResult`, we create a NEW canvas and draw `srcCanvas` onto it. 
            // Does `drawImage(canvas, ...)` draw the filtered state? Yes, it *should*.
            
            lbEditState.scale = scale;
        
        // Re-scale mask if it exists? 
        // For simplicity, we clear mask on geometry change to avoid misalignment
        if (lbMaskCanvas.width !== logicalW || lbMaskCanvas.height !== logicalH) {
             lbMaskCanvas.width = logicalW;
             lbMaskCanvas.height = logicalH;
             // clear mask context
             const mCtx = lbMaskCanvas.getContext('2d');
             mCtx.clearRect(0, 0, logicalW, logicalH);
        }
        
        // Update Crop UI if active
        if (lbEditState.crop.active) updateCropUI();
    }

    [lbBrightness, lbContrast, lbSaturation, lbGrayscale].forEach(el => {
        el.addEventListener('input', updateEditCanvas);
    });

    const lbAdjustResetBtn = document.getElementById("lbAdjustResetBtn");
    if (lbAdjustResetBtn) {
        lbAdjustResetBtn.addEventListener('click', () => {
            if(!lbEditState.active) return;
            lbBrightness.value = 100;
            lbContrast.value = 100;
            lbSaturation.value = 100;
            lbGrayscale.value = 0;
            updateEditCanvas();
        });
    }

    // View / Zoom / Pan Logic
    function updateEditViewTransform() {
        if (!lbEditWrapper) return;
        const { scale, x, y } = lbEditState.view;
        lbEditWrapper.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
    }

    function adjustEditZoom(delta) {
        if (!lbEditState.active) return;
        const oldScale = lbEditState.view.scale;
        let newScale = oldScale + delta;
        newScale = Math.min(20, Math.max(0.1, newScale));
        
        if (Math.abs(newScale - oldScale) < 0.001) return;
        
        const rect = document.getElementById("lbEditContainer").getBoundingClientRect();
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        
        // Use global cursor track if available
        const relX = lastCursorX - rect.left;
        const relY = lastCursorY - rect.top;
        const useMouse = (relX >= 0 && relX <= rect.width && relY >= 0 && relY <= rect.height);
        
        const pivotX = useMouse ? relX - centerX : 0;
        const pivotY = useMouse ? relY - centerY : 0;
        
        const ratio = newScale / oldScale;
        
        lbEditState.view.x = pivotX - (pivotX - lbEditState.view.x) * ratio;
        lbEditState.view.y = pivotY - (pivotY - lbEditState.view.y) * ratio;
        lbEditState.view.scale = newScale;
        
        updateEditViewTransform();
    }

    function resetEditZoom() {
        if (!lbEditState.active) return;
        lbEditState.view.scale = 1;
        lbEditState.view.x = 0;
        lbEditState.view.y = 0;
        updateEditViewTransform();
    }

    const lbEditContainerEl = document.getElementById("lbEditContainer");
    if (lbEditContainerEl) {
        lbEditContainerEl.addEventListener("wheel", (e) => {
            if (!lbEditState.active) return;
            // Disable wheel zoom in Paint Mode to prevent accidental zooming while drawing
            // User can still use Z/X/C keys
            if (lbEditState.paint.active) return;
            
            e.preventDefault();
            e.stopPropagation(); 
            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            adjustEditZoom(delta);
        }, { passive: false });

        lbEditContainerEl.addEventListener("click", (e) => {
            if (!lbEditState.active) return;
            e.stopPropagation();
            
            // Disable click-to-zoom in Paint Mode
            if (lbEditState.paint.active) return;

            if (lbEditState.view.hasMoved) return; // Ignore if it was a drag

            // Check if tool handles or specific canvases are target to avoid zoom on interactions
            const target = e.target;
            const isCropHandle = target.classList.contains('crop-handle');
            const isCropOverlay = (target.id === 'lbCropOverlay' || target.closest('#lbCropOverlay'));
            const isPaint = (lbEditState.paint.active && target.id === 'lbMaskCanvas');
            if (isCropHandle || (lbEditState.crop.active && isCropOverlay) || isPaint) return;

            // Toggle Zoom
            if (lbEditState.view.scale === 1) {
                 // Zoom In to 2.5x
                  const rect = lbEditContainerEl.getBoundingClientRect();
                  const centerX = rect.width / 2;
                  const centerY = rect.height / 2;
                  const relX = e.clientX - rect.left;
                  const relY = e.clientY - rect.top;
                  const pivotX = relX - centerX;
                  const pivotY = relY - centerY;
                  
                  const targetScale = 2.5;
                  const ratio = targetScale / 1;
                  
                  lbEditState.view.x = pivotX - (pivotX - 0) * ratio;
                  lbEditState.view.y = pivotY - (pivotY - 0) * ratio;
                  lbEditState.view.scale = targetScale;
            } else {
                 resetEditZoom();
            }
            updateEditViewTransform();
        });

        lbEditContainerEl.addEventListener("mousedown", (e) => {
            if (!lbEditState.active) return;
            e.stopPropagation();
            // Check if tool handles or specific canvases are target
            const target = e.target;
            const isCropHandle = target.classList.contains('crop-handle');
            // Check if clicking existing crop overlay (to move it)
            const isCropOverlay = (target.id === 'lbCropOverlay' || target.closest('#lbCropOverlay'));
            // Check if clicking mask canvas in paint mode
            const isPaint = (lbEditState.paint.active && target.id === 'lbMaskCanvas');

            // If we are on a control/tool, don't pan
            if (isCropHandle || (lbEditState.crop.active && isCropOverlay) || isPaint) return;
            
            // Start Pan
            lbEditState.view.isDragging = true;
            lbEditState.view.hasMoved = false;
            lbEditState.view.dragStart = { x: e.clientX, y: e.clientY };
            lbEditState.view.initialX = lbEditState.view.x;
            lbEditState.view.initialY = lbEditState.view.y;
            e.preventDefault();
        });

        window.addEventListener("mousemove", (e) => {
            if (lbEditState.view && lbEditState.view.isDragging) {
                const dx = e.clientX - lbEditState.view.dragStart.x;
                const dy = e.clientY - lbEditState.view.dragStart.y;
                
                if (Math.abs(dx) > 3 || Math.abs(dy) > 3) lbEditState.view.hasMoved = true;
                
                lbEditState.view.x = lbEditState.view.initialX + dx;
                lbEditState.view.y = lbEditState.view.initialY + dy;
                updateEditViewTransform();
            }
        });

        window.addEventListener("mouseup", () => {
             if (lbEditState.view) {
                 lbEditState.view.isDragging = false;
                 // Don't clear hasMoved here, we need it for click
             }
        });
    }
    
    lbRotateBtn.addEventListener('click', () => {
        lbEditState.adjust.rotation += 90;
        updateEditCanvas();
        if (lbEditState.crop.active) toggleCropMode(); 
        if (lbEditState.paint.active) {
            const mCtx = lbMaskCanvas.getContext('2d');
            mCtx.clearRect(0,0,lbMaskCanvas.width, lbMaskCanvas.height);
        }
    });

    if (lbUpscaleNoise && lbUpscaleNoiseNum) {
        lbUpscaleNoise.addEventListener('input', () => lbUpscaleNoiseNum.value = lbUpscaleNoise.value);
        lbUpscaleNoiseNum.addEventListener('input', () => lbUpscaleNoise.value = lbUpscaleNoiseNum.value);
    }

    lbCropToggleBtn.addEventListener('click', toggleCropMode);
    lbPaintToggleBtn.addEventListener('click', togglePaintMode);
    lbEditExitBtn.addEventListener('click', exitEditMode);
    lbEditSaveNewBtn.addEventListener('click', () => saveEditResult(false));
    lbEditSaveReplaceBtn.addEventListener('click', (e) => {
        // Checking for Cmd key bypass happens inside saveEditResult logic or here
        // The user requirement: "click needs confirmation, but hold cmd click overwrite without confirmation"
        const noConfirm = (e.metaKey || e.ctrlKey);
        saveEditResult(true, noConfirm);
    });
    lbClearMaskBtn.addEventListener('click', () => {
        const mCtx = lbMaskCanvas.getContext('2d');
        mCtx.clearRect(0,0,lbMaskCanvas.width, lbMaskCanvas.height);
    });
    
    // Inpaint submit button
    if (lbInpaintSubmitBtn) {
        lbInpaintSubmitBtn.addEventListener('click', () => {
             saveEditResult(false);
        });
    }

    function toggleCropMode() {
        if (!lbEditState.active) return;
        lbEditState.crop.active = !lbEditState.crop.active;
        if (lbEditState.paint.active && lbEditState.crop.active) togglePaintMode(); 
        
        if (lbEditState.crop.active) {
            lbCropOverlay.style.display = "block";
            lbEditState.crop.rect = { x: 0, y: 0, w: lbEditCanvas.width, h: lbEditCanvas.height };
            updateCropUI();
        } else {
            lbCropOverlay.style.display = "none";
        }
    }
    
    function updateCropUI() {
        if (!lbEditState.crop.active) return;
        const rect = lbEditState.crop.rect;
        const scale = lbEditState.scale || 1; 
        
        lbCropOverlay.style.left = (rect.x * scale) + "px";
        lbCropOverlay.style.top = (rect.y * scale) + "px";
        lbCropOverlay.style.width = (rect.w * scale) + "px";
        lbCropOverlay.style.height = (rect.h * scale) + "px";
    }
    
    function togglePaintMode() {
        if (!lbEditState.active) return;
        lbEditState.paint.active = !lbEditState.paint.active;
        if (lbEditState.crop.active && lbEditState.paint.active) toggleCropMode();
        
        if (lbEditState.paint.active) {
            lbMaskCanvas.style.display = "block";
            // lbMaskTools.style.display = "flex"; // Moved to sidebar
            lbAdjustControls.style.display = "none";
            lbInpaintControls.style.display = "block";
            updateInpaintCost(); // Calculate cost
        } else {
            lbMaskCanvas.style.display = "none";
            // lbMaskTools.style.display = "none";
            lbAdjustControls.style.display = "block";
            lbInpaintControls.style.display = "none";
        }
    }

    function updateInpaintCost() {
        const costEl = document.getElementById("lbInpaintCost");
        const resEl = document.getElementById("lbInpaintRes");
        if (!costEl || !lbEditCanvas) return;
        
        // Calculate based on physical resolution being edited
        const w = lbEditCanvas.width;
        const h = lbEditCanvas.height;
        const pixels = w * h;
        const mp = pixels / 1000000;
        const cost = mp * 0.05; // $0.05 per MP
        
        if (resEl) resEl.textContent = `${w} √ó ${h} (${mp.toFixed(2)} MP)`;
        costEl.textContent = `$${cost.toFixed(4)}`; 
    }

    lbCropOverlay.addEventListener('mousedown', startCropDrag);
    
    function startCropDrag(e) {
        if (!lbEditState.crop.active) return;
        e.preventDefault();
        e.stopPropagation();
        
        const handle = e.target.getAttribute('data-dir');
        // Allow dragging if target is the overlay OR any child that isn't a handle (though handles are covered above)
        // Check if the click is within the overlay box
        if (e.target === lbCropOverlay || e.target.closest('#lbCropOverlay')) {
             if (handle) {
                 lbEditState.crop.dragging = handle;
             } else {
                 lbEditState.crop.dragging = 'move';
             }
        } else {
             return; 
        }
        
        lbEditState.crop.dragStart = { x: e.clientX, y: e.clientY };
        lbEditState.crop.startRect = { ...lbEditState.crop.rect };
        
        window.addEventListener('mousemove', handleCropMove);
        window.addEventListener('mouseup', endCropDrag);
    }
    
    function handleCropMove(e) {
        if (!lbEditState.crop.dragging) return;
        
        const viewScale = lbEditState.view ? (lbEditState.view.scale || 1) : 1;
        const logicalScale = lbEditState.scale || 1;
        const totalScale = viewScale * logicalScale;

        const dx = (e.clientX - lbEditState.crop.dragStart.x) / totalScale;
        const dy = (e.clientY - lbEditState.crop.dragStart.y) / totalScale;
        
        const rect = { ...lbEditState.crop.startRect };
        const mode = lbEditState.crop.dragging;
        const limitW = lbEditCanvas.width;
        const limitH = lbEditCanvas.height;
        
        if (mode === 'move') {
            rect.x += dx;
            rect.y += dy;
        } else {
            if (mode.includes('w')) { rect.x += dx; rect.w -= dx; }
            if (mode.includes('n')) { rect.y += dy; rect.h -= dy; }
            if (mode.includes('e')) { rect.w += dx; }
            if (mode.includes('s')) { rect.h += dy; }
        }
        
        // Constraints
        if (rect.w < 50) rect.w = 50;
        if (rect.h < 50) rect.h = 50;
        if (rect.x < 0) rect.x = 0;
        if (rect.y < 0) rect.y = 0;
        if (rect.x + rect.w > limitW) {
             if (mode === 'move') rect.x = limitW - rect.w;
             else rect.w = limitW - rect.x;
        }
        if (rect.y + rect.h > limitH) {
             if (mode === 'move') rect.y = limitH - rect.h;
             else rect.h = limitH - rect.y;
        }
        
        lbEditState.crop.rect = rect;
        updateCropUI();
    }
    
    function endCropDrag() {
        window.removeEventListener('mousemove', handleCropMove);
        window.removeEventListener('mouseup', endCropDrag);
        lbEditState.crop.dragging = null;
    }

    lbMaskCanvas.addEventListener('mousedown', startPaint);
    
    function startPaint(e) {
        if (!lbEditState.paint.active) return;
        lbEditState.paint.drawing = true;
        const rect = lbMaskCanvas.getBoundingClientRect();
        
        const ratioX = lbMaskCanvas.width / rect.width;
        const ratioY = lbMaskCanvas.height / rect.height;
        
        const x = (e.clientX - rect.left) * ratioX;
        const y = (e.clientY - rect.top) * ratioY;
        
        const ctx = lbMaskCanvas.getContext('2d');
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.lineWidth = parseInt(lbBrushSize.value);
        ctx.globalCompositeOperation = "source-over"; 
        ctx.strokeStyle = "rgba(255, 255, 255, 1)";
        
        ctx.beginPath();
        ctx.moveTo(x, y);
        lbEditState.paint.lastPos = {x, y};
        
        window.addEventListener('mousemove', handlePaintMove);
        window.addEventListener('mouseup', endPaint);
    }
    
    function handlePaintMove(e) {
        if (!lbEditState.paint.drawing) return;
        const rect = lbMaskCanvas.getBoundingClientRect();
        
        const ratioX = lbMaskCanvas.width / rect.width;
        const ratioY = lbMaskCanvas.height / rect.height;
        
        const x = (e.clientX - rect.left) * ratioX;
        const y = (e.clientY - rect.top) * ratioY;
        
        const ctx = lbMaskCanvas.getContext('2d');
        ctx.lineWidth = parseInt(lbBrushSize.value);
        ctx.lineTo(x, y);
        ctx.stroke();
        lbEditState.paint.lastPos = {x, y};
    }
    
    function endPaint() {
        lbEditState.paint.drawing = false;
        window.removeEventListener('mousemove', handlePaintMove);
        window.removeEventListener('mouseup', endPaint);
    }

    async function saveEditResult(isReplace, noConfirm = false) {
        if (!lbEditState.active) return;
        
        if (lbEditState.paint.active) {
            await submitInpaintTask(); // Always new card
        } else {
             if (isReplace && !noConfirm) {
                 if (!confirm("Overwrite original image? Cannot be undone.")) return;
             }
            await submitLocalEdit(isReplace);
        }
    }

    async function submitLocalEdit(isReplace) {
        if(lbEditSaveNewBtn) lbEditSaveNewBtn.disabled = true;
        if(lbEditSaveReplaceBtn) lbEditSaveReplaceBtn.disabled = true;
        lbEditStatus.innerText = "Saving...";

        try {
            const canvas = document.createElement('canvas');
            const srcCanvas = lbEditCanvas;
            
            let targetX = 0, targetY = 0, targetW = srcCanvas.width, targetH = srcCanvas.height;
            if (lbEditState.crop.active && lbEditState.crop.rect) {
                targetX = lbEditState.crop.rect.x;
                targetY = lbEditState.crop.rect.y;
                targetW = lbEditState.crop.rect.w;
                targetH = lbEditState.crop.rect.h;
            }
            
            canvas.width = targetW;
            canvas.height = targetH;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(srcCanvas, targetX, targetY, targetW, targetH, 0, 0, targetW, targetH);
            
            const resultBase64 = canvas.toDataURL("image/jpeg", 0.95);
            const base64Content = resultBase64.split(",")[1];
            
            const taskId = isReplace ? lightboxImage.dataset.taskId : `task_${Date.now()}_edit`;
            let originalPrompt = "Edited Image";
            let originalMeta = {};
            
            if (lightboxImage.dataset.taskId) {
               try {
                 const tid = lightboxImage.dataset.taskId;
                 // Try memory first
                 if (typeof resultsData !== "undefined" && resultsData.has(tid)) {
                    const m = resultsData.get(tid);
                    if (m.prompt) originalPrompt = m.prompt;
                    if (m.meta) originalMeta = m.meta;
                 }
                 
                 const db = await openDB();
                 const tx = db.transaction(STORE_RESULTS, "readonly");
                 const rec = await getRequestAsync(tx.objectStore(STORE_RESULTS), tid);
                 if (rec) {
                     originalPrompt = rec.prompt || originalPrompt;
                     originalMeta = rec.metadata || originalMeta;
                 }
               } catch(e) {}
            }
            
            const meta = {
                ...originalMeta,
                width: canvas.width,
                height: canvas.height,
                type: "edit",
                timestamp: Date.now()
            };
            
            await renderImageCard(taskId, base64Content, meta, originalPrompt, { listId: MAIN_LIST_ID });
            
            if (isReplace) {
                 lightboxImage.src = resultBase64;
                 setTemporaryStatus("Image overwritten successfully");
                 exitEditMode();
            } else {
                 setTemporaryStatus("New image card created");
                 
                 // If addToCurrentList is not available (some versions), use manual refresh
                 if (typeof addToCurrentList === 'function') {
                    addToCurrentList(taskId);
                 } else if (typeof ensureTaskInOrder === 'function') {
                    ensureTaskInOrder(taskId, "start");
                 }
                 
                 // Try refreshing the view
                 if (typeof renderActivePage === 'function') renderActivePage(); 
                 
                 exitEditMode();
            }
        } catch (e) {
            console.error(e);
            alert("Save failed: " + e.message);
        } finally {
            if(lbEditSaveNewBtn) lbEditSaveNewBtn.disabled = false;
            if(lbEditSaveReplaceBtn) lbEditSaveReplaceBtn.disabled = false;
            lbEditStatus.innerText = "Ready";
        }
    }
    
    async function submitInpaintTask() {
         const prompt = lbInpaintPrompt.value;
         if (!prompt) {
             alert("Please enter a prompt for inpainting.");
             return;
         }
         
         // 1. Get Data Immediately
         const baseCanvas = lbEditCanvas; 
         const base64Image = baseCanvas.toDataURL("image/jpeg", 0.95);
         
         const finalMaskCanvas = document.createElement('canvas');
         finalMaskCanvas.width = baseCanvas.width;
         finalMaskCanvas.height = baseCanvas.height;
         const fCtx = finalMaskCanvas.getContext('2d');
         fCtx.fillStyle = "black";
         fCtx.fillRect(0,0, finalMaskCanvas.width, finalMaskCanvas.height);
         fCtx.drawImage(lbMaskCanvas, 0, 0);
         const base64Mask = finalMaskCanvas.toDataURL("image/png");
         
         const width = baseCanvas.width;
         const height = baseCanvas.height;

         // 2. Prepare Task UI Immediately
         const newTaskId = `task_${Date.now()}_inpaint`;
         
         // Create Skeleton
         createSkeletonCard(newTaskId, { listId: MAIN_LIST_ID });
         updateSkeletonStatus(newTaskId, "INITIALIZING...", "QUEUED");

         if (typeof setTemporaryStatus === "function") setTemporaryStatus("Inpaint task started...");

         // 3. Exit Editor
         exitEditMode();
         closeLightbox();

         // 4. Run Background Process
         handleBackgroundInpaint(newTaskId, prompt, base64Image, base64Mask, width, height)
            .catch(err => {
                console.error("Inpaint Background Error:", err);
                // Optionally mark skeleton as failed or remove it
                const card = document.querySelector(`.result-card[data-task-id="${newTaskId}"]`);
                if (card) {
                    card.classList.add("error");
                    const status = card.querySelector(".status-text");
                    if (status) status.textContent = "FAILED";
                    setTimeout(() => {
                        removeTaskIndexEntry(newTaskId);
                        card.remove();
                    }, 5000);
                }
                alert("Inpaint failed: " + err.message);
            });
    }

    async function handleBackgroundInpaint(taskId, prompt, base64Image, base64Mask, width, height) {
        try {
            updateSkeletonStatus(taskId, "UPLOADING...", "RUNNING");

            const apiKey = apiKeyManagers.fal.getNextKey();
            if (!apiKey) throw new Error("Missing Fal API Key.");

            const endpoint = "https://fal.run/fal-ai/flux-pro/v1/fill";
            const payload = {
                prompt: prompt,
                image_url: base64Image,
                mask_url: base64Mask,
                sync_mode: true,
                num_images: 1,
                output_format: "jpeg",
                enable_safety_checker: false,
                safety_tolerance: 6
            };
            
            updateSkeletonStatus(taskId, "PROCESSING...", "AI BUSY");

            const resp = await fetch(endpoint, {
                method: "POST",
                headers: {
                    "Authorization": `Key ${apiKey}`,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(payload)
            });
            
            if (!resp.ok) throw new Error("API Error: " + resp.statusText);
            
            updateSkeletonStatus(taskId, "DOWNLOADING...", "SAVING");
            
            const data = await resp.json();
            
             if (data.images && data.images.length > 0) {
                 const resultUrl = data.images[0].url;
                 const rImgResp = await fetch(resultUrl);
                 const rBlob = await rImgResp.blob();
                 const rBase64 = await blobToBase64Async(rBlob);
                 
                 // Replace skeleton with real card
                 await renderImageCard(taskId, rBase64, {
                     type: "inpaint", source: "fal-flux", width: width, height: height, timestamp: Date.now()
                 }, prompt, { listId: MAIN_LIST_ID });
                 
                 // Logic to ensure order is handled by renderImageCard implicitly or we ensure it here
                 // Since we already created skeleton, renderImageCard will replace it in place if logic supports it
                 // But wait, renderImageCard normally creates a new element. We need to check if it handles updates.
                 // Actually, createSkeletonCard creates a card with ID. renderImageCard will try to create one.
                 // If ID exists, we should replace it.
                 // Let's verify renderImageCard logic. Assuming standard behavior: it usually replaces or appends.
                 // Optimization: let's trust renderImageCard to handle it or we swap manually.
                 // Actually, if renderImageCard creates a new one, we might have duplicate.
                 // But `renderImageCard` usually checks `document.getElementById`? 
                 // Let's assume the previous logic for upscale worked similarly.
                 // Wait, upscale logic (handleBackgroundUpscale) calls renderImageCard too.
                 // So it should be fine.
                 
                 if (typeof setTemporaryStatus === "function") setTemporaryStatus("Inpaint finished!");

             } else {
                 throw new Error("No image returned");
             }
        } catch (err) {
            throw err;
        }
    }


    async function handleBackgroundUpscale(imageUrl, factor, taskId, originalPrompt = "", originalMeta = {}, noise = 0.1) {
        try {
            updateSkeletonStatus(taskId, "PROCESSING IMAGE...", "RUNNING");
            
            // 1. Prepare Base64
            let base64Data = "";
            let mimeType = "image/png";

            if (imageUrl.startsWith("data:")) {
                const parts = imageUrl.split(",");
                base64Data = parts[1];
                const mimeMatch = parts[0].match(/:(.*?);/);
                if (mimeMatch) mimeType = mimeMatch[1];
            } else {
                 const resp = await fetch(imageUrl);
                 const blob = await resp.blob();
                 base64Data = await blobToBase64Async(blob);
                 mimeType = blob.type;
            }
            const fullDataUrl = `data:${mimeType};base64,${base64Data}`;

            updateSkeletonStatus(taskId, "SENDING TO CLOUD...", "UPSCALE");

            // 2. Prepare Payload
            const payload = {
                image_url: fullDataUrl,
                upscale_mode: "factor",
                upscale_factor: factor,
                noise_scale: noise,
                seed: Math.floor(Math.random() * 10000000),
                sync_mode: true
            };

            // 3. Get Key
            const apiKey = apiKeyManagers.fal.getNextKey();
            if (!apiKey) throw new Error("Missing Fal API Key settings.");

            const endpoint = "https://fal.run/fal-ai/seedvr/upscale/image";

            // 4. Send Request
            const resp = await fetch(endpoint, {
                method: "POST",
                headers: {
                    "Authorization": `Key ${apiKey}`,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(payload)
            });

            if (!resp.ok) {
                const errText = await resp.text();
                throw new Error(`API Error: ${resp.status} - ${errText}`);
            }

            updateSkeletonStatus(taskId, "DOWNLOADING RESULT...", "SAVING");

            const result = await resp.json();
            
            // 5. Parse Result (New Scheme)
            // { "image": { "url": "data:...", "width":..., "height":... }, "seed": ... }
            let resultDataUrl = "";
            let width = 0;
            let height = 0;

            if (result.image && result.image.url) {
                resultDataUrl = result.image.url;
                width = result.image.width || 0;
                height = result.image.height || 0;
            } else if (result.images && result.images.length > 0) {
                 // Fallback for previous assumption just in case
                 resultDataUrl = result.images[0].url;
                 width = result.images[0].width || 0;
                 height = result.images[0].height || 0;
            } else {
                throw new Error("Invalid response format: No image found.");
            }

            // 6. Convert result to card
            let finalBase64 = "";
            let finalMime = "image/png";

            if (resultDataUrl.startsWith("data:")) {
                const parts = resultDataUrl.split(",");
                finalBase64 = parts[1];
                const mimeMatch = parts[0].match(/:(.*?);/);
                if (mimeMatch) finalMime = mimeMatch[1];
            } else {
                const imgResp = await fetch(resultDataUrl);
                const imgBlob = await imgResp.blob();
                finalBase64 = await blobToBase64Async(imgBlob);
                finalMime = imgBlob.type;
            }

            // Re-use same taskId to replace skeleton
            const prompt = originalPrompt || `Upscale x${factor} (Noise: ${noise}, Seed: ${result.seed || "random"})`;
            const meta = {
                ...originalMeta,
                provider: "fal-seedvr",
                endpoint: "upscale",
                upscaleFactor: factor,
                noiseScale: noise,
                mimeType: finalMime,
                width: width,
                height: height,
                timestamp: Date.now(),
                seed: result.seed
            };

            await renderImageCard(taskId, finalBase64, meta, prompt, {
                listId: MAIN_LIST_ID
            });
            
            if (typeof setTemporaryStatus === "function") {
                setTemporaryStatus("Upscale result saved!");
            }

        } catch (err) {
            console.error("Upscale Worker Error:", err);
            throw err; // Propagate to let caller show error
        }
    }

    function updatePreviewSplit(percent = lbCompressState.split || 50) {
        const clamped = Math.min(95, Math.max(5, percent));
        lbCompressState.split = clamped;
        if (lbPreview) {
            lbPreview.style.setProperty("--split", `${clamped}%`);
            lbPreview.style.setProperty("--split-right", `${100 - clamped}%`);
        }
    }

    function updateCompressionUi() {
        const useScale = lbCompressState.resizeMode !== "custom";
        if (lbResizeMode) lbResizeMode.value = lbCompressState.resizeMode;
        if (lbScaleRow) lbScaleRow.style.display = useScale ? "" : "none";
        if (lbCustomRow) lbCustomRow.style.display = useScale ? "none" : "";
        if (lbScaleInput) lbScaleInput.value = lbCompressState.scale;
        if (lbScaleNumber) lbScaleNumber.value = lbCompressState.scale;
        if (lbCustomWidth && lbCompressState.customWidth) lbCustomWidth.value = lbCompressState.customWidth;
        if (lbCustomHeight && lbCompressState.customHeight) lbCustomHeight.value = lbCompressState.customHeight;
        if (lbLockAspect) lbLockAspect.checked = lbCompressState.lockAspect;
        if (lbQualityInput) lbQualityInput.value = lbCompressState.quality;
        if (lbQualityNumber) lbQualityNumber.value = lbCompressState.quality;
        if (lbDimensionHint) lbDimensionHint.textContent = `${lbCompressState.targetWidth || lbCompressState.originalWidth || "--"}√ó${lbCompressState.targetHeight || lbCompressState.originalHeight || "--"}`;
        if (lbQualityHint) lbQualityHint.textContent = `Q${lbCompressState.quality}`;
    }

    function updateCompressionStats() {
        if (lbStatBefore) lbStatBefore.textContent = `${lbCompressState.originalWidth}√ó${lbCompressState.originalHeight} ‚Ä¢ ${formatBytesShort(lbCompressState.originalBytes)}`;
        if (lbStatAfter) lbStatAfter.textContent = lbCompressState.compressedBytes
            ? `${lbCompressState.targetWidth}√ó${lbCompressState.targetHeight} ‚Ä¢ ${formatBytesShort(lbCompressState.compressedBytes)}`
            : "--";
        if (lbStatSaved) {
            const saved = Math.max(0, lbCompressState.originalBytes - lbCompressState.compressedBytes);
            const percent = lbCompressState.originalBytes ? Math.round((saved / lbCompressState.originalBytes) * 100) : 0;
            lbStatSaved.textContent = lbCompressState.compressedBytes ? `${formatBytesShort(saved)} (${percent}%)` : "--";
        }
        if (lbSizeInfo) lbSizeInfo.textContent = `${lbCompressState.originalWidth}√ó${lbCompressState.originalHeight} / ${formatBytesShort(lbCompressState.originalBytes)}`;
    }

    function scheduleCompressionPreview() {
        if (lbPreviewDebounce) clearTimeout(lbPreviewDebounce);
        lbPreviewDebounce = setTimeout(() => {
            buildCompressionPreview().catch(console.error);
        }, 120);
    }

    async function ensureBaseBitmap() {
        if (lbCompressState.baseBitmap) return lbCompressState.baseBitmap;
        if (!lbCompressState.base64) return null;
        try {
            const blob = base64ToBlob(lbCompressState.base64, lbCompressState.sourceMime || DEFAULT_IMAGE_MIME);
            // Create source object URL for efficient display
            if (!lbCompressState.sourceObjectUrl) {
                lbCompressState.sourceObjectUrl = URL.createObjectURL(blob);
            }
            lbCompressState.baseBitmap = await createImageBitmap(blob);
            lbCompressState.originalWidth = lbCompressState.baseBitmap.width;
            lbCompressState.originalHeight = lbCompressState.baseBitmap.height;
            return lbCompressState.baseBitmap;
        } catch (err) {
            console.warn("Bitmap decode failed", err);
            return null;
        }
    }

    function resolveTargetSize() {
        if (lbCompressState.resizeMode === "custom") {
            const w = Math.max(16, Math.round(lbCompressState.customWidth || lbCompressState.originalWidth || 0));
            const h = Math.max(16, Math.round(lbCompressState.customHeight || lbCompressState.originalHeight || 0));
            return { width: w, height: h };
        }
        const scale = Math.max(10, Math.min(400, Number(lbCompressState.scale) || 100));
        const baseW = lbCompressState.originalWidth || 0;
        const baseH = lbCompressState.originalHeight || 0;
        return {
            width: Math.max(16, Math.round((baseW * scale) / 100)),
            height: Math.max(16, Math.round((baseH * scale) / 100))
        };
    }

    function syncCustomSizeFromInput(source = "width") {
        const origW = lbCompressState.originalWidth || 1;
        const origH = lbCompressState.originalHeight || 1;
        let w = Math.max(16, Math.round(Number(lbCustomWidth?.value || origW)) || origW);
        let h = Math.max(16, Math.round(Number(lbCustomHeight?.value || origH)) || origH);
        if (lbCompressState.lockAspect) {
            if (source === "width") {
                h = Math.max(16, Math.round((w / origW) * origH));
                if (lbCustomHeight) lbCustomHeight.value = h;
            } else {
                w = Math.max(16, Math.round((h / origH) * origW));
                if (lbCustomWidth) lbCustomWidth.value = w;
            }
        }
        lbCompressState.customWidth = w;
        lbCompressState.customHeight = h;
        lbCompressState.targetWidth = w;
        lbCompressState.targetHeight = h;
        updateCompressionUi();
    }

    async function buildCompressionPreview() {
        if (!lbCompressState.active) return;
        if (lbCompressState.loading) return;
        lbCompressState.loading = true;
        if (lbSaveCompressedBtn) lbSaveCompressedBtn.disabled = true;
        setCompressionStatus("Generating preview...");
        const bitmap = await ensureBaseBitmap();
        if (!bitmap) {
            lbCompressState.loading = false;
            if (lbSaveCompressedBtn) lbSaveCompressedBtn.disabled = false;
            setCompressionStatus("Preview failed");
            setTemporaryErrorStatus("Unable to load image data.");
            return;
        }
        const { width, height } = resolveTargetSize();
        lbCompressState.targetWidth = width;
        lbCompressState.targetHeight = height;
        const canvas = getCompressionCanvas();
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        // Clear previous content
        ctx.clearRect(0, 0, width, height);
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";
        ctx.drawImage(bitmap, 0, 0, width, height);
        const q = Math.min(1, Math.max(0.1, lbCompressState.quality / 100));

        // Use Blob and ObjectURL for Preview to save memory (avoid huge base64 strings)
        try {
            const blob = await new Promise(resolve => canvas.toBlob(resolve, "image/jpeg", q));
            if (!blob) throw new Error("Canvas blob creation failed");
            
            if (lbCompressState.previewObjectUrl) {
                URL.revokeObjectURL(lbCompressState.previewObjectUrl);
            }
            lbCompressState.compressedBlob = blob;
            lbCompressState.compressedBytes = blob.size;
            lbCompressState.previewObjectUrl = URL.createObjectURL(blob);
            
            // Mark base64 as null, generate on demand only
            lbCompressState.compressedBase64 = null; 
            
            if (lbPreviewAfter) lbPreviewAfter.src = lbCompressState.previewObjectUrl;
        } catch (err) {
            console.warn("Blob preview failed, falling back to dataURL", err);
            const dataUrl = canvas.toDataURL("image/jpeg", q);
            lbCompressState.compressedBase64 = dataUrl.split(",")[1] || null;
            lbCompressState.compressedBytes = estimateBase64Bytes(lbCompressState.compressedBase64);
            if (lbPreviewAfter) lbPreviewAfter.src = dataUrl;
        }

        if (lbPreviewBefore && lbCompressState.sourceObjectUrl) {
             lbPreviewBefore.src = lbCompressState.sourceObjectUrl;
        } else if (lbPreviewBefore) {
             lbPreviewBefore.src = `data:${lbCompressState.sourceMime};base64,${lbCompressState.base64}`;
        }
        
        updateCompressionUi();
        updateCompressionStats();
        setCompressionStatus("Preview updated");
        lbCompressState.loading = false;
        if (lbSaveCompressedBtn) lbSaveCompressedBtn.disabled = false;
    }

    async function saveCompressedAsNewCard() {
        if (!lbCompressState.active || (!lbCompressState.compressedBase64 && !lbCompressState.compressedBlob)) {
            await buildCompressionPreview();
        }
        
        // Generate base64 on demand
        if (!lbCompressState.compressedBase64 && lbCompressState.compressedBlob) {
             try {
                 lbCompressState.compressedBase64 = await blobToBase64Async(lbCompressState.compressedBlob);
             } catch (e) {
                 console.error("Failed to convert blob to base64", e);
             }
        }

        if (!lbCompressState.compressedBase64) {
            setTemporaryErrorStatus("Generate a preview before compressing.");
            return;
        }
        if (lbSaveCompressedBtn) lbSaveCompressedBtn.disabled = true;
        setCompressionStatus("Saving...");
        try {
            const snapshot = await getResultSnapshot(lbCompressState.taskId);
            const listId = snapshot?.listId || MAIN_LIST_ID;
            const prompt = snapshot?.prompt || "";
            const refImageIds = Array.isArray(snapshot?.refImageIds) ? snapshot.refImageIds : [];
            const sourceMeta = snapshot?.meta || {};
            const aspect = ratioFromDims(lbCompressState.targetWidth, lbCompressState.targetHeight) || sourceMeta.aspectRatio || "";
            const meta = {
                ...sourceMeta,
                mimeType: "image/jpeg",
                extension: "jpg",
                width: lbCompressState.targetWidth,
                height: lbCompressState.targetHeight,
                fileSize: lbCompressState.compressedBytes,
                resolution: `${lbCompressState.targetWidth}x${lbCompressState.targetHeight}`,
                aspectRatio: aspect,
                originalTaskId: lbCompressState.taskId,
                originalResolution: `${lbCompressState.originalWidth}x${lbCompressState.originalHeight}`,
                compressionQuality: lbCompressState.quality,
                resizeMode: lbCompressState.resizeMode,
                resizeScale: lbCompressState.scale,
                compressedBytes: lbCompressState.compressedBytes,
                originalBytes: lbCompressState.originalBytes,
                provider: "local-compress",
                compressedAt: Date.now()
            };
            const newTaskId = `${Date.now()}_${Math.random().toString(36).slice(2, 6)}_cmp`;
            await renderImageCard(newTaskId, lbCompressState.compressedBase64, meta, prompt, {
                listId,
                refImageIds
            });
            // Clear the temporary base64 to free memory immediately after save
            lbCompressState.compressedBase64 = null;
            setCompressionStatus("Saved as a new card");
            setTemporaryStatus("Compressed version created");
        } catch (err) {
            console.error("Save compressed copy failed", err);
            setCompressionStatus("Save failed");
            setTemporaryErrorStatus(err?.message || "Failed to save compressed image.");
        } finally {
            if (lbSaveCompressedBtn) lbSaveCompressedBtn.disabled = false;
            // Clear the generated base64 whether success or fail, blob is still available for retry
            lbCompressState.compressedBase64 = null;
        }
    }

    async function saveCompressedAndReplace(e) {
        if (!lbCompressState.active || (!lbCompressState.compressedBase64 && !lbCompressState.compressedBlob)) {
            await buildCompressionPreview();
        }

        // Generate base64 on demand
        if (!lbCompressState.compressedBase64 && lbCompressState.compressedBlob) {
             try {
                 lbCompressState.compressedBase64 = await blobToBase64Async(lbCompressState.compressedBlob);
             } catch (e) {
                 console.error("Failed to convert blob to base64", e);
             }
        }

        if (!lbCompressState.compressedBase64) {
            setTemporaryErrorStatus("Generate a preview before compressing.");
            return;
        }
        // Check for shortcut override (CMD/CTRL)
        if (!e.metaKey && !e.ctrlKey) {
            if (!confirm("Replace this card's original image with the compressed one? This cannot be undone.")) return;
        }

        if (lbReplaceCompressedBtn) lbReplaceCompressedBtn.disabled = true;
        setCompressionStatus("Replacing...");
        try {
            const taskId = lbCompressState.taskId;
            const snapshot = await getResultSnapshot(taskId);
            const sourceMeta = snapshot?.meta || {};
            const aspect = ratioFromDims(lbCompressState.targetWidth, lbCompressState.targetHeight) || sourceMeta.aspectRatio || "";
            
            const newMeta = {
                ...sourceMeta,
                mimeType: "image/jpeg",
                extension: "jpg",
                width: lbCompressState.targetWidth,
                height: lbCompressState.targetHeight,
                fileSize: lbCompressState.compressedBytes,
                resolution: `${lbCompressState.targetWidth}x${lbCompressState.targetHeight}`,
                aspectRatio: aspect,
                originalResolution: sourceMeta.resolution || `${lbCompressState.originalWidth}x${lbCompressState.originalHeight}`, // Keep track of previous resolution if needed, or stick to pixel dims
                compressionQuality: lbCompressState.quality,
                resizeMode: lbCompressState.resizeMode,
                resizeScale: lbCompressState.scale,
                compressedBytes: lbCompressState.compressedBytes,
                // originalBytes: lbCompressState.originalBytes, // Maybe don't overwrite originalBytes locally if we want to track true original? But for replacement, the "current" file becomes this one.
                replacedAt: Date.now()
            };
            
            // Construct full record for persistence
            const updatedRecord = {
                taskId: taskId,
                meta: newMeta,
                prompt: snapshot?.prompt || "",
                listId: snapshot?.listId || MAIN_LIST_ID,
                timestamp: snapshot?.timestamp || Date.now(),
                refImageIds: Array.isArray(snapshot?.refImageIds) ? snapshot.refImageIds : [],
                base64: lbCompressState.compressedBase64
            };

            // 1. Persist to DB
            await persistResultRecord(updatedRecord);

            // 2. Update memory cache
            rememberResultRecord(taskId, {
                meta: newMeta,
                prompt: updatedRecord.prompt,
                listId: updatedRecord.listId,
                base64: updatedRecord.base64
            });

            // 3. Update UI Card
            const card = document.querySelector(`.result-card[data-task-id="${taskId}"]`);
            if (card) {
               const img = card.querySelector("img");
               if (img) {
                   const type = newMeta.mimeType || "image/png";
                   img.src = `data:${type};base64,${updatedRecord.base64}`;
               }
               // Update resolution badge if it exists
               const metaEl = card.querySelector(".result-meta");
               if (metaEl) {
                   metaEl.innerHTML = "";
                   
                   const line1 = document.createElement("div");
                   line1.style.display = "flex";
                   line1.style.gap = "8px";
                   line1.style.alignItems = "center";
                   line1.style.fontSize = "11px";
                   line1.style.marginBottom = "4px";
                   line1.style.flexWrap = "wrap";

                   let resText = "";
                   if (newMeta.width && newMeta.height) {
                       resText = `${newMeta.width}*${newMeta.height}`;
                   } else if (newMeta.resolution) {
                       resText = newMeta.resolution.replace(/[xX]/g, "*");
                   }
                   
                   if (resText) {
                       const resSpan = document.createElement("span");
                       resSpan.textContent = resText;
                       resSpan.style.fontWeight = "600";
                       line1.appendChild(resSpan);
                   }

                   const curExt = (newMeta.extension || "jpg").toUpperCase();
                   const fmtSpan = document.createElement("span");
                   fmtSpan.textContent = curExt;
                   fmtSpan.style.opacity = "0.6";
                   line1.appendChild(fmtSpan);

                   let sizeText = "";
                   const bytes = newMeta.compressedBytes || newMeta.fileSize || estimateBase64Bytes(updatedRecord.base64);
                   if (bytes) {
                       const kb = bytes / 1024;
                       if (kb >= 1024) {
                           sizeText = (kb / 1024).toFixed(1) + " MB";
                       } else {
                           sizeText = Math.round(kb) + " KB";
                       }
                   }
                   
                   if (sizeText) {
                       const sizeSpan = document.createElement("span");
                       sizeSpan.textContent = sizeText;
                       sizeSpan.style.opacity = "0.6";
                       line1.appendChild(sizeSpan);
                   }

                   const line2 = document.createElement("div");
                   const timeSpan = document.createElement("span");
                   timeSpan.className = "timestamp-badge";
                   timeSpan.textContent = formatTimestamp(updatedRecord.timestamp); 
                   timeSpan.style.display = "block"; 
                   line2.appendChild(timeSpan);

                   metaEl.appendChild(line1);
                   metaEl.appendChild(line2);
               }
            }

            // 4. Update Lightbox Image
            if (lightbox.classList.contains("visible") && lightboxImage.dataset.taskId === taskId) {
                const type = newMeta.mimeType || "image/png";
                lightboxImage.src = `data:${type};base64,${updatedRecord.base64}`;
                // Update compression state to match new "original"
                lbCompressState.base64 = updatedRecord.base64;
                lbCompressState.originalBytes = lbCompressState.compressedBytes;
                lbCompressState.originalWidth = lbCompressState.targetWidth;
                lbCompressState.originalHeight = lbCompressState.targetHeight;
                lbCompressState.meta = newMeta;
                
                // Re-init bitmap for further compression if needed
                if (lbCompressState.baseBitmap) {
                    try { lbCompressState.baseBitmap.close(); } catch (e) {}
                    lbCompressState.baseBitmap = null;
                }
                // Release old source object URL before creating new one
                if (lbCompressState.sourceObjectUrl) {
                    try { URL.revokeObjectURL(lbCompressState.sourceObjectUrl); } catch (e) {}
                    lbCompressState.sourceObjectUrl = null;
                }
                const blob = base64ToBlob(lbCompressState.base64, type);
                lbCompressState.sourceObjectUrl = URL.createObjectURL(blob);
                lbCompressState.baseBitmap = await createImageBitmap(blob);
                
                updateCompressionStats();
                setCompressionStatus("Replaced successfully");
                setTimeout(() => setCompressionStatus("Press R to toggle anytime"), 1500);
            } else {
                 setTemporaryStatus("Original image replaced");
            }

        } catch (err) {
            console.error("Replace compressed failed", err);
            setCompressionStatus("Replace failed");
            setTemporaryErrorStatus(err?.message || "Replace failed");
        } finally {
            if (lbReplaceCompressedBtn) lbReplaceCompressedBtn.disabled = false;
            // Clear the generated base64 to free memory
            lbCompressState.compressedBase64 = null;
        }
    }

    async function enterCompressionMode() {
        if (!lightbox || !lightbox.classList.contains("visible")) return;
        if (lightboxImage.dataset.context === "ref") {
            setTemporaryErrorStatus("Reference images are not supported for compression yet.");
            return;
        }
        const taskId = lightboxImage.dataset.taskId;
        if (!taskId) {
            setTemporaryErrorStatus("Could not find a task for the current image.");
            return;
        }
        try {
            resetCompressionPreviewZoom();
            lbCompressState.active = true;
            lbCompressState.taskId = taskId;
            lbCompressState.context = lightboxImage.dataset.context || "result";
            setCompressionStatus("Loading...");
            if (lightboxTools) lightboxTools.classList.add("active");
            const snapshot = await getResultSnapshot(taskId);
            const meta = snapshot?.meta || {};
            let base64 = await fetchFullBase64(taskId);

            let forceRefresh = !base64;
            if (base64) {
                try {
                    const checkMime = meta.mimeType || DEFAULT_IMAGE_MIME;
                    const dims = await getImageDimensionsFromBase64(base64, checkMime);
                    if (dims) {
                        const isSmall = Math.max(dims.width, dims.height) <= 320;
                        const metaExpectsLarge = meta.width && meta.height && Math.max(meta.width, meta.height) > 480;
                        if (isSmall && (metaExpectsLarge || meta.remoteUrl || meta.remote_url)) {
                            setCompressionStatus("Fetching high-res original...");
                            forceRefresh = true;
                        }
                    }
                } catch (e) {
                    console.warn("Quality check failed", e);
                }
            }

            if (forceRefresh) {
                try {
                    const hydrated = await hydrateRemoteResultForTask(taskId, { refresh: true });
                    if (hydrated?.base64) {
                        base64 = hydrated.base64;
                        if (hydrated.meta) Object.assign(meta, hydrated.meta);
                    }
                } catch (err) {
                    console.warn("Compress hydrate failed", err);
                }
            }

            if (!base64) {
                setTemporaryErrorStatus("Image data missing; cannot compress.");
                resetCompressionMode();
                return;
            }
            lbCompressState.base64 = base64;
            lbCompressState.sourceMime = meta.mimeType || DEFAULT_IMAGE_MIME;
            lbCompressState.originalBytes = estimateBase64Bytes(base64);
            lbCompressState.prompt = snapshot?.prompt || "";
            lbCompressState.listId = snapshot?.listId || MAIN_LIST_ID;
            lbCompressState.refImageIds = Array.isArray(snapshot?.refImageIds) ? snapshot.refImageIds : [];
            lbCompressState.meta = meta;
            const bitmap = await ensureBaseBitmap();
            if (!bitmap) {
                setTemporaryErrorStatus("Load failed");
                resetCompressionMode();
                return;
            }
            lbCompressState.customWidth = bitmap.width;
            lbCompressState.customHeight = bitmap.height;
            lbCompressState.targetWidth = bitmap.width;
            lbCompressState.targetHeight = bitmap.height;
            if (lbSourceInfo) lbSourceInfo.textContent = `Source: ${meta.provider || "local"}`;
            updateCompressionStats();
            updateCompressionUi();
            updatePreviewSplit(lbCompressState.split);
            await buildCompressionPreview();
            setCompressionStatus("Press R to toggle anytime");
        } catch (err) {
            console.error("Enter compression failed", err);
            setTemporaryErrorStatus(err?.message || "Failed to initialize compression mode.");
            resetCompressionMode();
        }
    }
    function resetLightboxState() {
        resetCompressionMode();
        exitUpscaleMode();
        if (typeof exitEditMode === "function") exitEditMode();
        lbState = { isZoomed: false, scale: 1, x: 0, y: 0, isDragging: false, startX: 0, startY: 0, initialTx:0, initialTy:0, dragMoved: false, skipNextClick: false };
        lightboxImage.style.transform = `translate(0px, 0px) scale(1)`;
        lightboxImage.classList.remove("zoomed");
        lightboxImage.classList.remove("dragging");
    }
    function openLightboxWithSrc(src, alt) {
      if (!src) return;
      lightboxImage.src = src;
      lightboxImage.removeAttribute("data-task-id");
      lightboxImage.alt = alt || "Preview image";
      resetLightboxState();
      lightbox.classList.add("visible");
      lightbox.setAttribute("aria-hidden", "false");
    }

    async function fetchFullBase64(taskId) {
        if (!taskId) return null;
        const record = resultsData.get(taskId);
        try {
            const db = await openDB();
            const tx = db.transaction([STORE_PAYLOADS, STORE_RESULTS], "readonly");
            const payloadStore = tx.objectStore(STORE_PAYLOADS);
            const payload = await new Promise((resolve) => {
                const req = payloadStore.get(taskId);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => resolve(null);
            });
            if (payload?.base64) return payload.base64;
            const legacyStore = tx.objectStore(STORE_RESULTS);
            const legacy = await new Promise((resolve) => {
                const req = legacyStore.get(taskId);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => resolve(null);
            });
            if (legacy?.base64) return legacy.base64;
        } catch(e) {
            console.warn("DB payload read failed", e);
        }

        if (workingDirectoryHandle) {
             const meta = record ? record.meta : {};
             const diskData = await readImagePayloadFromDisk(taskId, meta);
             if (diskData && diskData.base64) {
                 return diskData.base64;
             }
        }
        return null;
    }

    async function getResultSnapshot(taskId) {
        if (!taskId) return null;
        let record = resultsData.get(taskId);
        let stored = null;
        if (!record || !record.meta) {
            stored = await fetchStoredResultRecord(taskId);
            if (stored) {
                record = rememberResultRecord(taskId, {
                    meta: stored.meta || {},
                    prompt: stored.prompt || "",
                    listId: stored.listId || MAIN_LIST_ID,
                    timestamp: stored.timestamp || Date.now(),
                    refImageIds: Array.isArray(stored.refImageIds) ? stored.refImageIds : []
                });
            }
        }
        const meta = { ...(record?.meta || stored?.meta || {}) };
        const prompt = record?.prompt || stored?.prompt || "";
        const timestamp = record?.timestamp || stored?.timestamp || Date.now();
        const listId = record?.listId || stored?.listId || MAIN_LIST_ID;
        const refImageIds = Array.isArray(record?.refImageIds)
            ? record.refImageIds
            : (Array.isArray(stored?.refImageIds) ? stored.refImageIds : []);
        return { record, stored, meta, prompt, timestamp, listId, refImageIds };
    }

    async function hydrateRemoteResultForTask(taskId, options = {}) {
        const snapshot = await getResultSnapshot(taskId);
        if (!snapshot) return null;
        const { meta, prompt, timestamp, listId, refImageIds } = snapshot;
        const remoteUrl = meta?.remoteUrl || meta?.remote_url || "";
        if (!remoteUrl) return null;
        const provider = normalizeProvider(meta?.provider || options.provider || activeProvider);
        const apiKey = options.apiKey || getApiKeyManager(provider).getNextKey();
        const maxAttempts = typeof options.maxAttempts === "number" ? options.maxAttempts : 2;
        let lastErr = null;
        for (let attempt = 1; attempt <= maxAttempts; attempt++) {
            try {
                const payload = await fetchImageUrlAsBase64(remoteUrl, provider, apiKey);
                if (!payload?.base64) throw new Error("Image fetch returned empty data.");
                const resolvedMimeType = payload.mimeType || meta.mimeType || DEFAULT_IMAGE_MIME;
                const safeMeta = {
                    ...meta,
                    mimeType: resolvedMimeType,
                    extension: meta.extension || mimeTypeToExtension(resolvedMimeType),
                    provider
                };
                let thumbData = null;
                try {
                    thumbData = await generateThumbnail(payload.base64, resolvedMimeType);
                } catch (err) {
                    console.warn("Thumbnail generation failed", err);
                }
                await persistResultRecord({
                    taskId,
                    base64: payload.base64,
                    meta: safeMeta,
                    prompt,
                    timestamp,
                    listId,
                    thumbnail: thumbData,
                    refImageIds
                });
                rememberResultRecord(taskId, { meta: safeMeta, prompt, timestamp, listId, refImageIds });
                if (options.saveToDisk) {
                    await saveResultToDisk(taskId, payload.base64, resolvedMimeType, {
                        prompt,
                        meta: safeMeta,
                        timestamp,
                        listId,
                        taskId,
                        thumbnail: thumbData,
                        refImageIds
                    });
                }
                if (options.refresh) {
                    renderActivePage({ reason: "remote-hydrate" });
                }
                return { base64: payload.base64, mimeType: resolvedMimeType, meta: safeMeta, thumbnail: thumbData, refImageIds };
            } catch (err) {
                lastErr = err;
                if (attempt < maxAttempts && isRetryableError(err)) {
                    const delay = Math.min(2000, getBackoffDelayMs(attempt));
                    try { await wait(delay); } catch (waitErr) {}
                    continue;
                }
                break;
            }
        }
        if (lastErr) throw lastErr;
        return null;
    }

    function refreshCardMetaUI(taskId) {
        const card = document.querySelector(`.result-card[data-task-id="${taskId}"]`);
        if (!card) return;
        
        const record = resultsData.get(taskId);
        if (!record || !record.meta) return;
        
        const metaEl = card.querySelector(".result-meta");
        if (!metaEl) return;
        
        const safeMeta = record.meta;
        const extension = safeMeta.extension || mimeTypeToExtension(safeMeta.mimeType || "image/png");
        const timestamp = record.timestamp || parseInt(card.dataset.createdAt) || Date.now();

        metaEl.innerHTML = "";
        
        const line1 = document.createElement("div");
        line1.style.display = "flex";
        line1.style.gap = "8px";
        line1.style.alignItems = "center";
        line1.style.fontSize = "11px";
        line1.style.marginBottom = "4px";
        line1.style.flexWrap = "wrap";

        let resText = "";
        if (safeMeta.width && safeMeta.height) {
            resText = `${safeMeta.width}*${safeMeta.height}`;
        } else if (safeMeta.resolution) {
            resText = safeMeta.resolution.replace(/[xX]/g, "*");
        }
        
        if (resText) {
            const resSpan = document.createElement("span");
            resSpan.textContent = resText;
            resSpan.style.fontWeight = "600";
            line1.appendChild(resSpan);
        }

        const curExt = (extension || "png").toUpperCase();
        const fmtSpan = document.createElement("span");
        fmtSpan.textContent = curExt;
        fmtSpan.style.opacity = "0.6";
        line1.appendChild(fmtSpan);

        let sizeText = "";
        let bytes = safeMeta.fileSize;
        if (bytes) {
            const kb = bytes / 1024;
            if (kb >= 1024) {
                sizeText = (kb / 1024).toFixed(1) + " MB";
            } else {
                sizeText = Math.round(kb) + " KB";
            }
        }
        
        if (sizeText) {
            const sizeSpan = document.createElement("span");
            sizeSpan.textContent = sizeText;
            sizeSpan.style.opacity = "0.6";
            line1.appendChild(sizeSpan);
        }

        const line2 = document.createElement("div");
        const timeSpan = document.createElement("span");
        timeSpan.className = "timestamp-badge";
        timeSpan.textContent = formatTimestamp(timestamp);
        timeSpan.style.display = "block"; 
        line2.appendChild(timeSpan);

        metaEl.appendChild(line1);
        metaEl.appendChild(line2);
    }

    function getImageDimensionsFromBase64(base64, mimeType) {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => resolve({ width: img.width, height: img.height });
            img.onerror = () => resolve(null);
            img.src = `data:${mimeType};base64,${base64}`;
        });
    }

    async function ensureResultMetadata(taskId, base64, existingMeta, mimeType) {
        if (!base64) return false;
        const meta = existingMeta || {};
        let changed = false;
        
        if (!meta.fileSize) {
             meta.fileSize = Math.round((base64.length * 3) / 4);
             changed = true;
        }
        
        if (!meta.width || !meta.height) {
            try {
                const dims = await getImageDimensionsFromBase64(base64, mimeType || "image/png");
                if (dims) {
                    meta.width = dims.width;
                    meta.height = dims.height;
                    meta.resolution = `${dims.width}x${dims.height}`;
                    meta.aspectRatio = formatAspectRatioFromSize(dims.width, dims.height);
                    changed = true;
                }
            } catch (e) {
                console.warn("Failed to get dims for metadata update", e);
            }
        }
        
        if (changed) {
            // 1. Update In-Memory Runtime Record if present
            const runtimeRecord = resultsData.get(taskId);
            if (runtimeRecord) {
                runtimeRecord.meta = meta;
            }

            // 2. Update IndexedDB (Persistent Store for Lists)
            await updateStoredResult(taskId, { meta });

            // 3. Update File Metadata (JSON on Disk)
            // We need a full record to safely write the JSON file.
            // Use runtimeRecord if available, otherwise fetch from DB (which we just updated or is about to be updated)
            let fullRecord = runtimeRecord;
            if (!fullRecord) {
                fullRecord = await fetchStoredResultRecord(taskId);
            }
            
            if (fullRecord) {
                // Ensure the fetch record has the latest meta
                fullRecord.meta = meta;
                await persistResultMetadataSnapshot(taskId, fullRecord);
            }
        }
        return changed;
    }

    async function openLightboxByTaskId(taskId, context = 'result') {
        let record = resultsData.get(taskId);

        if (context === 'result') {
            lastViewedTaskId = taskId; 
            if (!record) {
                try {
                    const stored = await fetchStoredResultRecord(taskId);
                    if (stored) {
                        record = {
                            taskId: stored.taskId,
                            meta: stored.meta || {},
                        };
                        // resultsData.set(taskId, record); 
                    }
                } catch (err) {
                    console.warn("Lightbox fallback fetch failed", err);
                }
            }
        }

        if (!record && context === 'result') return; 
        
        if (context === 'result') {
            markResultSeen(taskId);
        }

        if (lightboxImage.src && lightboxImage.src.startsWith('blob:')) {
             URL.revokeObjectURL(lightboxImage.src);
        }

        if (lightboxImage.dataset.tempUrl) {
            URL.revokeObjectURL(lightboxImage.dataset.tempUrl);
            lightboxImage.removeAttribute("data-tempUrl");
        }

        let mimeType = DEFAULT_IMAGE_MIME;
        if (context === 'ref') {
             const refEntry = refImages.find(r => r.sourceId === taskId);
             if (refEntry) mimeType = refEntry.mimeType;
        } else if (record) {
             mimeType = record.meta?.mimeType || DEFAULT_IMAGE_MIME;
        }

        let fullBase64 = await fetchFullBase64(taskId);
        if (!fullBase64 && context === "result") {
            try {
                const hydrated = await hydrateRemoteResultForTask(taskId, { maxAttempts: 2, refresh: true });
                if (hydrated?.base64) {
                    fullBase64 = hydrated.base64;
                    if (hydrated?.mimeType) mimeType = hydrated.mimeType;
                }
            } catch (err) {
                console.warn("Failed to hydrate remote image for lightbox", err);
                setTemporaryErrorStatus(err?.message || "Failed to fetch remote image.");
                return;
            }
        }
        if (!fullBase64) return;

        if (context === "result") {
             // Lazily update missing metadata like resolution and file size
             ensureResultMetadata(taskId, fullBase64, record?.meta, mimeType).then((updated) => {
                 if (updated) {
                     refreshCardMetaUI(taskId);
                 }
             });
        }

        const blob = base64ToBlob(fullBase64, mimeType);
        const objectUrl = URL.createObjectURL(blob);

        lightboxImage.src = objectUrl;
        lightboxImage.dataset.taskId = taskId;
        lightboxImage.dataset.context = context; 
        lightboxImage.dataset.tempUrl = objectUrl;
        
        lightboxImage.alt = "Preview image";
        resetLightboxState();
        lightbox.classList.add("visible");
        lightbox.setAttribute("aria-hidden", "false");
    }

    async function triggerLastViewedLocator() {
        if (!lastViewedTaskId) return;
        const activeListId = listConfig.active || MAIN_LIST_ID;
        const orderedIds = getOrderedTaskIdsForList(activeListId);
        const index = orderedIds.indexOf(lastViewedTaskId);
        if (index === -1) {
            setTemporaryErrorStatus("Last viewed card not in current list");
            return;
        }
        const targetPage = Math.floor(index / pageState.pageSize);
        setPageIndex(activeListId, targetPage);
        await renderActivePage({ reason: "locator" });
        const card = document.querySelector(`.result-card[data-task-id="${lastViewedTaskId}"]`);
        if (!card) return;

        document.querySelectorAll('.locator-highlight').forEach(el => {
            el.classList.remove('locator-highlight');
        });

        requestAnimationFrame(() => {
            card.classList.add('locator-highlight');
        });

        if (locatorTimer) clearTimeout(locatorTimer);
        locatorTimer = setTimeout(() => {
            card.classList.remove('locator-highlight');
            locatorTimer = null;
        }, 3000);
    }
    function closeLightbox() {
        lightbox.classList.remove("visible");
        lightbox.setAttribute("aria-hidden", "true");
        
        const tempUrl = lightboxImage.dataset.tempUrl;
        
        setTimeout(() => { 
            lightboxImage.removeAttribute("data-task-id"); 
            
            if (tempUrl) {
                URL.revokeObjectURL(tempUrl);
                lightboxImage.removeAttribute("data-tempUrl");
                
                const currentId = lightboxImage.dataset.taskId;
                if (currentId) {
                    const record = resultsData.get(currentId);
                    if (record && record.objectUrl === tempUrl) {
                        record.objectUrl = null;
                    }
                }
            }
            // ------------------------
            
            lightboxImage.src = ""; 
            resetLightboxState(); 
        }, 200);
    }
    function navigateLightbox(direction) {
        const orderedIds = getOrderedTaskIdsForList(listConfig.active);
        if (!orderedIds.length) return;
        const currentId = lightboxImage.dataset.taskId;
        const currentIndex = orderedIds.indexOf(currentId);
        if (currentIndex === -1) return;
        let newIndex = currentIndex + direction;
        if (newIndex < 0) newIndex = 0;
        if (newIndex >= orderedIds.length) newIndex = orderedIds.length - 1;
        if (newIndex !== currentIndex) {
            const nextId = orderedIds[newIndex];
            if (nextId) openLightboxByTaskId(nextId);
        }
    }
    lightboxImage.addEventListener("mousedown", (e) => {
        if (lbEditState.active) return; // Prevent interaction in Edit Mode
        if (!lbState.isZoomed) return;
        e.preventDefault();
        lbState.isDragging = true;
        lbState.startX = e.clientX;
        lbState.startY = e.clientY;
        lbState.initialTx = lbState.x;
        lbState.initialTy = lbState.y;
        lbState.dragMoved = false;
        lbState.skipNextClick = false;
        lightboxImage.classList.add("dragging");
    });
    window.addEventListener("mousemove", (e) => {
        lastCursorX = e.clientX;
        lastCursorY = e.clientY;
        if (lbState.isDragging && lbState.isZoomed) {
            e.preventDefault();
            const dx = e.clientX - lbState.startX;
            const dy = e.clientY - lbState.startY;
            if (!lbState.dragMoved && (dx !== 0 || dy !== 0)) {
                lbState.dragMoved = true;
            }
            lbState.x = lbState.initialTx + dx;
            lbState.y = lbState.initialTy + dy;
            lightboxImage.style.transform = `translate(${lbState.x}px, ${lbState.y}px) scale(${lbState.scale})`;
        }
        if (lbPreviewZoomState.isDragging && lbCompressState.active) {
            e.preventDefault();
            const dx = e.clientX - lbPreviewZoomState.startX;
            const dy = e.clientY - lbPreviewZoomState.startY;
            lbPreviewZoomState.x = lbPreviewZoomState.initialX + dx;
            lbPreviewZoomState.y = lbPreviewZoomState.initialY + dy;
            updateCompressionPreviewTransform();
        }
        if (compareViewState.isDragging && compareModeState.overlayVisible) {
            e.preventDefault();
            const dx = e.clientX - compareViewState.startX;
            const dy = e.clientY - compareViewState.startY;
            compareViewState.x = compareViewState.initialX + dx;
            compareViewState.y = compareViewState.initialY + dy;
            updateCompareZoomTransform();
        }
    });
    window.addEventListener("mouseup", (e) => {
        if (lbState.isDragging) {
            lbState.isDragging = false;
            lightboxImage.classList.remove("dragging");
            if (lbState.dragMoved && e.target === lightboxImage) {
                lbState.skipNextClick = true;
            }
            lbState.dragMoved = false;
        }
        if (lbPreviewZoomState.isDragging) {
            lbPreviewZoomState.isDragging = false;
            lbPreview?.classList.remove("dragging");
        }
        if (compareViewState.isDragging) {
            compareViewState.isDragging = false;
            compareViewEl?.classList.remove("compare-dragging");
        }
    });
    lightboxImage.addEventListener("click", (e) => {
        e.stopPropagation(); 
        if (lbEditState.active) return; // Prevent interaction in Edit Mode
        if (lbState.skipNextClick) {
            lbState.skipNextClick = false;
            return;
        }
        if (!lbState.isZoomed) {
            const rect = lightboxImage.getBoundingClientRect();
            const clickX = e.clientX;
            const clickY = e.clientY;
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const offsetX = centerX - clickX;
            const offsetY = centerY - clickY;
            const targetScale = 2.5;
            lbState.x = offsetX * (targetScale - 1); 
            lbState.y = offsetY * (targetScale - 1);
            lbState.scale = targetScale;
            lbState.isZoomed = true;
            lightboxImage.classList.add("zoomed");
        } else {
            lbState.isZoomed = false;
            lbState.scale = 1;
            lbState.x = 0;
            lbState.y = 0;
            lightboxImage.classList.remove("zoomed");
        }
        lbState.dragMoved = false;
        lightboxImage.style.transform = `translate(${lbState.x}px, ${lbState.y}px) scale(${lbState.scale})`;
    });
        lightboxClose.addEventListener("click", closeLightbox);
        lightbox.addEventListener("click", (e) => { if (e.target === lightbox || e.target.classList.contains('lightbox-inner')) closeLightbox(); });
        
        function adjustLightboxScale(delta) {
            if (!lightbox.classList.contains("visible")) return;
            if (lbEditState.active) {
                adjustEditZoom(delta);
                return;
            }
            if (lbCompressState.active && lightboxTools?.classList.contains("active")) {
                adjustCompressionPreviewScale(delta);
                return;
            }

            const oldScale = lbState.scale;
            
            let newScale = oldScale + delta;
            if (newScale < 0.1) newScale = 0.1;
            if (newScale > 20) newScale = 20;

            if (newScale === oldScale) return;

            const viewportCenterX = window.innerWidth / 2;
            const viewportCenterY = window.innerHeight / 2;
            
            const mouseRelX = lastCursorX - viewportCenterX;
            const mouseRelY = lastCursorY - viewportCenterY;

            const scaleRatio = newScale / oldScale;
            
            lbState.x = mouseRelX - (mouseRelX - lbState.x) * scaleRatio;
            lbState.y = mouseRelY - (mouseRelY - lbState.y) * scaleRatio;

            lbState.scale = newScale;

            if (lbState.scale !== 1) {
                lbState.isZoomed = true;
                lightboxImage.classList.add("zoomed");
            } else {
                resetLightboxZoom();
                return; 
            }

            lightboxImage.style.transform = `translate(${lbState.x}px, ${lbState.y}px) scale(${lbState.scale})`;
        }

        function resetLightboxZoom() {
            if (lbEditState.active) {
                 resetEditZoom();
                 return;
            }
            if (lbCompressState.active && lightboxTools?.classList.contains("active")) {
                resetCompressionPreviewZoom();
                return;
            }
            lbState.isZoomed = false;
            lbState.scale = 1;
            lbState.x = 0;
            lbState.y = 0;
            lightboxImage.classList.remove("zoomed");
            lightboxImage.style.transform = `translate(0px, 0px) scale(1)`;
        }

        if (lbResizeMode) lbResizeMode.addEventListener("change", (e) => {
            lbCompressState.resizeMode = e.target.value === "custom" ? "custom" : "scale";
            updateCompressionUi();
            scheduleCompressionPreview();
        });
        if (lbScaleInput) lbScaleInput.addEventListener("input", (e) => {
            lbCompressState.scale = Math.max(10, Math.min(400, Number(e.target.value) || 100));
            lbCompressState.resizeMode = "scale";
            updateCompressionUi();
            scheduleCompressionPreview();
        });
        if (lbScaleNumber) lbScaleNumber.addEventListener("input", (e) => {
            lbCompressState.scale = Math.max(10, Math.min(400, Number(e.target.value) || 100));
            lbCompressState.resizeMode = "scale";
            updateCompressionUi();
            scheduleCompressionPreview();
        });
        if (lbCustomWidth) lbCustomWidth.addEventListener("input", () => {
            lbCompressState.resizeMode = "custom";
            syncCustomSizeFromInput("width");
            scheduleCompressionPreview();
        });
        if (lbCustomHeight) lbCustomHeight.addEventListener("input", () => {
            lbCompressState.resizeMode = "custom";
            syncCustomSizeFromInput("height");
            scheduleCompressionPreview();
        });
        if (lbLockAspect) lbLockAspect.addEventListener("change", (e) => {
            lbCompressState.lockAspect = !!e.target.checked;
            if (lbCompressState.resizeMode === "custom") {
                syncCustomSizeFromInput();
                scheduleCompressionPreview();
            }
        });
        if (lbQualityInput) lbQualityInput.addEventListener("input", (e) => {
            lbCompressState.quality = Math.max(30, Math.min(100, Number(e.target.value) || 95));
            updateCompressionUi();
            scheduleCompressionPreview();
        });
        if (lbQualityNumber) lbQualityNumber.addEventListener("input", (e) => {
            lbCompressState.quality = Math.max(30, Math.min(100, Number(e.target.value) || 95));
            updateCompressionUi();
            scheduleCompressionPreview();
        });
        if (lbPreviewDivider && lbPreview) {
            lbPreviewDivider.addEventListener("pointerdown", (e) => {
                e.preventDefault();
                if (lbPreviewDivider.setPointerCapture) {
                    try { lbPreviewDivider.setPointerCapture(e.pointerId); } catch (err) {}
                }
                const dividerX = splitPercentToClientX(lbCompressState.split || 50);
                const dragOffset = Number.isFinite(dividerX) ? (e.clientX - dividerX) : 0;
                const move = (ev) => {
                    const percent = pointerXToSplitPercent(ev.clientX - dragOffset);
                    updatePreviewSplit(percent);
                };
                const up = () => {
                    window.removeEventListener("pointermove", move);
                    window.removeEventListener("pointerup", up);
                    if (lbPreviewDivider.releasePointerCapture) {
                        try { lbPreviewDivider.releasePointerCapture(e.pointerId); } catch (err) {}
                    }
                };
                window.addEventListener("pointermove", move);
                window.addEventListener("pointerup", up);
            });
        }
        if (lbPreview) {
            lbPreview.addEventListener("mousedown", (e) => {
                if (!lbCompressState.active) return;
                if (e.button !== 0) return;
                if (lbPreviewDivider && e.target === lbPreviewDivider) return;
                if (lbPreviewZoomState.scale === 1) return;
                e.preventDefault();
                lbPreviewZoomState.isDragging = true;
                lbPreviewZoomState.startX = e.clientX;
                lbPreviewZoomState.startY = e.clientY;
                lbPreviewZoomState.initialX = lbPreviewZoomState.x;
                lbPreviewZoomState.initialY = lbPreviewZoomState.y;
                lbPreview.classList.add("dragging");
            });
            lbPreview.addEventListener("wheel", (e) => {
                if (!lbCompressState.active) return;
                if (e.ctrlKey) return;
                const delta = e.deltaY > 0 ? -2 : 2;
                const next = Math.max(10, Math.min(400, lbCompressState.scale + delta));
                lbCompressState.scale = next;
                lbCompressState.resizeMode = "scale";
                updateCompressionUi();
                scheduleCompressionPreview();
            });
        }
        if (lbRefreshPreviewBtn) lbRefreshPreviewBtn.addEventListener("click", () => buildCompressionPreview().catch(console.error));
        if (lbSaveCompressedBtn) lbSaveCompressedBtn.addEventListener("click", () => saveCompressedAsNewCard().catch(console.error));
        if (lbReplaceCompressedBtn) lbReplaceCompressedBtn.addEventListener("click", (e) => saveCompressedAndReplace(e).catch(console.error));
        if (lbExitCompressBtn) lbExitCompressBtn.addEventListener("click", () => resetCompressionMode());
        if (lbUpscaleFactor) lbUpscaleFactor.addEventListener("input", updateUpscaleInfo);
        if (lbUpscaleSubmitBtn) lbUpscaleSubmitBtn.addEventListener("click", () => submitUpscaleTask().catch(console.error));
        if (lbUpscaleExitBtn) lbUpscaleExitBtn.addEventListener("click", () => exitUpscaleMode());
        if (compareOverlay) {
            compareOverlay.addEventListener("click", (e) => {
                if (e.target === compareOverlay) closeCompareOverlay();
            });
        }
        if (compareDivider && compareViewEl) {
            compareDivider.addEventListener("pointerdown", (e) => {
                if (!compareModeState.overlayVisible) return;
                e.preventDefault();
                const dividerX = splitPercentToCompareClientX(compareViewState.split || 50);
                const dragOffset = Number.isFinite(dividerX) ? e.clientX - dividerX : 0;
                const pointerId = e.pointerId;
                if (compareDivider.setPointerCapture) {
                    try { compareDivider.setPointerCapture(pointerId); } catch (err) {}
                }
                const move = (ev) => {
                    ev.preventDefault();
                    const percent = pointerXToCompareSplit(ev.clientX - dragOffset);
                    updateCompareSplit(percent);
                };
                const up = () => {
                    window.removeEventListener("pointermove", move);
                    window.removeEventListener("pointerup", up);
                    if (compareDivider.releasePointerCapture) {
                        try { compareDivider.releasePointerCapture(pointerId); } catch (err) {}
                    }
                };
                window.addEventListener("pointermove", move);
                window.addEventListener("pointerup", up);
            });
        }
        if (compareViewEl) {
            compareViewEl.addEventListener("wheel", (e) => {
                if (!compareModeState.overlayVisible || e.ctrlKey) return;
                e.preventDefault();
                const delta = e.deltaY > 0 ? -1.2 : 1.2;
                adjustCompareZoom(delta);
            }, { passive: false });
            compareViewEl.addEventListener("mousedown", (e) => {
                if (!compareModeState.overlayVisible) return;
                if (e.target === compareDivider) return;
                if (compareViewState.scale === 1) return;
                e.preventDefault();
                compareViewState.isDragging = true;
                compareViewState.startX = e.clientX;
                compareViewState.startY = e.clientY;
                compareViewState.initialX = compareViewState.x;
                compareViewState.initialY = compareViewState.y;
                compareViewEl.classList.add("compare-dragging");
            });
        }

        function handleDragPaginationKey(e) {
        if (!draggingCardId) return;
        if (lightbox.classList.contains("visible")) return;
        if (importOverlayEl && !importOverlayEl.classList.contains("hidden")) return;
        if (listMoveOverlayEl && !listMoveOverlayEl.classList.contains("hidden")) return;
        const keyLower = e.key?.toLowerCase();
        if (e.key === "ArrowLeft" || e.key === "PageUp" || e.keyCode === 37 || keyLower === "a" || e.code === "BracketLeft") {
            e.preventDefault();
            changePageBy(-1);
        }
        if (e.key === "ArrowRight" || e.key === "PageDown" || e.keyCode === 39 || keyLower === "d" || e.code === "BracketRight") {
            e.preventDefault();
            changePageBy(1);
        }
        }

        document.addEventListener("keydown", handleDragPaginationKey, true);
        document.addEventListener("keydown", (e) => {
        const keyLower = e.key?.toLowerCase();
        const targetTag = (document.activeElement?.tagName || "").toLowerCase();
        const isEditableTarget = document.activeElement?.isContentEditable || ["input", "textarea", "select"].includes(targetTag);
        const compareVisible = compareOverlayVisible();

        if (e.key === "Escape") {
            if (compareVisible) {
                e.preventDefault();
                closeCompareOverlay();
                return;
            }
            if (compareModeState.active) {
                e.preventDefault();
                exitCompareSelectionMode();
                return;
            }
            if (editSelectionModeState.active) {
                e.preventDefault();
                exitEditSelectionMode();
                return;
            }
            if (listMoveOverlayEl && !listMoveOverlayEl.classList.contains("hidden")) {
                e.preventDefault();
                closeListMoveOverlay();
                return;
            }
            if (importOverlayEl && !importOverlayEl.classList.contains("hidden") && importDialogResolver) {
                cancelImportDialog();
                return;
            }
            closeLightbox();
        }

        if (isEditableTarget) return;

        if (keyLower === "e") {
            if (compareVisible) {
                e.preventDefault();
                closeCompareOverlay();
                return;
            }
            if (compareModeState.active) {
                e.preventDefault();
                exitCompareSelectionMode();
                return;
            }
            if (editSelectionModeState.active) {
                e.preventDefault();
                exitEditSelectionMode();
                return;
            }
            if (importOverlayEl && !importOverlayEl.classList.contains("hidden") && importDialogResolver) {
                cancelImportDialog();
            } else {
                closeLightbox();
            }
        }

        if (lightbox.classList.contains("visible")) {
            if (lightboxImage.dataset.context !== 'ref') {
                if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a") navigateLightbox(-1);
                if (e.key === "ArrowRight" || e.key.toLowerCase() === "d") navigateLightbox(1);
            }
            const k = e.key.toLowerCase();
            
            if (k === "z") {
                adjustLightboxScale(1.5); 
            }
            if (k === "x") {
                adjustLightboxScale(-1.5);
            }
            if (k === "c") {
                resetLightboxZoom();
            }
            if (k === "r") {
                e.preventDefault();
                if (lbCompressState.active) resetCompressionMode();
                else enterCompressionMode();
            }
            if (k === "u") {
                e.preventDefault();
                if (lbUpscaleState.active) exitUpscaleMode();
                else enterUpscaleMode();
            }
            if (k === "t") {
                e.preventDefault();
                if (lbEditState.active) exitEditMode();
                else enterEditMode();
            }
        } else if (compareVisible) {
            if (keyLower === "z") {
                adjustCompareZoom(1.5);
            }
            if (keyLower === "x") {
                adjustCompareZoom(-1.5);
            }
            if (keyLower === "c") {
                resetCompareZoom();
            }
        }

        if (keyLower === "q" && !e.metaKey && !e.ctrlKey && !e.altKey) {
            e.preventDefault();
            triggerLastViewedLocator();
        }
        if (keyLower === "f" && !e.metaKey && !e.ctrlKey && !e.altKey) {
            e.preventDefault();
            setActiveList(REF_LIST_ID);
        }
        if (keyLower === "m" && !e.metaKey && !e.ctrlKey && !e.altKey) {
            if (!lightbox.classList.contains("visible") && importOverlayEl?.classList.contains("hidden")) {
                e.preventDefault();
                toggleListMoveOverlay();
            }
        }
        if (keyLower === "w" && !e.metaKey && !e.ctrlKey && !e.altKey) {
            if (compareVisible) {
                e.preventDefault();
                closeCompareOverlay();
                return;
            }
            if (compareModeState.active) {
                e.preventDefault();
                exitCompareSelectionMode();
                return;
            }
            const overlaysHidden = importOverlayEl?.classList.contains("hidden") && listMoveOverlayEl?.classList.contains("hidden");
            if (!lightbox.classList.contains("visible") && overlaysHidden && !lbCompressState.active && !lbUpscaleState.active && !editSelectionModeState.active) {
                e.preventDefault();
                enterCompareSelectionMode();
            }
        }
        if (keyLower === "p" && !e.metaKey && !e.ctrlKey && !e.altKey) {
            if (editSelectionModeState.active) {
                e.preventDefault();
                exitEditSelectionMode();
                return;
            }
            const overlaysHidden = importOverlayEl?.classList.contains("hidden") && listMoveOverlayEl?.classList.contains("hidden");
            if (!lightbox.classList.contains("visible") && overlaysHidden && !lbCompressState.active && !lbUpscaleState.active && !compareVisible && !compareModeState.active) {
                e.preventDefault();
                enterEditSelectionMode();
            }
        }
        if (!lightbox.classList.contains("visible")
            && importOverlayEl?.classList.contains("hidden")
            && listMoveOverlayEl?.classList.contains("hidden")
            && !compareVisible) {
            if (e.key === "ArrowLeft"||e.key.toLowerCase() === "a") {
                e.preventDefault();
                changePageBy(-1);
            }
            if (e.key === "ArrowRight"||e.key.toLowerCase() === "d") {
                e.preventDefault();
                changePageBy(1);
            }
        }
        });

    /* --- Reference Image Logic with Persistence --- */
    const REF_PLACEHOLDER_IMG = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";

    function createRefSelectionId() {
        return `refsel_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
    }

    function sortRefSelections() {
        refImages.sort((a, b) => (a.createdAt || 0) - (b.createdAt || 0));
    }

    function getRemainingReferenceSlots() {
        return Math.max(0, REF_IMAGE_LIMIT - refImages.length);
    }

    function isRefSourceSelected(sourceId) {
        return refImages.some(entry => entry.sourceId === sourceId);
    }

    function isAppOwnedRefEntry(entry) {
        if (!entry || !entry.sourceId) return false;
        if (entry.sourceListId === REF_LIST_ID) return true;
        return entry.sourceId.startsWith("ref-");
    }

    async function cleanupRefEntryArtifacts(entries = [], options = {}) {
        if (!Array.isArray(entries) || !entries.length) return;
        if (!options.purgeAssets) return;
        const ownedEntries = entries.filter(isAppOwnedRefEntry);
        if (!ownedEntries.length) return;
        const purgeIds = [];
        await Promise.all(ownedEntries.map(async (entry) => {
            try {
                purgeIds.push(entry.sourceId);
                await purgeResultRecord(entry.sourceId);
            } catch (err) {
                console.warn("Failed to cleanup ref entry", entry?.sourceId, err);
            }
        }));
        purgeIds.forEach((taskId) => {
            removeTaskFromOrder(taskId);
            removeTaskIndexEntry(taskId);
        });
        if (purgeIds.length) {
            renderActivePage({ reason: "ref-cleanup" });
        }
    }

    async function persistRefSelections(entriesOverride = null) {
        const snapshot = entriesOverride ? [...entriesOverride] : [...refImages];
        sortRefSelections();
        try {
            const db = await openDB();
            const tx = db.transaction(STORE_REFS, "readwrite");
            const store = tx.objectStore(STORE_REFS);
            await new Promise((resolve, reject) => {
                const clearReq = store.clear();
                clearReq.onsuccess = resolve;
                clearReq.onerror = () => reject(clearReq.error);
            });
            for (const entry of snapshot) {
                await new Promise((resolve, reject) => {
                    const req = store.put(entry);
                    req.onsuccess = resolve;
                    req.onerror = () => reject(req.error);
                });
            }
        } catch (err) {
            console.error("Ref persistence failed", err);
        }
    }

    function normalizeRefSelection(record) {
        if (!record?.id || !record?.sourceId) return null;
        return {
            id: record.id,
            sourceId: record.sourceId,
            sourceListId: record.sourceListId || record.listId || MAIN_LIST_ID,
            label: record.label || "Reference",
            mimeType: record.mimeType || DEFAULT_IMAGE_MIME,
            thumbnail: record.thumbnail || null,
            createdAt: record.createdAt || Date.now()
        };
    }

    function deriveRefLabel(record, fallback = "") {
        if (fallback) return fallback;
        const meta = record?.meta || {};
        if (meta.originalName) return meta.originalName;
        if (meta.source) return meta.source;
        return record?.taskId ? `ID ${record.taskId.slice(-6)}` : "Reference";
    }

    async function ensureRefEntryThumbnail(entry) {
        if (!entry || entry.thumbnail) return entry?.thumbnail || null;
        const runtimeRecord = resultsData.get(entry.sourceId);
        const thumb = await resolveRefThumbnail(entry.sourceId, runtimeRecord?.meta || null);
        if (thumb) {
            entry.thumbnail = thumb;
            await persistRefSelections();
        }
        return entry.thumbnail;
    }

    function buildRefMeta(mimeType, label, metaExtras = {}) {
        const safeMime = mimeType || DEFAULT_IMAGE_MIME;
        return {
            resolution: metaExtras.resolution || "",
            aspectRatio: metaExtras.aspectRatio || "",
            mimeType: safeMime,
            extension: metaExtras.extension || mimeTypeToExtension(safeMime),
            source: metaExtras.source || "ref",
            originalName: metaExtras.originalName || label || ""
        };
    }

    async function resolveRefThumbnail(taskId, metaHint = null, storedRecord = null) {
        if (!taskId) return null;
        if (storedRecord?.thumbnail) return storedRecord.thumbnail;
        try {
            let thumb = await fetchStoredThumbnail(taskId);
            if (thumb) return thumb;
            let meta = metaHint || storedRecord?.meta || resultsData.get(taskId)?.meta || null;
            let fallbackRecord = storedRecord;
            if (!meta || !fallbackRecord) {
                fallbackRecord = fallbackRecord || await fetchStoredResultRecord(taskId);
                if (fallbackRecord?.thumbnail) return fallbackRecord.thumbnail;
                meta = meta || fallbackRecord?.meta || null;
            }
            if (!meta) return null;
            return await hydrateMissingThumbnail({
                taskId,
                meta,
                thumbnail: null
            });
        } catch (err) {
            console.warn("Failed to resolve ref thumbnail", err);
            return null;
        }
    }

    async function createRefAssetFromBase64(base64Data, mimeType, label, metaExtras = {}) {
        if (!base64Data) return null;
        const taskId = `ref-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
        const safeMime = mimeType || DEFAULT_IMAGE_MIME;
        const meta = buildRefMeta(safeMime, label, metaExtras);
        const timestamp = Date.now();
        const shouldSkipSave = metaExtras.skipDiskSave !== undefined ? metaExtras.skipDiskSave : !folderAccessGranted;
        const thumbOverride = metaExtras.thumbnail || null;
        await renderImageCard(taskId, base64Data, meta, label || "", {
            listId: REF_LIST_ID,
            timestamp,
            skipDiskSave: shouldSkipSave,
            refImageIds: [],
            persistToDb: true,
            thumbnail: thumbOverride
        });
        return taskId;
    }

    async function buildRefEntryForSource(sourceId, options = {}) {
        if (!sourceId) return null;
        let record = resultsData.get(sourceId);
        let storedRecord = null;
        if (!record) {
            storedRecord = await fetchStoredResultRecord(sourceId);
            if (storedRecord) {
                record = {
                    taskId: storedRecord.taskId,
                    meta: storedRecord.meta,
                    prompt: storedRecord.prompt,
                    listId: storedRecord.listId || MAIN_LIST_ID,
                    timestamp: storedRecord.timestamp
                };
                rememberResultRecord(sourceId, {
                    meta: storedRecord.meta,
                    prompt: storedRecord.prompt,
                    listId: storedRecord.listId || MAIN_LIST_ID,
                    timestamp: storedRecord.timestamp || Date.now(),
                    refImageIds: Array.isArray(storedRecord.refImageIds) ? storedRecord.refImageIds : []
                });
            }
        }
        const meta = record?.meta || options.meta || storedRecord?.meta;
        if (!meta) return null;
        let thumbnail = options.thumbnail || storedRecord?.thumbnail || null;
        if (!thumbnail) {
            thumbnail = await resolveRefThumbnail(sourceId, meta, storedRecord);
        }
        const entry = {
            id: createRefSelectionId(),
            sourceId,
            sourceListId: options.sourceListId || record?.listId || MAIN_LIST_ID,
            label: options.label || deriveRefLabel(record, options.fallbackLabel || ""),
            mimeType: options.mimeType || meta.mimeType || DEFAULT_IMAGE_MIME,
            thumbnail,
            createdAt: options.createdAt || Date.now()
        };
        return entry;
    }

    async function migrateLegacyRefRecord(record) {
        try {
            const base64 = record?.data;
            if (!base64) return null;
            const mimeType = record.mimeType || DEFAULT_IMAGE_MIME;
            const label = record.name || "Reference";
            const taskId = await createRefAssetFromBase64(base64, mimeType, label, {
                source: "ref-legacy",
                originalName: label
            });
            if (!taskId) return null;
            return await buildRefEntryForSource(taskId, {
                label,
                sourceListId: REF_LIST_ID,
                mimeType
            });
        } catch (err) {
            console.warn("Legacy ref migration failed", err);
            return null;
        }
    }

    async function loadStoredRefSelections(dbOverride = null) {
        try {
            const db = dbOverride || await openDB();
            const txRef = db.transaction(STORE_REFS, "readonly");
            const storeRef = txRef.objectStore(STORE_REFS);
            const stored = await new Promise((resolve, reject) => {
                const req = storeRef.getAll();
                req.onsuccess = () => resolve(req.result || []);
                req.onerror = () => reject(req.error);
            });
            const fresh = [];
            const legacy = [];
            stored.forEach((item) => {
                if (item?.sourceId) {
                    const normalized = normalizeRefSelection(item);
                    if (normalized) fresh.push(normalized);
                } else if (item?.data) {
                    legacy.push(item);
                }
            });
            if (legacy.length) {
                for (const legacyEntry of legacy) {
                    const migrated = await migrateLegacyRefRecord(legacyEntry);
                    if (migrated) fresh.push(migrated);
                }
            }
            refImages = fresh.slice(0, REF_IMAGE_LIMIT);
            sortRefSelections();
            renderRefImageList();
            if (legacy.length) {
                await persistRefSelections();
            }
        } catch (err) {
            console.warn("Failed to load reference selections", err);
            refImages = [];
            renderRefImageList();
        }
    }

    function renderRefImageList() {
	const oldImages = refImageListEl.querySelectorAll("img");
	oldImages.forEach(img => {
        	if (img.src && img.src.startsWith("blob:")) {
            	URL.revokeObjectURL(img.src);
        	}
    	});
        refImageListEl.innerHTML = "";
        if (!refImages.length) {
            refImageHintEl.textContent = "No reference data loaded.";
            return;
        }
        refImageHintEl.textContent = `READY ${refImages.length} REF IMAGES (MAX ${REF_IMAGE_LIMIT})`;
        refImages.forEach((entry) => {
            const item = document.createElement("div");
            item.className = "ref-image-item";
            const thumbWrap = document.createElement("div");
            thumbWrap.className = "ref-thumb-wrap";
            const imageEl = document.createElement("img");
            if (entry.thumbnail) {
		if (entry.thumbnail instanceof Blob) {
        		imageEl.src = URL.createObjectURL(entry.thumbnail);
    		} else {
                imageEl.src = entry.thumbnail;
		}
            } else {
                imageEl.src = REF_PLACEHOLDER_IMG;
                ensureRefEntryThumbnail(entry).then((thumb) => {
                    if (thumb && imageEl.isConnected) {
			if (thumb instanceof Blob) {
                	imageEl.src = URL.createObjectURL(thumb);
            		} else {
                        imageEl.src = thumb;
			}
                    }
                }).catch(console.error);
            }
            imageEl.alt = entry.label || "Reference";
            thumbWrap.appendChild(imageEl);
            thumbWrap.addEventListener("click", () => openLightboxByTaskId(entry.sourceId, 'ref'));

            const meta = document.createElement("div");
            meta.className = "ref-meta";
            const nameEl = document.createElement("div");
            nameEl.className = "ref-name";
            nameEl.textContent = entry.label || entry.sourceId;

            const delBtn = document.createElement("button");
            delBtn.type = "button";
            delBtn.className = "btn-mini danger";
            delBtn.textContent = "DEL";
            delBtn.style.fontSize = "9px";
            delBtn.style.padding = "2px 4px";
            delBtn.addEventListener("click", (e) => {
                // if (!confirmAction(e, "Remove this reference image?")) return;
                removeRefSelection(entry.id);
            });
            meta.appendChild(nameEl);
            meta.appendChild(delBtn);
            item.appendChild(thumbWrap);
            item.appendChild(meta);
            refImageListEl.appendChild(item);
        });
    }

    async function addRefSelectionForTask(sourceId, options = {}) {
        if (!sourceId) return false;
        if (isRefSourceSelected(sourceId)) {
            setTemporaryErrorStatus("Reference already selected.");
            return false;
        }
        if (getRemainingReferenceSlots() <= 0) {
            setTemporaryErrorStatus(`LIMIT REACHED (${REF_IMAGE_LIMIT}).`);
            return false;
        }
        const entry = await buildRefEntryForSource(sourceId, options);
        if (!entry) {
            console.warn("Reference source unavailable", sourceId);
            return false;
        }
        refImages.push(entry);
        sortRefSelections();
        renderRefImageList();
        await persistRefSelections();
        return true;
    }

    async function removeRefSelection(entryId) {
        const toRemove = refImages.filter(entry => entry.id === entryId);
        if (!toRemove.length) return;
        refImages = refImages.filter(entry => entry.id !== entryId);
        renderRefImageList();
        await persistRefSelections();
        await cleanupRefEntryArtifacts(toRemove);
    }

    async function clearRefSelections() {
        if (!refImages.length) return;
        const toRemove = refImages.slice();
        refImages = [];
        renderRefImageList();
        await persistRefSelections();
        await cleanupRefEntryArtifacts(toRemove);
    }

    async function applyReferenceIdsQuietly(refIds = []) {
        if (!Array.isArray(refIds) || !refIds.length) {
            await clearRefSelections();
            return false;
        }
        const nextEntries = [];
        for (const sourceId of refIds.slice(0, REF_IMAGE_LIMIT)) {
            try {
                const entry = await buildRefEntryForSource(sourceId);
                if (entry) nextEntries.push(entry);
            } catch (err) {
                console.warn("Failed to rebuild reference entry", err);
            }
        }
        if (!nextEntries.length) return false;
        const previousEntries = refImages.slice();
        refImages = nextEntries;
        sortRefSelections();
        renderRefImageList();
        await persistRefSelections();
        const removedEntries = previousEntries.filter(prev => {
            return !nextEntries.some(next => next.sourceId === prev.sourceId);
        });
        await cleanupRefEntryArtifacts(removedEntries);
        return true;
    }

    async function handleExternalBase64Reference(base64Data, mimeType, fileName, metaExtras = {}) {
        if (!base64Data) return;
        if (getRemainingReferenceSlots() <= 0) {
            setTemporaryErrorStatus(`LIMIT REACHED (${REF_IMAGE_LIMIT}).`);
            return;
        }
        let thumbData = null;
        try {
            thumbData = await generateThumbnail(base64Data, mimeType);
        } catch (err) {
            console.warn("Reference thumbnail generation failed", err);
        }
        const refMeta = buildRefMeta(mimeType || DEFAULT_IMAGE_MIME, fileName || "Reference", {
            ...metaExtras,
            source: metaExtras.source || "ref-import",
            originalName: metaExtras.originalName || fileName || ""
        });
        const taskId = await createRefAssetFromBase64(base64Data, mimeType, fileName, {
            ...metaExtras,
            source: metaExtras.source || "ref-import",
            originalName: metaExtras.originalName || fileName || "",
            skipDiskSave: false,
            thumbnail: thumbData
        });
        if (taskId) {
            await addRefSelectionForTask(taskId, {
                label: fileName || "Reference",
                sourceListId: REF_LIST_ID,
                mimeType,
                thumbnail: thumbData,
                meta: refMeta
            });
        }
    }

    async function handleExternalFileReference(file) {
        if (!file || (file.type && !file.type.startsWith("image/"))) return;
        if (getRemainingReferenceSlots() <= 0) {
            setTemporaryErrorStatus(`LIMIT REACHED (${REF_IMAGE_LIMIT}).`);
            return;
        }
        const dims = await readImageDimensions(file);
        const metaExtras = {
            resolution: dims ? `${dims.width}x${dims.height}` : "",
            aspectRatio: dims ? formatAspectRatioFromSize(dims.width, dims.height) : "",
        };
        const base64 = await blobToBase64Async(file);
        await handleExternalBase64Reference(base64, file.type || DEFAULT_IMAGE_MIME, file.name || "reference", metaExtras);
    }

    async function handleRefFiles(fileList) {
        if (!fileList || !fileList.length) return;
        for (const file of Array.from(fileList)) {
            if (getRemainingReferenceSlots() <= 0) break;
            try {
                await handleExternalFileReference(file);
            } catch (err) {
                console.warn("Failed to add reference file", err);
            }
        }
    }

    dropZone.addEventListener("click", () => refInput.click());
    pasteRefBtn.addEventListener("click", async () => {
        try {
            const items = await navigator.clipboard.read();
            let foundImage = false;
            for (const item of items) {
                const type = item.types.find(t => t.startsWith("image/"));
                if (type) {
                    const blob = await item.getType(type);
                    const file = new File([blob], "clipboard-image.png", { type });
                    await handleRefFiles([file]);
                    foundImage = true;
                }
            }
            if (!foundImage) setTemporaryErrorStatus("No image data in clipboard");
        } catch (err) {
            console.error(err);
            setTemporaryErrorStatus("Clipboard access denied");
        }
    });
    ["dragenter", "dragover"].forEach((evt) => {
        dropZone.addEventListener(evt, (e) => { e.preventDefault(); dropZone.classList.add("active"); });
    });
    ["dragleave", "dragend"].forEach((evt) => {
        dropZone.addEventListener(evt, (e) => { e.preventDefault(); dropZone.classList.remove("active"); });
    });
    dropZone.addEventListener("drop", async (e) => {
        e.preventDefault();
        dropZone.classList.remove("active");
        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
            await handleRefFiles(e.dataTransfer.files);
            return;
        }

        const draggedTaskId = e.dataTransfer.getData("application/x-nano-card-id");
        if (draggedTaskId) {
            await addRefSelectionForTask(draggedTaskId);
            return;
        }

        const internalData = e.dataTransfer.getData("application/x-nano-banana-image");
        if (internalData) {
            const parts = internalData.split(",");
            if (parts.length === 2) {
                const mimeMatch = parts[0].match(/:(.*?);/);
                const mimeType = mimeMatch ? mimeMatch[1] : "image/png";
                await handleExternalBase64Reference(parts[1], mimeType, "result_drop.png");
            }
        }
    });
    refInput.addEventListener("change", () => {
        if (refInput.files?.length) {
            handleRefFiles(refInput.files).catch(console.error);
        }
        refInput.value = "";
    });
    clearAllRefsBtn.addEventListener("click", () => {
        clearRefSelections().catch(console.error);
    });

    /* --- Task Execution & Result Rendering --- */
    function cancelTask(taskId) {
        const task = activeTasks.get(taskId);
        if (task && task.controller) {
            task.controller.abort(); 
            activeTasks.delete(taskId);
            renderCancelledCard(null, taskId);
            updateGlobalStatus();
        }
    }
    cancelAllBtn.addEventListener("click", () => {
        if(activeTasks.size === 0) return;
        const mainTasks = Array.from(activeTasks.keys()).filter(taskId => {
            const meta = taskIndex.get(taskId);
            return !meta || meta.listId === MAIN_LIST_ID;
        });
        mainTasks.forEach(taskId => { cancelTask(taskId); });
        updateGlobalStatus();
    });

    function buildSkeletonCardElement(taskId) {
      const meta = taskIndex.get(taskId);
      const runtime = getTaskRuntimeInfo(taskId) || {};
      const card = document.createElement("div");
      card.className = "result-card skeleton";
      card.dataset.taskId = taskId;
      card.dataset.listId = meta?.listId || MAIN_LIST_ID;
      card.dataset.createdAt = String(meta?.timestamp || Date.now());
      const title = document.createElement("div");
      title.className = "result-title";
      const left = document.createElement("span");
      left.textContent = `TASK_${taskId.split('_')[1]}`; 
      const badge = document.createElement("span");
      badge.className = "badge";
      badge.textContent = runtime.badgeText || "QUEUED";
      if (runtime.isRetry) badge.classList.add("retry");
      title.appendChild(left);
      title.appendChild(badge);
      const thumb = document.createElement("div");
      thumb.className = "skeleton-thumb";
      const line = document.createElement("div");
      line.className = "skeleton-line";
      const metaRow = document.createElement("div");
      metaRow.className = "result-meta";
      const hint = document.createElement("span");
      hint.className = "status-text";
      hint.textContent = runtime.statusText || "INITIALIZING...";
      metaRow.appendChild(hint);
      const footer = document.createElement("div");
      footer.className = "skeleton-footer";
      const cancelBtn = document.createElement("button");
      cancelBtn.className = "btn-mini neutral";
      cancelBtn.textContent = "ABORT";
      cancelBtn.onclick = () => cancelTask(taskId);
      footer.appendChild(cancelBtn);
      card.appendChild(title);
      card.appendChild(thumb);
      card.appendChild(line);
      card.appendChild(metaRow);
      card.appendChild(footer);
      return card;
    }

    function createSkeletonCard(taskId, options = {}) {
      const listId = options.listId || MAIN_LIST_ID;
      const timestamp = options.timestamp || Date.now();
      upsertTaskIndexEntry(taskId, {
        listId,
        timestamp,
        type: TASK_TYPES.SKELETON
      });
      setTaskRuntimeInfo(taskId, {
        statusText: "INITIALIZING...",
        badgeText: "QUEUED",
        isRetry: false
      });
            ensureTaskInOrder(taskId, "start");
      renderActivePage({ reason: "skeleton-create" });
      return taskId;
    }

    function updateSkeletonStatus(taskId, statusText, badgeText, isRetry = false) {
        setTaskRuntimeInfo(taskId, { statusText, badgeText, isRetry });
        const card = document.querySelector(`.result-card[data-task-id="${taskId}"]`);
        if (!card) return;
        const badge = card.querySelector(".badge");
        const hint = card.querySelector(".status-text");
        if (badge) {
            badge.textContent = badgeText;
            if (isRetry) badge.classList.add("retry");
            else badge.classList.remove("retry");
        }
        if (hint) hint.textContent = statusText;
    }

    function buildResultCardElement({ taskId, listId, timestamp, meta, prompt, thumbnail, base64 }) {
      const safeMeta = meta || {};
      const mimeType = safeMeta.mimeType || DEFAULT_IMAGE_MIME;
      const extension = safeMeta.extension || mimeTypeToExtension(mimeType);
      const card = document.createElement("div");
      card.className = "result-card";
      card.dataset.taskId = taskId;
      card.dataset.listId = listId;
      card.dataset.createdAt = String(timestamp);
      card.draggable = true;
      card.addEventListener("dragstart", (e) => {
          e.dataTransfer.setData("application/x-nano-card-id", taskId);
          draggingCardId = taskId;
          draggingCardEl = card;
          dragPaginationActive = false;
          setDragHoldState(false);
          e.dataTransfer.setData("application/x-nano-card-sort", taskId);
          e.dataTransfer.effectAllowed = "move";
          recordCardDragOrigin(e, card);
      });
      card.addEventListener("dragend", () => {
          if (draggingCardId === taskId) finalizeCardDrag();
      });

      const thumbWrap = document.createElement("div");
      thumbWrap.className = "thumb-wrap";
      thumbWrap.dataset.taskId = taskId;
      const img = document.createElement("img");
      let finalSrc = null;
      let usedObjectUrl = false;
      if (thumbnail) {
          if (thumbnail instanceof Blob) {
              finalSrc = URL.createObjectURL(thumbnail);
          } else {
              finalSrc = thumbnail;
          }
      }
      if (!finalSrc && base64) {
          try {
              finalSrc = URL.createObjectURL(base64ToBlob(base64, mimeType));
          } catch (err) {
              console.warn("Failed to create object URL from base64", err);
          }
      }
      if (!finalSrc && thumbnail) {
          finalSrc = thumbnail;
      }
      if (typeof finalSrc === "string" && /^https?:\/\//i.test(finalSrc)) {
          if (typeof safeMeta.remoteUrl === "string" && safeMeta.remoteUrl.trim()) {
              finalSrc = null;
          }
      }
      if (finalSrc) {
        img.src = finalSrc;
        if (finalSrc.startsWith("blob:")) {
            usedObjectUrl = true;
            img.dataset.usingObjectUrl = "true";
        } else {
            delete img.dataset.usingObjectUrl;
        }
      } else {
        img.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
        img.style.backgroundColor = "#fee2e2";
        delete img.dataset.usingObjectUrl;
      }
      const runtimeRecord = resultsData.get(taskId);
      if (runtimeRecord) {
          if (runtimeRecord.objectUrl && runtimeRecord.objectUrl !== finalSrc) {
              revokeObjectUrl(runtimeRecord.objectUrl);
          }
          runtimeRecord.objectUrl = usedObjectUrl ? finalSrc : null;
      }

      img.loading = "lazy";
      img.alt = "Draw result";
      if (typeof finalSrc === "string" && /^https?:\/\//i.test(finalSrc)) {
        img.addEventListener("error", () => {
          if (img.dataset.remoteFailed === "true") return;
          img.dataset.remoteFailed = "true";
          img.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
          img.style.backgroundColor = "#fee2e2";
          delete img.dataset.usingObjectUrl;
        });
      }
      img.addEventListener("dragstart", (e) => {
        e.dataTransfer.setData("application/x-nano-card-id", taskId);
        e.dataTransfer.setData("application/x-nano-internal-drag", "true");
        draggingCardId = taskId;
        draggingCardEl = card;
        dragPaginationActive = false;
        setDragHoldState(false);
        e.dataTransfer.effectAllowed = "copyMove";
        const shim = ensureTransparentDragImage();
        if (shim) {
            e.dataTransfer.setDragImage(shim, 0, 0);
        }
        recordCardDragOrigin(e, card);
        });
      img.addEventListener("dragend", () => {
          if (draggingCardId === taskId) finalizeCardDrag();
      });
      thumbWrap.appendChild(img);
      thumbWrap.addEventListener("click", (event) => {
          if (handleCompareCardSelection(taskId, event)) return;
          if (handleEditCardSelection(taskId, event)) return;
          openLightboxByTaskId(taskId);
      });

      const metaEl = document.createElement("div");
      metaEl.className = "result-meta";

      const line1 = document.createElement("div");
      line1.style.display = "flex";
      line1.style.gap = "8px";
      line1.style.alignItems = "center";
      line1.style.fontSize = "11px";
      line1.style.marginBottom = "4px";
      line1.style.flexWrap = "wrap";

      let resText = "";
      if (safeMeta.width && safeMeta.height) {
          resText = `${safeMeta.width}*${safeMeta.height}`;
      } else if (safeMeta.resolution) {
          // Replace x/X with * and try to filter out text labels if simple
          resText = safeMeta.resolution.replace(/[xX]/g, "*");
      }
      
      if (resText) {
          const resSpan = document.createElement("span");
          resSpan.textContent = resText;
          resSpan.style.fontWeight = "600";
          line1.appendChild(resSpan);
      }

      const curExt = (extension || "png").toUpperCase();
      const fmtSpan = document.createElement("span");
      fmtSpan.textContent = curExt;
      fmtSpan.style.opacity = "0.6";
      line1.appendChild(fmtSpan);

      let sizeText = "";
      let bytes = safeMeta.fileSize;
      if (!bytes && base64) {
          bytes = Math.round((base64.length * 3) / 4);
      }
      if (bytes) {
          const kb = bytes / 1024;
          if (kb >= 1024) {
              sizeText = (kb / 1024).toFixed(1) + " MB";
          } else {
              sizeText = Math.round(kb) + " KB";
          }
      }
      
      if (sizeText) {
          const sizeSpan = document.createElement("span");
          sizeSpan.textContent = sizeText;
          sizeSpan.style.opacity = "0.6";
          line1.appendChild(sizeSpan);
      }

      const line2 = document.createElement("div");
      const timeSpan = document.createElement("span");
      timeSpan.className = "timestamp-badge";
      timeSpan.textContent = formatTimestamp(timestamp);
      // Ensure it starts on new line
      timeSpan.style.display = "block"; 
      line2.appendChild(timeSpan);

      metaEl.appendChild(line1);
      metaEl.appendChild(line2);

      const actions = document.createElement("div");
      actions.className = "result-actions";

      const reuseBtn = document.createElement("button");
      reuseBtn.type = "button";
      reuseBtn.className = "btn-mini info";
      reuseBtn.textContent = "REUSE";
      reuseBtn.addEventListener("click", async (event) => {
          const promptOnly = !!event?.metaKey;
          const record0 = resultsData.get(taskId);
  	promptInput.value = (record0?.prompt ?? prompt ?? "");
  	promptInput.dispatchEvent(new Event("input", { bubbles: true }));

          if (promptOnly) return;
  	let refIds = Array.isArray(record0?.refImageIds) ? record0.refImageIds : [];
  	if (!refIds.length) {
    	const stored = await fetchStoredResultRecord(taskId);
    	if (stored) {
      	rememberResultRecord(taskId, {
        	meta: stored.meta || {},
        	prompt: stored.prompt || "",
        	listId: stored.listId || MAIN_LIST_ID,
        	timestamp: stored.timestamp || Date.now(),
        	refImageIds: Array.isArray(stored.refImageIds) ? stored.refImageIds : []
      	});
      	refIds = Array.isArray(stored.refImageIds) ? stored.refImageIds : [];
    	}
  	}

  	await applyReferenceIdsQuietly(refIds);
	});

      const downloadLink = document.createElement("a");
      downloadLink.download = `nano-banana-${taskId}.${extension}`;
      downloadLink.href = "javascript:void(0)";
      downloadLink.addEventListener("click", async (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (dlBtn.disabled) return;
            dlBtn.disabled = true;
            const originalText = dlBtn.textContent;
            dlBtn.textContent = "PREP...";
            try {
                let fullBase64 = await fetchFullBase64(taskId);
                const hadBase64 = !!fullBase64;
                let resolvedMeta = safeMeta;
                let didHydrate = false;
                if (!fullBase64) {
                    try {
                        const hydrated = await hydrateRemoteResultForTask(taskId, {
                            provider: safeMeta.provider,
                            maxAttempts: 2,
                            refresh: false
                        });
                        if (hydrated?.base64) {
                            fullBase64 = hydrated.base64;
                            resolvedMeta = hydrated.meta || resolvedMeta;
                            didHydrate = true;
                        }
                    } catch (remoteErr) {
                        console.error("Remote fetch failed", remoteErr);
                        setTemporaryErrorStatus(remoteErr?.message || "Failed to fetch remote image.");
                        return;
                    }
                }
                if (!fullBase64) {
                    setTemporaryErrorStatus("Image data not found in storage.");
                    return;
                }
                if (resolvedMeta?.mimeType) safeMeta.mimeType = resolvedMeta.mimeType;
                if (resolvedMeta?.extension) safeMeta.extension = resolvedMeta.extension;
                const resolvedExtension = safeMeta.extension || extension;
                downloadLink.download = `nano-banana-${taskId}.${resolvedExtension}`;
                const mime = safeMeta.mimeType || DEFAULT_IMAGE_MIME;
                if (didHydrate) {
                    try {
                        const runtimeRecord = resultsData.get(taskId);
                        const refIds = Array.isArray(runtimeRecord?.refImageIds) ? runtimeRecord.refImageIds : [];
                        const thumbnail = await fetchStoredThumbnail(taskId);
                        await saveResultToDisk(taskId, fullBase64, mime, {
                            prompt: prompt || "",
                            meta: safeMeta,
                            timestamp,
                            listId,
                            taskId,
                            thumbnail,
                            refImageIds: refIds
                        });
                    } catch (diskErr) {
                        console.warn("Folder save failed", diskErr);
                    }
                }
                if (didHydrate && !hadBase64) {
                    renderActivePage({ reason: "remote-save" });
                    setTemporaryStatus("Image cached. Click SAVE again to download.");
                    return;
                }
                const tempLink = document.createElement('a');
                tempLink.href = `data:${mime};base64,${fullBase64}`;
                tempLink.download = `nano-banana-${taskId}.${resolvedExtension}`;
                document.body.appendChild(tempLink);
                tempLink.click();
                document.body.removeChild(tempLink);
            } catch (err) {
                console.error("Download failed", err);
                setTemporaryErrorStatus("Failed to save image.");
            } finally {
                dlBtn.disabled = false;
                dlBtn.textContent = originalText;
            }
        });
      const dlBtn = document.createElement("button");
      dlBtn.type = "button";
      dlBtn.className = "btn-mini";
      dlBtn.textContent = "SAVE";
      downloadLink.appendChild(dlBtn);

      const clearBtn = document.createElement("button");
      clearBtn.type = "button";
      clearBtn.className = "btn-mini danger";
      clearBtn.textContent = "DISCARD";
      clearBtn.addEventListener("click", async (e) => {
        if (!confirmAction(e, "Discard this result permanently?")) return;
        await purgeResultRecord(taskId);
        removeTaskFromOrder(taskId);
        removeTaskIndexEntry(taskId);
        removePendingTask(taskId);
        renderActivePage({ reason: "discard-result" });
      });

      actions.appendChild(reuseBtn);
      actions.appendChild(downloadLink);
      actions.appendChild(clearBtn);

      card.appendChild(thumbWrap);
      card.appendChild(metaEl);
      card.appendChild(actions);
            card.addEventListener("click", (event) => {
                    if (!compareModeState.active && !editSelectionModeState.active) return;
                    if (event.defaultPrevented) return;
                    if (event.target.closest("button") || event.target.closest("a")) return;

                    if (compareModeState.active) {
                        handleCompareCardSelection(taskId, event);
                    } else if (editSelectionModeState.active) {
                         handleEditCardSelection(taskId, event);
                    }
            });

      setCardUnseenState(card, unseenResultIds.has(taskId));
      return card;
    }

    function createCardElementOnly(record) {
      if (!record?.taskId) return null;
      const safeMeta = { ...(record.meta || {}) };
      const mimeType = safeMeta.mimeType || DEFAULT_IMAGE_MIME;
      const extension = safeMeta.extension || mimeTypeToExtension(mimeType);
      safeMeta.mimeType = mimeType;
      safeMeta.extension = extension;
      const card = buildResultCardElement({
        taskId: record.taskId,
        listId: record.listId || MAIN_LIST_ID,
        timestamp: record.timestamp || Date.now(),
        meta: safeMeta,
        prompt: record.prompt || "",
        thumbnail: record.thumbnail || null,
        base64: record.base64 || null
      });
      observeCardMedia(card);
      return card;
    }

    async function renderImageCard(taskId, base64, meta, usedPrompt, options = {}) {
      const {
          isRestoring = false,
          timestamp = Date.now(),
          listId = MAIN_LIST_ID,
          thumbnail: storedThumbnail,
          persistToDb = !isRestoring,
          skipDiskSave = isRestoring,
          refImageIds = []
      } = options;
      const safeMeta = meta || {};
      const mimeType = safeMeta.mimeType || DEFAULT_IMAGE_MIME;
      const extension = safeMeta.extension || mimeTypeToExtension(mimeType);
      safeMeta.mimeType = mimeType;
      safeMeta.extension = extension;

      if (base64 && (!safeMeta.width || !safeMeta.height)) {
          try {
              const dims = await getImageDimensionsFromBase64(base64, mimeType);
              if (dims) {
                  safeMeta.width = dims.width;
                  safeMeta.height = dims.height;
                  safeMeta.resolution = `${dims.width}x${dims.height}`;
                  safeMeta.aspectRatio = formatAspectRatioFromSize(dims.width, dims.height);
              }
          } catch (err) {
              console.warn("Failed to calculate image dimensions", err);
          }
      }

      if (base64 && !safeMeta.fileSize) {
        safeMeta.fileSize = Math.round((base64.length * 3) / 4);
      }
      removePendingTask(taskId);
      let thumbData = storedThumbnail;
      let didGenerateMissingThumbnail = false;
      if (!thumbData) {
          try {
            if (base64){
                thumbData = await generateThumbnail(base64, mimeType);
                didGenerateMissingThumbnail = true;
            }
          } catch (err) {
              console.warn("Thumbnail generation failed", err);
          }
      }

      if (persistToDb) {
          await persistResultRecord({ taskId, base64, meta: safeMeta, prompt: usedPrompt, timestamp, listId, thumbnail: thumbData, refImageIds });
      }

      rememberResultRecord(taskId, { 
        meta: safeMeta, 
        prompt: usedPrompt, 
        timestamp, 
        listId,
        refImageIds
        });

      upsertTaskIndexEntry(taskId, {
        listId,
        timestamp,
        type: TASK_TYPES.RESULT
      });
      taskRuntimeInfo.delete(taskId);
      if (!isRestoring) {
          ensureTaskInOrder(taskId, "start");
      } else {
          syncCardUnseenClass(taskId);
      }
      if (!isRestoring && listId !== REF_LIST_ID) {
          markResultUnseen(taskId);
      }
      renderActivePage({ reason: "result-render" });

      if (!skipDiskSave) {
        saveResultToDisk(taskId, base64, mimeType, { 
            prompt: usedPrompt, 
            meta: safeMeta, 
            timestamp, 
            listId, 
            taskId, 
            thumbnail: thumbData,
            refImageIds
        }).catch((err) => {
            console.error("Disk save failed", err);
            });
        }
        if (isRestoring && didGenerateMissingThumbnail) {
            setTimeout(() => {
                console.log(`Migrating old file: adding thumbnail to ${taskId}`);
                persistResultMetadataSnapshot(taskId);
            }, 500 + Math.random() * 1000); 
        }
        return taskId;
    }

    function generateThumbnail(base64, mimeType = "image/png") {
        return new Promise(async (resolve) => {
            if (!base64) {
                resolve(null);
                return;
            }
            try {
                const res = await fetch(`data:${mimeType};base64,${base64}`);
                const blob = await res.blob();
                const bitmap = await createImageBitmap(blob);
                
                const maxSize = 320; 
                let width = bitmap.width;
                let height = bitmap.height;

                if (width > height) {
                    if (width > maxSize) {
                        height = Math.round(height * (maxSize / width));
                        width = maxSize;
                    }
                } else {
                    if (height > maxSize) {
                        width = Math.round(width * (maxSize / height));
                        height = maxSize;
                    }
                }

                const canvas = document.createElement("canvas");
                canvas.width = width;
                canvas.height = height;
                
                const ctx = canvas.getContext("2d");
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = "high";
                
                ctx.drawImage(bitmap, 0, 0, width, height);
                bitmap.close();
                const dataUrl = canvas.toDataURL("image/webp", 0.8);
                resolve(dataUrl);
            } catch (e) {
                console.warn("Thumbnail gen failed", e);
                resolve(null);
            }
        });
    }

    function formatTimestamp(ts) {
        const date = new Date(ts || Date.now());
        const pad = (n) => n.toString().padStart(2, "0");
        return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}`;
    }

    function mimeTypeToExtension(mimeType = DEFAULT_IMAGE_MIME) {
        if (!mimeType) return "img";
        const normalized = mimeType.toLowerCase();
        if (normalized.includes("png")) return "png";
        if (normalized.includes("jpeg")) return "jpg";
        if (normalized.includes("jpg")) return "jpg";
        if (normalized.includes("webp")) return "webp";
        if (normalized.includes("gif")) return "gif";
        if (normalized.includes("bmp")) return "bmp";
        const parts = normalized.split("/");
        return parts[1] || "img";
    }

    function extensionToMimeType(extension) {
        if (!extension) return DEFAULT_IMAGE_MIME;
        const normalized = extension.toLowerCase().replace(/^\./, "");
        if (normalized === "png") return "image/png";
        if (normalized === "jpg" || normalized === "jpeg") return "image/jpeg";
        if (normalized === "webp") return "image/webp";
        if (normalized === "gif") return "image/gif";
        if (normalized === "bmp") return "image/bmp";
        return DEFAULT_IMAGE_MIME;
    }

    function base64ToBlob(base64, mimeType = "image/png") {
        const binary = atob(base64);
        const len = binary.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary.charCodeAt(i);
        }
        return new Blob([bytes], { type: mimeType });
    }

    function revokeObjectUrl(url) {
        if (typeof url !== "string") return;
        if (!url.startsWith("blob:")) return;
        try {
            URL.revokeObjectURL(url);
        } catch (err) {
            console.warn("Failed to revoke object URL", err);
        }
    }

    function cleanupResultRecord(taskId, cardHint = null, options = {}) {
        if (!taskId) return;
        const {
            keepObserver = false,
            keepRecord = false,
            preserveUnseen = false,
            skipSaveCancel = false,
            skipRecordUrlCleanup = false
        } = options || {};
        if (!skipSaveCancel && typeof cancelledSaveIds !== "undefined") cancelledSaveIds.add(taskId);
        if (!preserveUnseen) markResultSeen(taskId);
        const record = resultsData.get(taskId);
        const card = cardHint || document.querySelector(`.result-card[data-task-id="${taskId}"]`);
        if (card) {
            if (!keepObserver) {
                unobserveCardMedia(card);
            }
            offloadCardMedia(card);
            const img = card.querySelector("img");
            if (img && img.src && img.src.startsWith("blob:")) {
                revokeObjectUrl(img.src);
            }
            if (img) delete img.dataset.usingObjectUrl;
        }
        if (!skipRecordUrlCleanup && record?.objectUrl) {
            revokeObjectUrl(record.objectUrl);
            record.objectUrl = null;
        }
        if (!keepRecord) resultsData.delete(taskId);
    }

    async function purgeResultRecord(taskId, metaOverride = null) {
        if (!taskId) return;
        const runtimeRecord = resultsData.get(taskId);
        const metaCandidate = metaOverride || runtimeRecord?.meta || null;
        cleanupResultRecord(taskId);
        try {
            const db = await openDB();
            await new Promise((resolve, reject) => {
                const tx = db.transaction([STORE_RESULTS, STORE_PAYLOADS], "readwrite");
                const resultStore = tx.objectStore(STORE_RESULTS);
                const payloadStore = tx.objectStore(STORE_PAYLOADS);
                resultStore.delete(taskId);
                if (payloadStore) payloadStore.delete(taskId);
                tx.oncomplete = resolve;
                tx.onerror = () => reject(tx.error);
                tx.onabort = () => reject(tx.error || new Error("Result cleanup transaction aborted"));
            });
        } catch (err) {
            console.warn("Failed to delete stored result record", err);
        }
        let meta = metaCandidate;
        if (!meta) {
            try {
                const stored = await fetchStoredResultRecord(taskId);
                meta = stored?.meta || null;
            } catch (err) {
                console.warn("Failed to load stored metadata for cleanup", err);
            }
        }
        try {
            await deleteResultFiles(taskId, meta || {});
        } catch (err) {
            console.warn("File cleanup failed", err);
        }
    }

    async function updateStoredResult(taskId, patch) {
        try {
            const db = await openDB();
            const tx = db.transaction(STORE_RESULTS, "readwrite");
            const store = tx.objectStore(STORE_RESULTS);
            await new Promise((resolve, reject) => {
                const req = store.get(taskId);
                req.onsuccess = () => {
                    const current = req.result;
                    if (!current) return resolve();
                    store.put({ ...current, ...patch });
                    resolve();
                };
                req.onerror = () => reject(req.error);
            });
        } catch (err) {
            console.warn("Update result failed", err);
        }
    }

    async function hasResultRecord(taskId) {
        if (!taskId) return false;
        try {
            const db = await openDB();
            const tx = db.transaction(STORE_RESULTS, "readonly");
            const store = tx.objectStore(STORE_RESULTS);
            return await new Promise((resolve) => {
                const req = store.get(taskId);
                req.onsuccess = () => resolve(!!req.result);
                req.onerror = () => resolve(false);
            });
        } catch (err) {
            console.warn("Failed to query existing record", err);
            return false;
        }
    }

    async function fetchStoredResultRecord(taskId) {
        if (!taskId) return null;
        try {
            const db = await openDB();
            const tx = db.transaction(STORE_RESULTS, "readonly");
            const store = tx.objectStore(STORE_RESULTS);
            return await new Promise((resolve) => {
                const req = store.get(taskId);
                req.onsuccess = () => resolve(req.result || null);
                req.onerror = () => resolve(null);
            });
        } catch (err) {
            console.warn("Stored result lookup failed", err);
            return null;
        }
    }

    function sanitizeRefImageIds(ids) {
        if (!Array.isArray(ids)) return [];
        return ids
            .map(id => (typeof id === "string" ? id.trim() : ""))
            .filter(Boolean);
    }

    async function ensureSerializableThumbnail(thumbnail) {
        if (!thumbnail) return null;
        if (typeof thumbnail === "string") {
            const trimmed = thumbnail.trim();
            if (!trimmed || /^blob:/i.test(trimmed)) return null;
            return trimmed;
        }
        if (typeof Blob !== "undefined" && thumbnail instanceof Blob) {
            try {
                const base64 = await blobToBase64Async(thumbnail);
                if (!base64) return null;
                const mime = thumbnail.type || "image/webp";
                return `data:${mime};base64,${base64}`;
            } catch (err) {
                console.warn("Thumbnail serialization failed", err);
                return null;
            }
        }
        return null;
    }

    async function buildMetadataPayloadForDisk(taskId, payload = {}) {
        const safeTaskId = taskId || payload?.taskId;
        const safeMeta = { ...(payload?.meta || {}) };
        const mimeType = safeMeta.mimeType || DEFAULT_IMAGE_MIME;
        safeMeta.mimeType = mimeType;
        safeMeta.extension = safeMeta.extension || mimeTypeToExtension(mimeType);
        const numericTimestamp = typeof payload?.timestamp === "number"
            ? payload.timestamp
            : Number(payload?.timestamp);
        const safeTimestamp = Number.isFinite(numericTimestamp) ? numericTimestamp : Date.now();
        const safeListId = (typeof payload?.listId === "string" && payload.listId.trim()) ? payload.listId : MAIN_LIST_ID;
        const safePayload = {
            taskId: safeTaskId,
            prompt: typeof payload?.prompt === "string" ? payload.prompt : "",
            meta: safeMeta,
            timestamp: safeTimestamp,
            listId: safeListId,
            refImageIds: sanitizeRefImageIds(payload?.refImageIds)
        };
        safePayload.thumbnail = await ensureSerializableThumbnail(payload?.thumbnail);
        return safePayload;
    }

    async function writeMetadataFile(taskId, payload) {
        const safePayload = await buildMetadataPayloadForDisk(taskId, payload || {});
        const fileBase = `nano-${taskId}`;
        const metaHandle = await workingDirectoryHandle.getFileHandle(`${fileBase}.json`, { create: true });
        const writableMeta = await metaHandle.createWritable();
        await writableMeta.write(JSON.stringify(safePayload, null, 2));
        await writableMeta.close();
    }

    const saveQueue = [];
    let isSaving = false;
    const cancelledSaveIds = new Set();

    async function processSaveQueue() {
        if (isSaving) return;
        isSaving = true;
        while (saveQueue.length > 0) {
            const { taskId, base64, mimeType, payload, resolve, reject } = saveQueue.shift();
            if (cancelledSaveIds.has(taskId)) {
                cancelledSaveIds.delete(taskId);
                resolve(); 
                continue;
            }
            try {
                await performDiskSave(taskId, base64, mimeType, payload);
                resolve();
            } catch (err) {
                reject(err);
            }
        }
        isSaving = false;
    }

    async function performDiskSave(taskId, base64, mimeType, payload) {
        if (!folderAccessGranted || !workingDirectoryHandle) {
             throw new Error("Folder access lost");
        }
        try {
            const fileBase = `nano-${taskId}`;
            const extension = mimeTypeToExtension(mimeType);
            const imageHandle = await workingDirectoryHandle.getFileHandle(`${fileBase}.${extension}`, { create: true });
            const writableImg = await imageHandle.createWritable();
            
            let blob;
            if (base64 instanceof Blob) {
                blob = base64;
            } else {
                 try {
                     const res = await fetch(`data:${mimeType};base64,${base64}`);
                     blob = await res.blob();
                 } catch (e) {
                     blob = base64ToBlob(base64, mimeType);
                 }
            }
            
            await writableImg.write(blob);
            await writableImg.close();
            await writeMetadataFile(taskId, payload);
        } catch (err) {
            if (err.name === "NotAllowedError") {
                 handleFolderAccessError("Save failed, please re-authorize");
            }
            throw err;
        }
    }

    function saveResultToDisk(taskId, base64, mimeType, payload) {
        if (!folderAccessGranted || !workingDirectoryHandle) {
            showFolderOverlay();
            return Promise.reject(new Error("No folder access"));
        }
        return new Promise((resolve, reject) => {
            saveQueue.push({ taskId, base64, mimeType, payload, resolve, reject });
            processSaveQueue();
        });
    }

    async function persistResultMetadataSnapshot(taskId, recordOverride = null) {
        if (!folderAccessGranted || !workingDirectoryHandle) return;
        const record = recordOverride || resultsData.get(taskId);
        if (!record) return;
        let thumbData = recordOverride?.thumbnail || null;
        if (!thumbData) {
            thumbData = await fetchStoredThumbnail(taskId);
        }
        const payload = {
            prompt: record.prompt || "",
            meta: record.meta || {},
            timestamp: record.timestamp || Date.now(),
            listId: record.listId || MAIN_LIST_ID,
            taskId,
            thumbnail: thumbData || null,
            refImageIds: Array.isArray(record.refImageIds) ? record.refImageIds : []
        };
        try {
            await writeMetadataFile(taskId, payload);
        } catch (err) {
            if (err?.name === "NotAllowedError") {
                handleFolderAccessError("Re-authorize the output directory");
            } else {
                console.warn("Metadata sync failed", err);
            }
        }
    }

    async function fetchStoredThumbnail(taskId) {
        if (!taskId) return null;
        try {
            const db = await openDB();
            const tx = db.transaction(STORE_RESULTS, "readonly");
            const store = tx.objectStore(STORE_RESULTS);
            return await new Promise((resolve) => {
                const req = store.get(taskId);
                req.onsuccess = () => resolve(req.result?.thumbnail || null);
                req.onerror = () => resolve(null);
            });
        } catch (err) {
            console.warn("Thumbnail lookup failed", err);
            return null;
        }
    }

    async function deleteResultFiles(taskId, meta = {}) {
        if (!folderAccessGranted || !workingDirectoryHandle || typeof workingDirectoryHandle.removeEntry !== "function") return;
        const fileBase = `nano-${taskId}`;
        const targets = new Set([`${fileBase}.json`]);
        if (meta?.extension) {
            targets.add(`${fileBase}.${meta.extension}`);
        } else {
            DISK_IMAGE_EXTENSIONS.forEach(ext => targets.add(`${fileBase}.${ext}`));
        }
        for (const name of targets) {
            try {
                await workingDirectoryHandle.removeEntry(name);
            } catch (err) {
                if (err?.name === "NotFoundError") continue;
                if (err?.name === "NotAllowedError") {
                    handleFolderAccessError("Re-authorize the output directory");
                    break;
                }
                console.warn(`Failed to delete file: ${name}`, err);
            }
        }
    }

    function isResultMetadataFile(name = "") {
        const lower = name.toLowerCase();
        return lower.startsWith("nano-") && lower.endsWith(".json");
    }

    function extractTaskIdFromFileName(name = "") {
        return name.replace(/\.json$/i, "").replace(/^nano-/, "");
    }

    function buildCandidateExtensions(primary) {
        const candidates = [];
        const normalized = (primary || "").replace(/^\./, "");
        if (normalized) candidates.push(normalized);
        DISK_IMAGE_EXTENSIONS.forEach(ext => {
            if (!candidates.some(item => item.toLowerCase() === ext)) {
                candidates.push(ext);
            }
        });
        return candidates;
    }

    async function readImagePayloadFromDisk(taskId, storedMeta = {}) {
        if (!workingDirectoryHandle) return null;
        const baseName = `nano-${taskId}`;
        const candidates = buildCandidateExtensions(storedMeta?.extension);
        for (const ext of candidates) {
            try {
                const fileHandle = await workingDirectoryHandle.getFileHandle(`${baseName}.${ext}`);
                const file = await fileHandle.getFile();
                const base64 = await blobToBase64Async(file);
                const mimeType = file.type || storedMeta?.mimeType || extensionToMimeType(ext);
                return {
                    base64,
                    meta: { ...(storedMeta || {}), mimeType, extension: ext }
                };
            } catch (err) {
                if (err?.name === "NotFoundError") continue;
                if (err?.name === "NotAllowedError") {
                    handleFolderAccessError("Re-authorize access to the output directory");
                    return null;
                }
                console.warn("Failed to read local image", err);
            }
        }
        return null;
    }

    const INLINE_THUMBNAIL_PATTERN = /^data:image\/[a-z0-9.+-]+;base64,/i;

    function isInlineThumbnailContent(value) {
        if (typeof value !== "string") return false;
        const trimmed = value.trim();
        if (!trimmed) return false;
        return INLINE_THUMBNAIL_PATTERN.test(trimmed) && trimmed.length > 300;
    }

    async function repairDiskThumbnailFromImage(taskId, payload = {}, imagePayload = {}) {
        if (!taskId || !imagePayload?.base64) return null;
        try {
            const mergedMeta = {
                ...(payload?.meta || {}),
                ...(imagePayload?.meta || {})
            };
            const mimeType = mergedMeta.mimeType || imagePayload?.meta?.mimeType || DEFAULT_IMAGE_MIME;
            mergedMeta.mimeType = mimeType;
            mergedMeta.extension = mergedMeta.extension || mimeTypeToExtension(mimeType);
            const regeneratedThumbnail = await generateThumbnail(imagePayload.base64, mimeType);
            if (!regeneratedThumbnail) return null;
            const patchedPayload = {
                ...payload,
                taskId,
                meta: mergedMeta,
                thumbnail: regeneratedThumbnail
            };
            await writeMetadataFile(taskId, patchedPayload);
            return { thumbnail: regeneratedThumbnail, meta: mergedMeta };
        } catch (err) {
            console.warn("Thumbnail metadata repair failed", err);
            return null;
        }
    }

    async function readResultFromDisk(jsonHandle, fileName) {
        try {
            const file = await jsonHandle.getFile();
            const text = await file.text();
            if (!text.trim()) return null;
            const payload = JSON.parse(text || "{}");
            const taskId = payload?.taskId || extractTaskIdFromFileName(fileName);
            
            if (!taskId) return null;
            if (resultsData.has(taskId) && !activeTasks.has(taskId)) return null;
            
            let base64 = null;
            let meta = payload.meta || {};
            let thumbnail = payload.thumbnail;
            const hasStoredThumbnail = typeof thumbnail !== "undefined" && thumbnail !== null;
            const isThumbnailValid = isInlineThumbnailContent(thumbnail);

            if (!isThumbnailValid) {
                if (hasStoredThumbnail) {
                    console.debug(`Repairing invalid thumbnail for ${taskId}, rehydrating from disk source.`);
                }
                const imagePayload = await readImagePayloadFromDisk(taskId, payload?.meta);
                if (!imagePayload) return null;
                base64 = imagePayload.base64;
                meta = imagePayload.meta;
                const repairResult = await repairDiskThumbnailFromImage(taskId, payload, imagePayload);
                if (repairResult?.thumbnail) {
                    thumbnail = repairResult.thumbnail;
                    meta = repairResult.meta || meta;
                } else {
                    thumbnail = null;
                }
            }

            return {
                taskId,
                base64: base64,
                meta: meta,
                prompt: payload?.prompt || "",
                timestamp: payload?.timestamp || Date.now(),
                listId: payload?.listId || MAIN_LIST_ID,
                thumbnail: thumbnail,
                refImageIds: Array.isArray(payload?.refImageIds) ? payload.refImageIds : []
            };
        } catch (err) {
            console.warn("Failed to parse local records", err);
            return null;
        }
    }

    const DISK_SYNC_BATCH_SIZE = 50;

    function normalizeDiskRecord(record) {
        if (!record?.taskId) return null;
        const safeMeta = { ...(record.meta || {}) };
        const mimeType = safeMeta.mimeType || DEFAULT_IMAGE_MIME;
        const extension = safeMeta.extension || mimeTypeToExtension(mimeType);
        safeMeta.mimeType = mimeType;
        safeMeta.extension = extension;
        return {
            taskId: record.taskId,
            base64: record.base64 || null,
            prompt: record.prompt || "",
            timestamp: record.timestamp || Date.now(),
            listId: record.listId || MAIN_LIST_ID,
            thumbnail: record.thumbnail || null,
            meta: safeMeta,
            refImageIds: Array.isArray(record.refImageIds) ? record.refImageIds : []
        };
    }

    async function filterExistingDiskRecords(records = []) {
        const validRecords = records.filter((record) => record?.taskId);
        if (!validRecords.length) return [];
        try {
            const db = await openDB();
            return await new Promise((resolve) => {
                const tx = db.transaction(STORE_RESULTS, "readonly");
                const store = tx.objectStore(STORE_RESULTS);
                const includeFlags = new Array(validRecords.length).fill(false);
                let settled = false;
                const finish = (result) => {
                    if (settled) return;
                    settled = true;
                    resolve(result);
                };
                tx.oncomplete = () => {
                    const filtered = validRecords.filter((_, idx) => includeFlags[idx]);
                    finish(filtered);
                };
                tx.onabort = () => {
                    console.warn("Result existence check aborted", tx.error);
                    finish(validRecords);
                };
                tx.onerror = () => {
                    console.warn("Result existence check failed", tx.error);
                    finish(validRecords);
                };
                validRecords.forEach((record, index) => {
                    const req = store.get(record.taskId);
                    req.onsuccess = () => {
                        includeFlags[index] = !req.result;
                    };
                    req.onerror = () => {
                        includeFlags[index] = true;
                    };
                });
            });
        } catch (err) {
            console.warn("Batch existence check failed", err);
            return validRecords;
        }
    }

    async function persistRecordsBatch(records = []) {
        const validRecords = records.filter((record) => record?.taskId);
        if (!validRecords.length) return true;
        try {
            const db = await openDB();
            const tx = db.transaction([STORE_RESULTS, STORE_PAYLOADS], "readwrite");
            const resultStore = tx.objectStore(STORE_RESULTS);
            const payloadStore = tx.objectStore(STORE_PAYLOADS);
            validRecords.forEach((record) => {
                const { base64, ...metaRecord } = record;
                resultStore.put(metaRecord);
                if (base64) {
                    payloadStore.put({ taskId: record.taskId, base64 });
                }
            });
            await new Promise((resolve, reject) => {
                tx.oncomplete = resolve;
                tx.onerror = () => reject(tx.error);
                tx.onabort = () => reject(tx.error);
            });
            return true;
        } catch (err) {
            console.error("Batch save result failed", err);
            return false;
        }
    }

    async function processResultBatch(batchHandles = [], context = {}) {
        const { canRenderImmediately = false, foundListIds } = context;
        if (!Array.isArray(batchHandles) || !batchHandles.length) {
            return { imported: 0, rendered: 0, stagedReload: false };
        }
        const rawRecords = await Promise.all(
            batchHandles.map(({ handle, name }) => readResultFromDisk(handle, name))
        );
        const normalized = rawRecords.map(normalizeDiskRecord).filter(Boolean);
        if (!normalized.length) {
            return { imported: 0, rendered: 0, stagedReload: false };
        }
        const deduped = [];
        const seenTaskIds = new Set();
        normalized.forEach((record) => {
            if (seenTaskIds.has(record.taskId)) return;
            seenTaskIds.add(record.taskId);
            deduped.push(record);
        });
        deduped.forEach((record) => {
            if (record.listId && foundListIds) {
                foundListIds.add(record.listId);
            }
        });

        const newRecords = await filterExistingDiskRecords(deduped);
        if (!newRecords.length) {
            return { imported: 0, rendered: 0, stagedReload: false };
        }

        const persisted = await persistRecordsBatch(newRecords);
        if (!persisted) {
            return { imported: 0, rendered: 0, stagedReload: false };
        }

        return { imported: newRecords.length, rendered: 0, stagedReload: false };
    }

    async function syncResultsFromDirectory() {
        if (!folderAccessGranted || !workingDirectoryHandle || typeof workingDirectoryHandle.entries !== "function") return;
        if (diskSyncPromise) return diskSyncPromise;

        diskSyncPromise = (async () => {

            await loadCardOrderFromDisk(true);
            
            let imported = 0;
            const canRenderImmediately = false;
            const foundListIds = new Set(); 
            if (listConfig.lists.has(MAIN_LIST_ID)) foundListIds.add(MAIN_LIST_ID);
            const batchHandles = [];
            const flushBatch = async () => {
                if (!batchHandles.length) return;
                const stats = await processResultBatch(batchHandles.splice(0, batchHandles.length), {
                    canRenderImmediately,
                    foundListIds
                });
                imported += stats.imported;
            };

            try {
                for await (const [name, handle] of workingDirectoryHandle.entries()) {
                    if (handle?.kind !== "file") continue;
                    if (!isResultMetadataFile(name)) continue;
                    batchHandles.push({ name, handle });
                    if (batchHandles.length >= DISK_SYNC_BATCH_SIZE) {
                        await flushBatch();
                    }
                }
                await flushBatch();

                let configChanged = false;
                foundListIds.forEach(id => {
                    if (!listConfig.lists.has(id)) {
                        const newName = id.startsWith('list_') 
                            ? `Recovered List ${id.slice(-4)}`
                            : `List ${id}`; 
                        
                        listConfig.lists.set(id, { id, name: newName, locked: false });
                        configChanged = true;
                    }
                });
                
                if (configChanged) {
                    saveListPreferences();
                    renderListTabs();
                }
                await rebuildTaskIndexFromDb();
                await renderActivePage({ reason: "disk-sync" });
            } catch (err) {
                console.warn("Failed to read output directory", err);
                setTemporaryErrorStatus("Failed to read directory, please re-authorize.");
            } finally {
                diskSyncPromise = null;
            }
        })();
        return diskSyncPromise;
    }
    
    function buildFailureCardElement(options = {}) {
      const {
          taskId,
          errorMessage = "Task failed.",
          retryHandler,
          allowReuse = false,
          listId = MAIN_LIST_ID,
          timestamp = Date.now()
      } = options;
      const card = document.createElement("div");
      card.className = "result-card";
      card.dataset.taskId = taskId;
      card.dataset.listId = listId || MAIN_LIST_ID;
      card.dataset.createdAt = String(timestamp || Date.now());
      const title = document.createElement("div");
      title.className = "result-title";
      const left = document.createElement("span");
      left.textContent = `FAILURE`;
      const badge = document.createElement("span");
      badge.className = "badge";
      badge.style.background = "#fee2e2";
      badge.style.color = "#b91c1c";
      badge.textContent = "ERR";
      title.appendChild(left);
      title.appendChild(badge);
      const msg = document.createElement("div");
      msg.className = "small-text";
      msg.style.color = "#b91c1c";
      msg.style.wordBreak = "break-all";
      msg.textContent = errorMessage || "Unknown Error";
      const footer = document.createElement("div");
      footer.className = "result-actions";
      if (allowReuse) {
          const reuseBtn = document.createElement("button");
          reuseBtn.type = "button";
          reuseBtn.className = "btn-mini info";
          reuseBtn.textContent = "REUSE";
          reuseBtn.addEventListener("click", (event) => applyPendingTaskToForm(taskId, { promptOnly: event.metaKey }));
          footer.appendChild(reuseBtn);
      }
      const disposeFailureCard = () => {
        cleanupResultRecord(taskId, card);
        removeTaskFromOrder(taskId);
        removeTaskIndexEntry(taskId);
        taskRuntimeInfo.delete(taskId);
        renderActivePage({ reason: "failure-dispose" });
      };

      if (typeof retryHandler === "function") {
          const retryBtn = document.createElement("button");
          retryBtn.type = "button";
          retryBtn.className = "btn-mini";
          retryBtn.textContent = "RETRY";
          retryBtn.addEventListener("click", () => {
              const scheduled = retryHandler();
              if (!scheduled) return;
              disposeFailureCard();
          });
          footer.appendChild(retryBtn);
      }
      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.className = "btn-mini danger";
      removeBtn.textContent = "DISCARD";
      removeBtn.addEventListener("click", (e) => {
        if (!confirmAction(e, "Discard this error card?")) return;
        disposeFailureCard();
        removePendingTask(taskId);
      });
      footer.appendChild(removeBtn);
      card.appendChild(title);
      card.appendChild(msg);
      card.appendChild(footer);
      return card;
    }

        function renderCancelledCard(cardElement, taskId) {
            const pendingRecord = getPendingTaskRecord(taskId);
            const reuseSnapshot = buildReusableTaskSnapshot(pendingRecord);
            const listId = cardElement?.dataset?.listId || pendingRecord?.listId || taskIndex.get(taskId)?.listId || MAIN_LIST_ID;
            const timestamp = Date.now();
      upsertTaskIndexEntry(taskId, {
        listId,
        timestamp,
        type: TASK_TYPES.FAILURE
      });
      setTaskRuntimeInfo(taskId, {
        status: "cancelled",
        errorMessage: "Task terminated by user.",
        listId,
                timestamp,
                allowReuse: !!reuseSnapshot,
                reuseSnapshot
      });
            ensureTaskInOrder(taskId, "start");
      removePendingTask(taskId);
      renderActivePage({ reason: "cancelled" });
    }

    function buildCancelledCardElement(options = {}) {
            const { taskId } = options;
            const runtime = getTaskRuntimeInfo(taskId) || {};
            const listId = options.listId || runtime.listId || MAIN_LIST_ID;
            const timestamp = options.timestamp || runtime.timestamp || Date.now();
      const card = document.createElement("div");
      card.className = "result-card";
      card.style.opacity = "0.7";
      card.dataset.taskId = taskId;
      card.dataset.listId = listId;
      card.dataset.createdAt = String(timestamp);
      const title = document.createElement("div");
      title.className = "result-title";
      title.innerHTML = `<span>ABORTED</span><span class="badge cancel">CANCEL</span>`;
      const msg = document.createElement("div");
      msg.className = "small-text";
      msg.textContent = "Task terminated by user.";
      const footer = document.createElement("div");
      footer.className = "result-actions";
            if (resolveReusableTaskConfig(taskId)) {
                    const reuseBtn = document.createElement("button");
                    reuseBtn.className = "btn-mini info";
                    reuseBtn.type = "button";
                    reuseBtn.textContent = "REUSE";
                    reuseBtn.addEventListener("click", (event) => applyPendingTaskToForm(taskId, { promptOnly: event.metaKey }));
                    footer.appendChild(reuseBtn);
            }
      const removeBtn = document.createElement("button");
      removeBtn.className = "btn-mini danger";
      removeBtn.textContent = "REMOVE";
      removeBtn.onclick = (e) => { 
        if (!confirmAction(e, "Remove this card?")) return;
        cleanupResultRecord(taskId, card);
        removeTaskFromOrder(taskId);
        removeTaskIndexEntry(taskId);
                removePendingTask(taskId);
        taskRuntimeInfo.delete(taskId);
        renderActivePage({ reason: "cancelled-remove" });
      };
      footer.appendChild(removeBtn);
      card.appendChild(title);
      card.appendChild(msg);
      card.appendChild(footer);
      return card;
    }

    function renderErrorCard(taskId, error, canRetryFunc) {
      const failureRecord = markPendingTaskFailed(taskId, error?.message || "Unknown Error");
      const listId = failureRecord?.listId || taskIndex.get(taskId)?.listId || MAIN_LIST_ID;
      const retryHandler = () => retryPendingTask(taskId, canRetryFunc);
      upsertTaskIndexEntry(taskId, {
          listId,
          timestamp: failureRecord?.createdAt || Date.now(),
          type: TASK_TYPES.FAILURE
      });
      setTaskRuntimeInfo(taskId, {
          errorMessage: failureRecord?.errorMessage || error?.message || "Unknown Error",
          allowReuse: !!failureRecord,
          listId,
          timestamp: failureRecord?.createdAt || Date.now()
      });
            ensureTaskInOrder(taskId, "start");
      renderActivePage({ reason: "error-card" });
    }

    /* --- Generation Logic --- */
    async function loadReferencePayload(entry) {
        if (!entry) return null;
        const sourceId = entry.sourceId || entry.id || "";
        if (!sourceId) return null;
        const base64 = await fetchFullBase64(sourceId);
        if (!base64) return null;
        let mimeType = entry.mimeType;
        if (!mimeType) {
            const record = resultsData.get(sourceId) || await fetchStoredResultRecord(sourceId);
            mimeType = record?.meta?.mimeType || DEFAULT_IMAGE_MIME;
        }
        return { base64, mimeType: mimeType || DEFAULT_IMAGE_MIME };
    }

    async function buildParts(promptText, images) {
      const parts = [];
      if (promptText.trim()) parts.push({ text: promptText.trim() });
      if (images && images.length) {
        for (const img of images.slice(0, REF_IMAGE_LIMIT)) {
            try {
                const payload = await loadReferencePayload(img);
                if (payload?.base64) {
                    parts.push({ inlineData: { mimeType: payload.mimeType, data: payload.base64 } });
                }
            } catch (err) {
                console.warn("Failed to load reference payload", err);
            }
        }
      }
      return parts;
    }

    function getFalImageSize(aspectRatio, resolutionMode) {
        // Parse aspect ratio
        let w = 1, h = 1;
        if (aspectRatio) {
             const parts = aspectRatio.split(":");
             if (parts.length === 2) {
                 w = parseFloat(parts[0]) || 1;
                 h = parseFloat(parts[1]) || 1;
             }
        }
        const ratio = w / h;
        
        // Set baseline pixel count (Base Pixels)
        // 1K mode: target ~1MP (SDXL standard recommendation). 16:9 -> ~1344x768
        let targetPixels = 1024 * 1024; 
        
        // 2K mode: target ~2.4MP. 16:9 -> ~2048x1152
        // This is the best high-res size typically supported by Turbo models
        if (resolutionMode === "2K") targetPixels = 1536 * 1536; 

        // 4K mode: try higher pixel counts (4MP+), but limited by Max Dimension below
        // Without a max dimension, the API can force-crop and break the aspect ratio
        if (resolutionMode === "4K") targetPixels = 2048 * 2048; 

        // Compute theoretical width/height
        let width = Math.sqrt(targetPixels * ratio);
        let height = width / ratio;

        // [Key fix] Max dimension limit
        // Fal/SDXL Turbo models usually hard-limit at 2048 pixels
        // If any requested side exceeds 2048, the API can reset width and break the ratio (e.g., 4:3)
        // So we proactively scale down within 2048 while preserving the ratio
        const MAX_DIM = 2048; 
        
        if (width > MAX_DIM) {
            width = MAX_DIM;
            height = width / ratio;
        }
        if (height > MAX_DIM) {
            height = MAX_DIM;
            width = height * ratio;
        }

        // Align to 32 (UNet compatibility)
        width = Math.round(width / 32) * 32;
        height = Math.round(height / 32) * 32;
        
        return { width, height };
    }

    async function buildGenerationRequestBody(promptText, images, resolution, aspectRatio, provider) {
        const normalizedProvider = normalizeProvider(provider);
        if (normalizedProvider === "fal") {
            const payload = {
                prompt: promptText,
                sync_mode: true,
                enable_safety_checker: false,
                num_images: 1
            };

            // Handle Qwen Models
            if (falModel === "qwen-image") {
                 if (images && images.length) {
                     // Qwen Image Edit (2511) - Requires image_urls array
                     payload.num_inference_steps = 28;
                     payload.guidance_scale = 4.5;
                     try {
                        const refImg = images[0];
                        const refPayload = await loadReferencePayload(refImg);
                        if (refPayload && refPayload.base64) {
                            payload.image_urls = [`data:${refPayload.mimeType};base64,${refPayload.base64}`];
                        }
                    } catch (e) {
                        console.warn("Failed to load ref for fal qwen", e);
                    }
                 } else {
                     // Qwen Image Gen (2512)
                     payload.num_inference_steps = 28;
                     payload.guidance_scale = 4.0;
                     payload.image_size = getFalImageSize(aspectRatio, resolution);
                 }
                 return JSON.stringify(payload);
            }
            
            // Default (Z-Image Turbo)
            payload.num_inference_steps = 8;
            payload.image_size = getFalImageSize(aspectRatio, resolution);

            if (images && images.length) {
                try {
                    const refImg = images[0];
                    const refPayload = await loadReferencePayload(refImg);
                    if (refPayload && refPayload.base64) {
                        payload.image_url = `data:${refPayload.mimeType};base64,${refPayload.base64}`;
                        // We will detect presence of image_url in executeTask to switch endpoint
                        // strength default is 0.6
                        payload.strength = 0.6; 
                    }
                } catch (e) {
                    console.warn("Failed to load ref for fal", e);
                }
            }
            return JSON.stringify(payload);
        }
        const parts = await buildParts(promptText, images);
        const generationConfig = {
            imageConfig: { imageSize: resolution },
            responseModalities: ["TEXT", "IMAGE"]
        };
        if (aspectRatio) generationConfig.imageConfig.aspectRatio = aspectRatio;
        return JSON.stringify({
            contents: [{ role: "user", parts }],
            generationConfig
        });
    }

    function normalizeResourceUrl(resource = "", provider) {
        if (!resource) return null;
        if (/^https?:\/\//i.test(resource)) return resource;
        const trimmed = resource.replace(/^\/+/, "");
        const normalized = normalizeProvider(provider);
        const providerConfig = PROVIDER_CONFIGS[normalized];
        const baseUrl = providerConfig?.resourceBase || PROVIDER_CONFIGS.google.resourceBase;
        if (trimmed.startsWith("v1beta/")) {
            return `${baseUrl}/${trimmed}`;
        }
        return `${baseUrl}/v1beta/${trimmed}`;
    }

    function ensureAltMedia(url) {
        if (!url) return null;
        if (url.includes("alt=media")) return url;
        const separator = url.includes("?") ? "&" : "?";
        return `${url}${separator}alt=media`;
    }

    function blobToBase64Async(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onerror = () => reject(reader.error);
            reader.onloadend = () => {
                const result = reader.result;
                if (typeof result === "string") {
                    resolve(result.split(",")[1] || "");
                } else {
                    resolve("");
                }
            };
            reader.readAsDataURL(blob);
        });
    }

    function sanitizeImageUrlCandidate(url) {
        if (!url || typeof url !== "string") return "";
        let cleaned = url.trim();
        if (cleaned.startsWith("<") && cleaned.endsWith(">")) {
            cleaned = cleaned.slice(1, -1).trim();
        }
        cleaned = cleaned.replace(/[)\],.]+$/g, "");
        cleaned = cleaned.replace(/["']+$/g, "");
        return cleaned;
    }

    function extractImageUrlFromText(text) {
        if (!text || typeof text !== "string") return "";
        const markdownMatch = text.match(/!\[[^\]]*\]\(\s*<?(https?:\/\/[^\s)>]+)>?(?:\s+["'][^"']*["'])?\s*\)/i);
        if (markdownMatch && markdownMatch[1]) return sanitizeImageUrlCandidate(markdownMatch[1]);
        const extMatch = text.match(/https?:\/\/[^\s"'()<>]+?\.(?:png|jpe?g|webp|gif|bmp)(?:\?[^\s"'()<>]*)?/i);
        if (extMatch && extMatch[0]) return sanitizeImageUrlCandidate(extMatch[0]);
        const fallbackMatch = text.match(/https?:\/\/[^\s"'()<>]+/i);
        return fallbackMatch ? sanitizeImageUrlCandidate(fallbackMatch[0]) : "";
    }

    function inferMimeTypeFromUrl(url) {
        if (!url) return "";
        const cleaned = url.split("?")[0].split("#")[0];
        const ext = getFileExtensionFromName(cleaned);
        return ext ? extensionToMimeType(ext) : "";
    }

    async function fetchImageUrlAsBase64(url, provider, apiKey) {
        if (!url) return null;
        const normalizedProvider = normalizeProvider(provider);
        if (/^data:/i.test(url)) {
            const [meta, data] = url.split(",", 2);
            const mimeMatch = /data:([^;]+)/i.exec(meta || "");
            return { base64: data || "", mimeType: mimeMatch?.[1] || DEFAULT_IMAGE_MIME };
        }
        const requestUrl = normalizedProvider === "google" && /\/v1beta\//i.test(url)
            ? ensureAltMedia(url)
            : url;
        const fetchWithHeaders = async (headers) => {
            const response = await fetch(requestUrl, headers ? { headers, cache: "no-store" } : { cache: "no-store" });
            if (!response.ok) {
                throw new Error(`Image fetch failed: HTTP ${response.status}`);
            }
            const blob = await response.blob();
            const blobType = blob.type || "";
            const inferredMime = inferMimeTypeFromUrl(url);
            const isImageType = blobType.startsWith("image/");
            if (blobType && !isImageType) {
                const isOctetStream = blobType === "application/octet-stream" || blobType === "binary/octet-stream";
                if (!(isOctetStream && inferredMime.startsWith("image/"))) {
                    throw new Error("Image fetch did not return an image.");
                }
            }
            return { base64: await blobToBase64Async(blob), mimeType: isImageType ? blobType : (inferredMime || DEFAULT_IMAGE_MIME) };
        };
        try {
            return await fetchWithHeaders();
        } catch (err) {
            throw err;
        }
    }

    function resetImportDialogFields() {
        if (importPromptInput) importPromptInput.value = "";
        if (importResolutionInput) importResolutionInput.value = "";
        if (importAspectInput) importAspectInput.value = "";
        if (importFilenameEl) importFilenameEl.textContent = "Awaiting file selection";
        if (importConfirmBtn) importConfirmBtn.textContent = "Import";
        if (importPreviewImg) {
            importPreviewImg.removeAttribute("src");
            importPreviewImg.style.display = "none";
        }
    }

    function resolveImportDialog(result) {
        if (importOverlayEl) {
            importOverlayEl.classList.add("hidden");
            importOverlayEl.setAttribute("aria-hidden", "true");
        }
        const resolver = importDialogResolver;
        importDialogResolver = null;
        if (resolver) resolver(result);
        resetImportDialogFields();
    }

    function confirmImportDialog() {
        if (!importDialogResolver) {
            if (importOverlayEl) {
                importOverlayEl.classList.add("hidden");
                importOverlayEl.setAttribute("aria-hidden", "true");
            }
            resetImportDialogFields();
            return;
        }
        resolveImportDialog({
            prompt: importPromptInput?.value || "",
            resolution: importResolutionInput?.value || "",
            aspectRatio: importAspectInput?.value || ""
        });
    }

    function cancelImportDialog() {
        if (!importDialogResolver) {
            if (importOverlayEl) {
                importOverlayEl.classList.add("hidden");
                importOverlayEl.setAttribute("aria-hidden", "true");
            }
            resetImportDialogFields();
            return;
        }
        resolveImportDialog(null);
    }

    function openImportDialog(payload = {}) {
        if (!importOverlayEl) {
            return Promise.resolve({
                prompt: "",
                resolution: payload?.defaults?.resolution || "",
                aspectRatio: payload?.defaults?.aspectRatio || ""
            });
        }
        importOverlayEl.classList.remove("hidden");
        importOverlayEl.setAttribute("aria-hidden", "false");
        if (importFilenameEl) importFilenameEl.textContent = payload?.fileName || "Imported Image";
        if (importConfirmBtn) importConfirmBtn.textContent = payload?.confirmText || "Import";
        if (importPreviewImg) {
            if (payload?.previewUrl) {
                importPreviewImg.src = payload.previewUrl;
                importPreviewImg.style.display = "";
            } else {
                importPreviewImg.removeAttribute("src");
                importPreviewImg.style.display = "none";
            }
        }
        if (importPromptInput) importPromptInput.value = payload?.defaults?.prompt || "";
        if (importResolutionInput) importResolutionInput.value = payload?.defaults?.resolution || "";
        if (importAspectInput) importAspectInput.value = payload?.defaults?.aspectRatio || "";
        setTimeout(() => importPromptInput?.focus(), 0);
        return new Promise((resolve) => {
            importDialogResolver = resolve;
        });
    }

    function getFileExtensionFromName(name = "") {
        const match = /\.([^.]+)$/.exec(name || "");
        return match ? match[1].toLowerCase() : "";
    }

    function isImageFileCandidate(file) {
        if (!file) return false;
        if (file.type && file.type.startsWith("image/")) return true;
        const ext = getFileExtensionFromName(file.name);
        return DISK_IMAGE_EXTENSIONS.some(candidate => candidate.toLowerCase() === ext);
    }

    function formatAspectRatioFromSize(width, height) {
        if (!width || !height) return "";
        const gcd = (a, b) => (b ? gcd(b, a % b) : a);
        const divisor = gcd(width, height) || 1;
        const w = Math.round(width / divisor);
        const h = Math.round(height / divisor);
        return `${w}:${h}`;
    }

    function readImageDimensions(file) {
        return new Promise((resolve) => {
            try {
                const url = URL.createObjectURL(file);
                const img = new Image();
                img.onload = () => {
                    URL.revokeObjectURL(url);
                    resolve({ width: img.naturalWidth || img.width, height: img.naturalHeight || img.height });
                };
                img.onerror = () => {
                    URL.revokeObjectURL(url);
                    resolve(null);
                };
                img.src = url;
            } catch (err) {
                console.warn("Failed to read image dimensions", err);
                resolve(null);
            }
        });
    }

    async function importSingleFile(file) {
        try {
            const base64 = await blobToBase64Async(file);
            if (!base64) throw new Error("Failed to read image");
            const dims = await readImageDimensions(file);
            const defaults = {
                resolution: dims ? `${dims.width}x${dims.height}` : "",
                aspectRatio: dims ? formatAspectRatioFromSize(dims.width, dims.height) : ""
            };
            const previewUrl = URL.createObjectURL(file);
            let dialogResult = null;
            try {
                dialogResult = await openImportDialog({
                    fileName: file.name || "Imported Image",
                    previewUrl,
                    defaults
                });
            } finally {
                URL.revokeObjectURL(previewUrl);
            }
            if (dialogResult === null) return { status: "cancelled" };
            const mimeType = file.type || extensionToMimeType(getFileExtensionFromName(file.name));
            const extension = getFileExtensionFromName(file.name) || mimeTypeToExtension(mimeType);
            const meta = {
                resolution: dialogResult.resolution?.trim() || defaults.resolution || "",
                aspectRatio: dialogResult.aspectRatio?.trim() || defaults.aspectRatio || "",
                mimeType,
                extension,
                source: "import",
                originalName: file.name || ""
            };
            const promptNote = dialogResult.prompt?.trim() || "";
            const taskId = `import-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
            await renderImageCard(taskId, base64, meta, promptNote, { listId: listConfig.active });
            return { status: "success", taskId };
        } catch (err) {
            console.error("Import image failed", err);
            setTemporaryErrorStatus(err?.message || "Import failed");
            return { status: "failed", error: err };
        }
    }

    async function importSingleFileDirect(file) {
        try {
            const base64 = await blobToBase64Async(file);
            if (!base64) throw new Error("Failed to read image");
            const dims = await readImageDimensions(file);
            const resolution = dims ? `${dims.width}x${dims.height}` : "";
            const aspectRatio = dims ? formatAspectRatioFromSize(dims.width, dims.height) : "";
            const mimeType = file.type || extensionToMimeType(getFileExtensionFromName(file.name));
            const extension = getFileExtensionFromName(file.name) || mimeTypeToExtension(mimeType);
            const meta = {
                resolution,
                aspectRatio,
                mimeType,
                extension,
                source: "import",
                originalName: file.name || ""
            };
            const taskId = `import-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
            await renderImageCard(taskId, base64, meta, "", { listId: listConfig.active });
            return { status: "success", taskId };
        } catch (err) {
            console.error("Batch import image failed", err);
            setTemporaryErrorStatus(err?.message || "Import failed");
            return { status: "failed", error: err };
        }
    }

    async function handleManualImageImport(fileList = []) {
        const baseFiles = Array.from(fileList || []).filter(isImageFileCandidate);
        const files = baseFiles;
        if (!files.length) {
            setTemporaryErrorStatus("Please choose an image file to import");
            return;
        }
        for (const file of files) {
            const result = await importSingleFile(file);
            if (result.status === "cancelled") break;
        }
    }

    async function handleBatchImageImport(fileList = []) {
        const files = Array.from(fileList || []).filter(isImageFileCandidate);
        if (!files.length) {
            setTemporaryErrorStatus("Please choose an image file to import");
            return;
        }
        for (const file of files) {
            await importSingleFileDirect(file);
        }
    }

    async function fetchFileUriAsBase64(resource, provider, apiKey) {
        const normalized = normalizeResourceUrl(resource, provider);
        if (!normalized) return null;
        const url = ensureAltMedia(normalized);
        const headers = apiKey ? { "x-goog-api-key": apiKey } : {};
        const resp = await fetch(url, {
            headers
        });
        if (!resp.ok) {
            throw new Error(`File download failed: HTTP ${resp.status}`);
        }
        const blob = await resp.blob();
        return blobToBase64Async(blob);
    }

    async function extractImagePayloadFromParts(parts, provider, apiKey) {
        if (!Array.isArray(parts)) return null;
        let urlCandidate = "";
        for (const part of parts) {
            if (!part) continue;
            const inline = part.inlineData || part.inline_data;
            if (inline?.data) {
                return { base64: inline.data, mimeType: inline.mimeType || inline.mime_type || DEFAULT_IMAGE_MIME };
            }
            if (!urlCandidate && typeof part.text === "string") {
                urlCandidate = extractImageUrlFromText(part.text);
            }
            if (!urlCandidate) {
                const directUrl = part.imageUrl || part.image_url || part.url || part.mediaUrl || part.media_url || part?.media?.url;
                if (typeof directUrl === "string") {
                    urlCandidate = sanitizeImageUrlCandidate(directUrl);
                }
            }
            const media = part.media;
            if (media?.data) {
                return { base64: media.data, mimeType: media.mimeType || DEFAULT_IMAGE_MIME };
            }
            const fileData = part.fileData || part.file_data || media;
            if (fileData?.fileUri || fileData?.file_uri || fileData?.resourceName || fileData?.resource_name) {
                const fileUri = fileData.fileUri || fileData.file_uri || fileData.resourceName || fileData.resource_name;
                try {
                    const base64 = await fetchFileUriAsBase64(fileUri, provider, apiKey);
                    if (base64) {
                        return { base64, mimeType: fileData.mimeType || fileData.mime_type || media?.mimeType || DEFAULT_IMAGE_MIME };
                    }
                } catch (downloadErr) {
                    console.warn("Failed to download generated image", downloadErr);
                    throw downloadErr;
                }
            }
        }
        if (urlCandidate) {
            try {
                return await fetchImageUrlAsBase64(urlCandidate, provider, apiKey);
            } catch (err) {
                console.warn("Failed to fetch image URL payload", err);
            }
        }
        return null;
    }

    async function extractFalImagePayload(data) {
        if (!data || !data.images || !data.images.length) return null;
        const img = data.images[0];
        if (img.url && img.url.startsWith("data:")) {
             const [meta, b64] = img.url.split(",");
             const mime = meta.split(":")[1].split(";")[0];
             return { base64: b64, mimeType: mime };
        }
        if (img.url) {
             try {
                return await fetchImageUrlAsBase64(img.url, "fal", null);
             } catch(err) {
                 return { remoteUrl: img.url, mimeType: img.content_type || "image/png" };
             }
        }
        return null;
    }

    function extractResponseMessage(parts, data) {
        if (Array.isArray(parts)) {
            const textPart = parts.find((p) => typeof p?.text === "string" && p.text.trim());
            if (textPart?.text) return textPart.text.trim();
        }
        const promptFeedback = data?.promptFeedback || data?.prompt_feedback;
        if (promptFeedback?.blockReason || promptFeedback?.block_reason) {
            return `Blocked: ${promptFeedback.blockReason || promptFeedback.block_reason}`;
        }
        if (promptFeedback?.safetyRatings?.length) {
            const categories = promptFeedback.safetyRatings.map((item) => item.category || item.name).filter(Boolean);
            if (categories.length) {
                return `Blocked (${categories.join(", ")})`;
            }
        }
        return "";
    }

    function wait(ms, signal) {
        return new Promise((resolve, reject) => {
            const timer = setTimeout(() => resolve(), ms);
            if (signal) {
                signal.addEventListener('abort', () => {
                    clearTimeout(timer);
                    reject(new DOMException('Aborted', 'AbortError'));
                }, { once: true });
            }
        });
    }

    function getBackoffDelayMs(attemptNumber) {
        if (!attemptNumber || attemptNumber < 1) attemptNumber = 1;
        const seconds = Math.min(64, Math.pow(2, attemptNumber - 1));
        const baseMs = seconds * 1000;
        const jitter = Math.floor(Math.random() * 1001); // 0-1000ms jitter
        return baseMs + jitter;
    }

    function isRetryableError(err) {
        if (!err) return false;
        if (err.isRetryable) return true;
        if (err.name === "TypeError" && err.message === "Failed to fetch") return true;
        const message = (err.message || "").toLowerCase();
        return (
        message.includes("networkerror") || 
        message.includes("failed to fetch") || 
        message.includes("network request failed") ||
        message.includes("connection refused")
       );
    }

    async function executeTask(taskId, config) {
        let { apiKey, prompt, refImagesSnapshot, refImageIds = [], resolution, aspectRatio, enableRetry, maxRetries, provider } = config;
        const normalizedProvider = normalizeProvider(provider || activeProvider);
        const providerConfig = getProviderConfig(normalizedProvider);
        const controller = new AbortController();
        activeTasks.set(taskId, { controller });
        updateGlobalStatus();

        let attempts = 0;
        const totalAttempts = enableRetry ? (1 + maxRetries) : 1;
        const hasReferenceImages = Array.isArray(refImagesSnapshot) && refImagesSnapshot.length > 0;
        let requestBodyCache = null;

        const getRequestBodyForAttempt = async () => {
            if (hasReferenceImages) {
                return buildGenerationRequestBody(prompt, refImagesSnapshot, resolution, aspectRatio, normalizedProvider);
            }
            if (!requestBodyCache) {
                requestBodyCache = await buildGenerationRequestBody(prompt, refImagesSnapshot, resolution, aspectRatio, normalizedProvider);
            }
            return requestBodyCache;
        };

        while (attempts < totalAttempts) {
            if (controller.signal.aborted) break;
            attempts++;
            const isRetrying = attempts > 1;
            const statusText = isRetrying ? `Retrying attempt ${attempts}...` : "Generating content...";
            updateSkeletonStatus(
                taskId, 
                statusText,
                isRetrying ? `RETRY ${attempts-1}` : "RUNNING",
                isRetrying
            );

            try {
                let requestBody;
                try {
                    requestBody = await getRequestBodyForAttempt();
                } catch (payloadErr) {
                    renderErrorCard(taskId, payloadErr, null);
                    break;
                }
                let endpoint = providerConfig.endpoint;
                if (normalizedProvider === "fal" && hasReferenceImages) {
                    endpoint = providerConfig.i2iEndpoint || endpoint;
                }
                const headers = normalizedProvider === "fal"
                    ? { "Content-Type": "application/json", "Authorization": `Key ${apiKey}` }
                    : { "Content-Type": "application/json", "x-goog-api-key": apiKey };
                const fetchPromise = fetch(endpoint, {
                    method: "POST",
                    headers,
                    body: requestBody,
                    signal: controller.signal
                });
                if (hasReferenceImages) {
                    requestBody = null;
                }
                const resp = await fetchPromise;
                if (!resp.ok) {
                    let detail = "";
                    try { const errJson = await resp.json(); detail = errJson.error?.message || JSON.stringify(errJson); } 
                    catch { detail = resp.statusText; }
                    const httpError = new Error(`HTTP ${resp.status}: ${detail}`);
                    const is429 = resp.status === 429;
                    const is5xx = resp.status >= 500 && resp.status < 600;
                    httpError.isRetryable = is429 || is5xx;
                    httpError.statusCode = resp.status;
                    throw httpError;
                }
                const data = await resp.json();
                let imagePayload = null;
                let partsOut = [];
                if (normalizedProvider === "fal") {
                    imagePayload = await extractFalImagePayload(data);
                } else {
                    const candidate = (data.candidates && data.candidates[0]) || data;
                    partsOut = (candidate.content && candidate.content.parts) || candidate.parts || [];
                    imagePayload = await extractImagePayloadFromParts(partsOut, normalizedProvider, apiKey);
                }
                if (!imagePayload?.base64 && !imagePayload?.remoteUrl) {
                    const reason = normalizedProvider === "fal"
                        ? "No image data found in response."
                        : (extractResponseMessage(partsOut, data) || "No image data found in response.");
                    throw new Error(reason);
                }
                const resolvedMimeType = imagePayload?.mimeType || DEFAULT_IMAGE_MIME;
                const resolvedMeta = { resolution, aspectRatio, mimeType: resolvedMimeType, provider: normalizedProvider };
                if (imagePayload?.remoteUrl) resolvedMeta.remoteUrl = imagePayload.remoteUrl;
                renderImageCard(
                    taskId,
                    imagePayload?.base64 || null,
                    resolvedMeta,
                    prompt,
                    {
                        timestamp: Date.now(),
                        listId: MAIN_LIST_ID,
                        refImageIds,
                        skipDiskSave: !imagePayload?.base64
                    }
                );
                break; 
            } catch (err) {
                if (err.name === 'AbortError') break;
                const canRetry = attempts < totalAttempts && isRetryableError(err);
                if (canRetry) {
                    apiKey = getApiKeyManager(normalizedProvider).getNextKey() || apiKey;
                    const delay = getBackoffDelayMs(attempts);
                    let remaining = delay;
                    while (remaining > 0) {
                        if (controller.signal.aborted) break;
                        updateSkeletonStatus(taskId, `Failed (${err.message}). Retrying in ${Math.ceil(remaining/1000)}s...`, "WAITING", true);
                        const step = Math.min(1000, remaining);
                        try { await wait(step, controller.signal); } catch (waitErr) { if (waitErr.name === 'AbortError') break; }
                        remaining -= step;
                    }
                    if (controller.signal.aborted) break;
                } else {
                    renderErrorCard(taskId, err, () => {
                        const newId = `${Date.now()}_${Math.random().toString(36).slice(2)}`;
                        createSkeletonCard(newId, { listId: MAIN_LIST_ID });
                        executeTask(newId, config);
                    });
                    break;
                }
            }
        }
        activeTasks.delete(taskId);
        updateGlobalStatus();
    }

    generateBtn.addEventListener("click", () => {
        generateBtn.style.transform = "scale(0.95)";
        setTimeout(() => generateBtn.style.transform = "", 100);
      const prompt = promptInput.value || "";
      if (!prompt.trim() && !refImages.length) { setTemporaryErrorStatus("Prompt or reference image required."); return; }
      const keys = getApiKeyValues();
      if (!keys.length) { setTemporaryErrorStatus("Please enter at least one API Key."); return; }
      const provider = activeProvider;
      const keyManager = getApiKeyManager(provider);
      keyManager.setKeys(keys);
      if (!requireFolderAccess()) { setTemporaryErrorStatus("Please authorize the output directory first."); return; }

      const count = Number(countInput.value || "1");
      const resolution = resolutionSelect.value;
      const aspectRatio = aspectRatioSelect.value;
      const enableRetry = enableRetryInput.checked;
      const maxRetries = Number(maxRetriesInput.value || 5);

      const refSnapshot = refImages.map(entry => ({
          sourceId: entry.sourceId,
          mimeType: entry.mimeType
      }));
      const refIds = refImages.map(entry => entry.sourceId);
      const configSnapshot = { prompt, refImagesSnapshot: refSnapshot, refImageIds: refIds, resolution, aspectRatio, enableRetry, maxRetries, provider };

      for (let i = 0; i < count; i++) {
          const apiKey = keyManager.getNextKey();
          if (!apiKey) { setTemporaryErrorStatus("API key rotation failed"); break; }
          const taskId = `${Date.now()}_${Math.random().toString(36).slice(2)}`;
          createSkeletonCard(taskId);
          registerPendingTask(taskId, configSnapshot, { listId: MAIN_LIST_ID, createdAt: Date.now(), status: "RUNNING" });
          executeTask(taskId, { ...configSnapshot, apiKey }).catch(console.error);
      }
      updateGlobalStatus();
    });

    promptInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && (e.metaKey || e.ctrlKey)) {
            e.preventDefault();
            if (!generateBtn.disabled) {
                generateBtn.click();
            }
        }
    });

    clearResultsBtn.addEventListener("click", async (e) => {
        const ids = getOrderedTaskIdsForList(MAIN_LIST_ID)
            .filter(taskId => taskIndex.get(taskId)?.type !== TASK_TYPES.SKELETON);
        if (!ids.length) return;
        if (!confirmAction(e, "‚ö†Ô∏è PURGE ALL \n\nDelete all results in the Main list? This cannot be undone.")) return;
        for (const taskId of ids) {
            await purgeResultRecord(taskId);
            removeTaskFromOrder(taskId);
            removeTaskIndexEntry(taskId);
            removePendingTask(taskId);
        }
        renderActivePage({ reason: "clear-main" });
    });

    // --- NEW RESET LOGIC ---
    resetAppBtn.addEventListener("click", async () => {
        if(confirm("‚ö†Ô∏è DANGER ZONE ‚ö†Ô∏è\n\nThis will delete:\n1. API Key & Settings\n2. All Generated Images\n3. All Reference Images\n\nThe app will reset to factory state.")) {
            // 1. Clear Storage
            localStorage.clear();
            sessionStorage.clear();
            resetCardOrderTracking();
            unseenResultIds.clear();
            pendingTaskRecords.clear();
            persistPendingTaskRecords();

            // 2. Close DB connection if open to prevent blocking
            if (dbInstance) {
                dbInstance.close();
                dbInstance = null;
            }

            // 3. Delete IndexedDB
            const req = indexedDB.deleteDatabase(DB_NAME);
            req.onsuccess = () => {
                window.location.reload();
            };
            req.onerror = () => {
                alert("Failed to delete database. Please clear browser data manually.");
                window.location.reload();
            };
            req.onblocked = () => {
                // Force reload if still blocked
                window.location.reload();
            }
        }
    });

	const clearPromptBtn = document.getElementById("clearPromptBtn");
    	if (clearPromptBtn) {
        clearPromptBtn.addEventListener("click", () => {
            if (promptInput) {
                promptInput.value = "";
                promptInput.focus();
                promptInput.dispatchEvent(new Event("input", { bubbles: true }));
            }
        });
    }

    // --- Lightbox Copy Feature ---
    function showCopyToast(msg = "Copied to clipboard", isError = false) {
        let toast = document.createElement("div");
        toast.style.position = "fixed";
        toast.style.bottom = "32px";
        toast.style.left = "50%";
        toast.style.transform = "translateX(-50%) translate(0, 10px)";
        toast.style.backgroundColor = isError ? "rgba(220, 38, 38, 0.9)" : "rgba(15, 23, 42, 0.9)";
        toast.style.color = "#f8fafc";
        toast.style.padding = "8px 16px";
        toast.style.borderRadius = "20px";
        toast.style.fontSize = "13px";
        toast.style.fontWeight = "600";
        toast.style.zIndex = "10001";
        toast.style.fontFamily = "var(--font-sans)";
        toast.style.boxShadow = "0 10px 25px -5px rgba(0, 0, 0, 0.4)";
        toast.style.border = "1px solid rgba(255,255,255,0.15)";
        toast.style.backdropFilter = "blur(12px)";
        toast.style.webkitBackdropFilter = "blur(12px)";
        toast.style.pointerEvents = "none";
        toast.style.opacity = "0";
        toast.style.transition = "opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1), transform 0.2s cubic-bezier(0.4, 0, 0.2, 1)";
        toast.style.whiteSpace = "nowrap";
        
        const icon = isError 
            ? `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>`
            : `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`;

        toast.innerHTML = `<span style="display:inline-flex; align-items:center; gap:6px">${icon} ${msg}</span>`;

        document.body.appendChild(toast);
        
        requestAnimationFrame(() => {
            toast.style.opacity = "1";
            toast.style.transform = "translateX(-50%) translate(0, 0)";
        });

        setTimeout(() => {
            toast.style.opacity = "0";
            toast.style.transform = "translateX(-50%) translate(0, 10px)";
            setTimeout(() => {
                if(toast.parentNode) document.body.removeChild(toast)
            }, 300);
        }, 2500);
    }

    async function copyLightboxImageToClipboard() {
        // Core lookup logic
        const lightbox = document.getElementById("lightbox");
        if (!lightbox) return;
        
        const style = window.getComputedStyle(lightbox);
        const isVisible = style.display !== 'none' && style.opacity !== '0' && style.visibility !== 'hidden';
        if (!isVisible && !lightbox.classList.contains("visible")) return;

        const img = document.getElementById("lightboxImage");
        if (!img || !img.src) return;

        try {
            let blob;
            if (img.src.startsWith("data:")) {
                const parts = img.src.split(",");
                const mimeMatch = parts[0].match(/:(.*?);/);
                const mime = mimeMatch ? mimeMatch[1] : "image/png";
                
                // Convert inline base64 to blob just in case
                const binary = atob(parts[1]);
                const len = binary.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
                blob = new Blob([bytes], { type: mime });
            } else {
                // If it's a blob: or http url
                const resp = await fetch(img.src);
                blob = await resp.blob();
            }

            if (!blob) {
                showCopyToast("Unable to get image data.", true);
                return;
            }

            // Force conversion to PNG to avoid Clipboard API JPEG/WebP limitations
            if (blob.type !== "image/png") {
                 try {
                    const bitmap = await createImageBitmap(blob);
                    const canvas = document.createElement("canvas");
                    canvas.width = bitmap.width;
                    canvas.height = bitmap.height;
                    const ctx = canvas.getContext("2d");
                    ctx.drawImage(bitmap, 0, 0);
                    blob = await new Promise(resolve => canvas.toBlob(resolve, "image/png"));
                    bitmap.close(); 
                 } catch(e) {
                     console.warn("Auto conversion to PNG failed; trying to copy the original format", e);
                 }
            }

            const item = new ClipboardItem({ [blob.type]: blob });
            await navigator.clipboard.write([item]);
            showCopyToast();
        } catch (err) {
            console.error("Failed to copy image", err);
            showCopyToast("Copy failed: " + err.message, true);
        }
    }

    document.addEventListener("keydown", (e) => {
        // Adding capture: true is not required; we want to coexist with existing logic
        // But we need to avoid conflicts with other shortcuts
        if (e.code === "KeyV" && !e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) {
             // Double-check focus is not in an input
            const active = document.activeElement;
            if (active && (active.tagName === "INPUT" || active.tagName === "TEXTAREA" || active.isContentEditable)) return;
            
            // Trigger copy
            copyLightboxImageToClipboard();
        }
    });

/* --- Custom Task Feature Logic --- */
    (function initCustomTaskFeature() {
        const customTaskOverlay = document.getElementById('customTaskOverlay');
        const customEndpointInput = document.getElementById('customEndpoint');
        const payloadListContainer = document.getElementById('payloadList');
        const customTaskSubmitBtn = document.getElementById('customTaskSubmitBtn');
        const customTaskCancelBtn = document.getElementById('customTaskCancelBtn');
        const addPayloadItemBtn = document.getElementById('addPayloadItemBtn');
        const promptInput = document.getElementById("prompt");

        let customPayloadConfig = [];
        const CONFIG_KEY = 'nano_banana_custom_task_config_v2'; 

        const DEFAULT_PAYLOAD_CONFIG = [
            { key: 'prompt', type: 'string', value: '[System Checked]', locked: true },
            { key: 'image_url', type: 'string', value: '[System Checked]', locked: true },
            { key: 'image_size', type: 'json', value: '{"width":1024,"height":1024}', locked: false },
            { key: 'sync_mode', type: 'boolean', value: 'true', locked: false },
            { key: 'num_images', type: 'number', value: '1', locked: false },
            { key: 'output_format', type: 'string', value: 'jpeg', locked: false },
            { key: 'enable_safety_checker', type: 'boolean', value: 'false', locked: false }
        ];

        function loadConfig() {
            try {
                const saved = localStorage.getItem(CONFIG_KEY);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    customEndpointInput.value = parsed.endpoint || '';
                    customPayloadConfig = parsed.payloadConfig || JSON.parse(JSON.stringify(DEFAULT_PAYLOAD_CONFIG));
                    
                    // Migration: Ensure image_size exists if missing from saved config
                    // Also ensure it is type json if it was string 'square_hd' from previous version
                    const sizeEntry = customPayloadConfig.find(p => p.key === 'image_size');
                    if (!sizeEntry) {
                        customPayloadConfig.splice(2, 0, { key: 'image_size', type: 'json', value: '{"width":1024,"height":1024}', locked: false });
                    } else if (sizeEntry.type === 'string' && !sizeEntry.value.includes('{')) {
                         // Convert old string preset to json type for consistency
                         sizeEntry.type = 'json';
                         sizeEntry.value = '{"width":1024,"height":1024}';
                    }

                } else {
                    customPayloadConfig = JSON.parse(JSON.stringify(DEFAULT_PAYLOAD_CONFIG));
                }
            } catch (e) {
                console.warn("Failed to load custom config", e);
                customPayloadConfig = JSON.parse(JSON.stringify(DEFAULT_PAYLOAD_CONFIG));
            }
        }

        function saveConfig() {
            try {
                const config = {
                    endpoint: customEndpointInput.value,
                    payloadConfig: customPayloadConfig
                };
                localStorage.setItem(CONFIG_KEY, JSON.stringify(config));
            } catch (e) {
                console.warn("Failed to save custom config", e);
            }
        }

        function renderList() {
            payloadListContainer.innerHTML = '';
            customPayloadConfig.forEach((item, index) => {
                const row = document.createElement('div');
                row.className = 'api-key-row'; 
                row.style.gridTemplateColumns = '1fr 80px 1fr 30px'; 
                
                const keyInput = document.createElement('input');
                keyInput.type = 'text';
                keyInput.value = item.key;
                keyInput.placeholder = 'Key';
                keyInput.disabled = item.locked;
                keyInput.onchange = (e) => { item.key = e.target.value; saveConfig(); };

                const typeSelect = document.createElement('select');
                typeSelect.style.padding = '4px'; 
                typeSelect.style.height = '32px';
                ['string', 'number', 'boolean', 'json'].forEach(t => {
                    const opt = document.createElement('option');
                    opt.value = t;
                    opt.innerText = t;
                    if (item.type === t) opt.selected = true;
                    typeSelect.appendChild(opt);
                });
                typeSelect.disabled = item.locked; 
                typeSelect.onchange = (e) => { item.type = e.target.value; saveConfig(); };

                const valInput = document.createElement('input');
                valInput.type = 'text';
                valInput.value = item.value;
                valInput.placeholder = 'Value';
                valInput.disabled = item.locked; 
                valInput.onchange = (e) => { item.value = e.target.value; saveConfig(); };

                const delBtn = document.createElement('button');
                delBtn.innerText = '√ó';
                delBtn.className = 'btn-mini danger';
                delBtn.style.padding = '0';
                delBtn.style.height = '30px';
                delBtn.style.width = '30px';
                delBtn.disabled = item.locked;
                delBtn.onclick = () => {
                    if (item.locked) return;
                    customPayloadConfig.splice(index, 1);
                    saveConfig();
                    renderList();
                };

                row.appendChild(keyInput);
                row.appendChild(typeSelect);
                row.appendChild(valInput);
                row.appendChild(delBtn);
                payloadListContainer.appendChild(row);
            });
        }

        function openOverlay() {
            loadConfig();
            
            // Auto-update image_size based on current UI selection
            const sizeEntry = customPayloadConfig.find(p => p.key === 'image_size');
            if (sizeEntry && !sizeEntry.locked) {
                 const res = document.getElementById('resolution').value;
                 const ar = document.getElementById('aspectRatio').value;
                 
                 // Use getFalImageSize from main scope to get precise pixels
                 try {
                     const sizeObj = getFalImageSize(ar, res); 
                     // Only overwrite if it matches the 'json' type expectation
                     // or if we force it to become json (which we prefer for this field now)
                     sizeEntry.type = 'json';
                     sizeEntry.value = JSON.stringify(sizeObj);
                 } catch(e) {
                     // fallback
                     sizeEntry.type = 'json';
                     sizeEntry.value = '{"width":1024,"height":1024}';
                 }
            }

            renderList();
            customTaskOverlay.classList.remove('hidden');
            customEndpointInput.focus();
        }

        function closeOverlay() {
            customTaskOverlay.classList.add('hidden');
        }

        // Listeners
        addPayloadItemBtn.onclick = () => {
            customPayloadConfig.push({ key: '', type: 'string', value: '', locked: false });
            saveConfig();
            renderList();
        };

        customTaskCancelBtn.onclick = closeOverlay;

        promptInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter" && e.altKey) {
                e.preventDefault();
                e.stopPropagation();

                const hasPrompt = promptInput.value.trim().length > 0;
                
                if (!hasPrompt) {
                     showCopyToast("Custom Protocol: Prompt required", true);
                     return;
                }
                
                // Allow Opening without refs (Text-to-Image mode)
                openOverlay();
            }
        });

        // Submission Logic
        customTaskSubmitBtn.onclick = async () => {
            const endpointPath = customEndpointInput.value.trim();
            if (!endpointPath) {
                showCopyToast("Custom Protocol: Endpoint required", true);
                return;
            }
            
            // Generate Task ID
            const taskId = `${Date.now()}_${Math.random().toString(36).slice(2)}`;
            const currentPrompt = promptInput.value;
            const currentRefs = [...refImages]; // snapshot
            const currentRefIds = currentRefs.map(f => f.name); // simplistic ID

            closeOverlay();
            
            // Show skeleton immediately
            createSkeletonCard(taskId);

            // Register Pending Task (placeholder)
            // We reuse registerPendingTask to show the card immediately
            registerPendingTask(taskId, 
                { prompt: currentPrompt, refImagesSnapshot: currentRefs }, 
                { listId: MAIN_LIST_ID, createdAt: Date.now(), status: "UPLOADING" }
            );

            // Execute Custom Task
            try {
                const manager = getApiKeyManager("fal");
                let apiKey = manager.getNextKey(); // rotating key
                if (!apiKey) {
                    // Fallback to active provider if it is fal, else try to find one
                    const activeMgr = getApiKeyManager();
                    if (activeProvider === 'fal') apiKey = activeMgr.getNextKey();
                    // If still no key, we might fail or prompt.
                    // For now, proceed and let it fail if unauthorized.
                    if (!apiKey) throw new Error("No API Key configured for Fal AI.");
                }

                // Construct Payload
                const payload = {};
                for (const item of customPayloadConfig) {
                    if (item.key === 'prompt') {
                        payload[item.key] = currentPrompt;
                    } else if (item.key === 'image_url') {
                         // Build image data
                         // Using the first image as main reference
                         if (currentRefs.length > 0) {
                             const refPayload = await loadReferencePayload(currentRefs[0]);
                             payload[item.key] = `data:${refPayload.mimeType};base64,${refPayload.base64}`;
                         }
                    } else {
                        // Type casting
                        let val = item.value;
                        if (item.type === 'boolean') val = (val === 'true');
                        if (item.type === 'number') val = Number(val);
                        if (item.type === 'json') {
                             try {
                                 val = JSON.parse(val);
                             } catch(e) {
                                 console.warn("Invalid JSON for key " + item.key, e);
                                 // Fallback to string if parse fails, or throw error?
                                 // Let's keep it as string if it fails, maybe API handles it or it fails there.
                             }
                        }
                        payload[item.key] = val;
                    }
                }

                // Determine full URL (support queue or sync based on payload or assumption)
                // Defaulting to fal.run (Sync) unless sync_mode is explicitly false
                // But fal.run supports queue if /queue prefix is used? 
                // Using standard fal.run pattern: https://fal.run/{endpoint}
                // If user wants queue, they might need to adjust endpoint or we handle it?
                // The requirements say "custom endpoint". Let's assume user inputs "fal-ai/flux-pro"
                let url = `https://fal.run/${endpointPath}`;

                // Update Status
                updateSkeletonStatus(taskId, "Executing custom workflow...", "RUNNING");

                // Fetch
                const resp = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Key ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!resp.ok) {
                    const errText = await resp.text();
                    throw new Error(`Example Endpoint Error (${resp.status}): ${errText}`);
                }

                const data = await resp.json();

                // Extract Result
                const imagePayload = await extractFalImagePayload(data);
                if (!imagePayload || (!imagePayload.base64 && !imagePayload.remoteUrl)) {
                    throw new Error("No image data found in custom task response.");
                }

                // Render Success
                const resolvedMimeType = imagePayload.mimeType || "image/jpeg"; 
                // default jpeg as per requirement default config
                
                renderImageCard(
                    taskId,
                    imagePayload.base64 || null,
                    { 
                        resolution: "Custom", // Config doesn't track this explicitly unless we add it
                        aspectRatio: "Custom",
                        mimeType: resolvedMimeType, 
                        provider: "fal-custom",
                        remoteUrl: imagePayload.remoteUrl
                    },
                    currentPrompt,
                    {
                        timestamp: Date.now(),
                        listId: MAIN_LIST_ID,
                        refImageIds: currentRefIds,
                        skipDiskSave: !imagePayload.base64
                    }
                );

            } catch (err) {
                console.error("Custom Task Failed", err);
                renderErrorCard(taskId, err, null);
            }
        };

    })();

    // Run Start
    initApp();
  </script>
</body>
</html>
